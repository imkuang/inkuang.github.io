<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ming&#39;s Blog</title>
  
  <subtitle>Just do what you want to do</subtitle>
  <link href="https://blog.inkuang.com/atom.xml" rel="self"/>
  
  <link href="https://blog.inkuang.com/"/>
  <updated>2021-04-05T10:17:12.000Z</updated>
  <id>https://blog.inkuang.com/</id>
  
  <author>
    <name>Ming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 gulp 压缩 Hexo 博客文件（兼容 ES6 标准）</title>
    <link href="https://blog.inkuang.com/2021/405/"/>
    <id>https://blog.inkuang.com/2021/405/</id>
    <published>2021-04-05T10:17:12.000Z</published>
    <updated>2021-04-05T10:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用文本编辑器打开 Hexo 生成的博客文件，往往会发现其中存在大量的空格与空行，这虽然不影响代码发挥作用，但却会在一定程度上增加文件的大小。</p><p>实际上不止空白，这些由 Hexo 生成的文件中还有很多能够被优化以减小大小的地方，而要提高网站访问速度，减小资源文件的大小一直是最有效的手段之一。</p><span id="more"></span><p>gulp 是一个自动化构建工具，一般用于开发过程中执行一些常见任务，它有很多社区提供的强大插件可供使用，极大的简化了任务处理流程。在这里我们用它来对 Hexo 生成的博客文件进行压缩优化处理。</p><h2 id="其他教程存在的问题"><a href="#其他教程存在的问题" class="headerlink" title="其他教程存在的问题"></a>其他教程存在的问题</h2><p>使用关键词 <code>hexo gulp</code> 在网上搜索，可以搜到一堆类似的教程，但是根据我的实际测试，网上搜到的这些教程大部分都已经过时了，现在再使用的话或多或少的存在一些问题。</p><p>这些教程中一般都是通过安装 <code>gulp-minify-css</code>、<code>gulp-uglify</code>、<code>gulp-htmlclean</code>、<code>gulp-htmlmin</code> 这几个插件来处理的。下面按照压缩任务划分，分别说明一下现在还按照这些教程操作的话存在的一些问题。</p><h3 id="压缩-CSS-的问题"><a href="#压缩-CSS-的问题" class="headerlink" title="压缩 CSS 的问题"></a>压缩 CSS 的问题</h3><p>上面那几个插件中 <code>gulp-minify-css</code> 是用来压缩 CSS 代码的，使用命令 <code>npm install gulp-minify-css</code> 安装它，此时会发现在该命令的输出中存在如下的一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm WARN deprecated gulp-minify-css@1.2.4: Please use gulp-clean-css</span><br></pre></td></tr></table></figure><p>说得很明显了，这个插件已弃用，请使用 <code>gulp-clean-css</code> 。这虽然并不影响我们的正常使用该插件，但是有更好的替代品的话为什么还要用这个已弃用的插件呢？</p><h3 id="压缩-JS-的问题"><a href="#压缩-JS-的问题" class="headerlink" title="压缩 JS 的问题"></a>压缩 JS 的问题</h3><p>网上的大部分教程都是使用 <code>gulp-uglify</code> 来压缩 JS 代码，然而这个插件不兼容 JS 的 ES6 标准，导致在我的实际测试中（Hexo 5.x、NexT 8.x）使用该插件时出现了报错，如下所示，最后直接是“无法压缩 JavaScript”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[19:31:26] &#39;minify-js&#39; errored after 489 ms</span><br><span class="line">[19:31:26] GulpUglifyError: unable to minify JavaScript</span><br><span class="line">Caused by: SyntaxError: Unexpected token: punc «)»</span><br><span class="line">File: C:\Users\Administrator\Desktop\hexo\new-blog\public\js\local-search.js</span><br></pre></td></tr></table></figure><p>ES6 标准在2015年6月就正式通过了，现在已经过去了这么久，很多地方都有在使用，而 <code>gulp-uglify</code> 这个插件却完全不兼容，这无疑是个问题。</p><h3 id="压缩-HTML-的问题"><a href="#压缩-HTML-的问题" class="headerlink" title="压缩 HTML 的问题"></a>压缩 HTML 的问题</h3><p>上面提到的插件中 <code>gulp-htmlclean</code> 和 <code>gulp-htmlmin</code> 是用来压缩 HTML 代码的。</p><p>网上教程的一般做法是先将代码传递给 <code>gulp-htmlclean</code> 清理掉其中的空白，然后再传递给 <code>gulp-htmlmin</code> 来移除注释、压缩 HTML 文件中的 CSS、JS 代码等。然而查看 <code>gulp-htmlmin</code> 所基于的 <code>html-minifier</code> 的<a href="https://github.com/kangax/html-minifier#options-quick-reference">文档</a>发现，它有一个 <code>collapseWhitespace</code> 参数，设置为 <code>true</code> 时可以移除 HTML 代码中的空白块，那还多此一举的安装一个 <code>gulp-htmlclean</code> 插件干什么呢？</p><p>另外，上面提到了 <code>gulp-htmlmin</code> 可以压缩 HTML 中的 JS 代码，这个功能用的是跟 <code>gulp-uglify</code> 一样的底层库 <code>uglify-js</code> 来实现的，这也就导致它同样的不兼容 ES6 标准。最终会发现 HTML 文件中的内容并没有被全部压缩成“一行”，仍有部分 JS 代码是以未被压缩的形式存在的。</p><h2 id="我的解决办法"><a href="#我的解决办法" class="headerlink" title="我的解决办法"></a>我的解决办法</h2><p>针对上面那些问题，在一番查找资料与实际测试后，最终还是找到了一些在我看来比较完美的解决办法：</p><ul><li><strong>压缩 CSS：</strong> 这个是最简单的，按照它的提示换成 <code>gulp-clean-css</code> 这个插件就行了。</li><li><strong>压缩 JS：</strong> 针对这个问题网上有一种在我看来比较“邪教”的做法：使用 babel 将 ES6 标准的代码编译为 ES5 标准的代码然后再继续使用 gulp-uglify 进行压缩。怎么说呢，这样做确实是可行的，但就是看着有种不爽的感觉。经过搜索，最后找到了 <code>gulp-uglify-es</code> 这个插件，它将底层库替换成了 <code>terser</code>，可以完美支持 ES6 标准。</li><li><strong>压缩 HTML：</strong> 同样要解决对 ES6 标准支持的问题，最终换到了 <code>gulp-html-minifier-terser</code> 这个插件，它是 <code>gulp-htmlmin</code> 的 fork，但是将底层库换成了 <code>html-minifier-terser</code>（<code>html-minifier</code> 的 fork，将压缩 JS 代码的功能修改为了使用 <code>terser</code> 库处理）。其次就是不再使用 <code>gulp-htmlclean</code> 插件，改为在使用 <code>gulp-html-minifier-terser</code> 插件时传入参数 <code>collapseWhitespace: true</code>。</li></ul><h2 id="操作方法及任务配置"><a href="#操作方法及任务配置" class="headerlink" title="操作方法及任务配置"></a>操作方法及任务配置</h2><p>根据 gulp 及各个插件的文档，我们首先需要全局安装 <code>gulp-cli</code>，然后在博客工作目录下安装需要的插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli</span><br><span class="line">npm install gulp gulp-clean-css gulp-uglify-es gulp-html-minifier-terser</span><br></pre></td></tr></table></figure><p>安装完成后在博客工作目录下新建文件 <code>gulpfile.js</code> ，写入如下 gulp 任务配置代码（详细描述见注释）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cleancss = <span class="built_in">require</span>(<span class="string">&#x27;gulp-clean-css&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify-es&#x27;</span>).default;</span><br><span class="line"><span class="keyword">const</span> htmlmin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-html-minifier-terser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩public目录下的css文件</span></span><br><span class="line"><span class="comment">// 可接受参数的文档：https://github.com/jakubpawlowicz/clean-css#constructor-options</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-css&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.css&#x27;</span>)           <span class="comment">// 处理public目录下所有的css文件，下同</span></span><br><span class="line">        .pipe(cleancss(&#123; <span class="attr">compatibility</span>: <span class="string">&#x27;ie8&#x27;</span> &#125;))  <span class="comment">// 兼容到IE8</span></span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩public目录下的js文件</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-js&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.js&#x27;</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩public目录下的html文件</span></span><br><span class="line"><span class="comment">// 可接受参数的文档：https://github.com/terser/html-minifier-terser#options-quick-reference</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-html&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./public/**/*.html&#x27;</span>)</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: <span class="literal">true</span>,                 <span class="comment">// 移除注释</span></span><br><span class="line">            removeEmptyAttributes: <span class="literal">true</span>,          <span class="comment">// 移除值为空的参数</span></span><br><span class="line">            removeRedundantAttributes: <span class="literal">true</span>,      <span class="comment">// 移除值跟默认值匹配的属性</span></span><br><span class="line">            collapseBooleanAttributes: <span class="literal">true</span>,      <span class="comment">// 省略布尔属性的值</span></span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>,             <span class="comment">// 移除空格和空行</span></span><br><span class="line">            minifyCSS: <span class="literal">true</span>,                      <span class="comment">// 压缩HTML中的CSS</span></span><br><span class="line">            minifyJS: <span class="literal">true</span>,                       <span class="comment">// 压缩HTML中的JS</span></span><br><span class="line">            minifyURLs: <span class="literal">true</span>                      <span class="comment">// 压缩HTML中的链接</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">&#x27;./public&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认任务，不带任务名运行gulp时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">&#x27;default&#x27;</span>, gulp.parallel(</span><br><span class="line">    <span class="string">&#x27;minify-css&#x27;</span>, <span class="string">&#x27;minify-js&#x27;</span>, <span class="string">&#x27;minify-html&#x27;</span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>保存之后先用 <code>hexo g</code> 生成博客文件，然后执行命令 <code>gulp</code> 就可以对刚刚生成的博客文件（public 目录下的文件）进行压缩优化处理了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用文本编辑器打开 Hexo 生成的博客文件，往往会发现其中存在大量的空格与空行，这虽然不影响代码发挥作用，但却会在一定程度上增加文件的大小。&lt;/p&gt;
&lt;p&gt;实际上不止空白，这些由 Hexo 生成的文件中还有很多能够被优化以减小大小的地方，而要提高网站访问速度，减小资源文件的大小一直是最有效的手段之一。&lt;/p&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="自动化" scheme="https://blog.inkuang.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="Hexo" scheme="https://blog.inkuang.com/tags/Hexo/"/>
    
    <category term="博客" scheme="https://blog.inkuang.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移（升级）说明</title>
    <link href="https://blog.inkuang.com/2021/403/"/>
    <id>https://blog.inkuang.com/2021/403/</id>
    <published>2021-04-03T06:10:25.000Z</published>
    <updated>2021-04-03T06:10:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间因为自己忙于其他的事情，再加上懒，博客鸽了有大半年没有更新。最近终于闲下来了，重新折腾一下，把博客彻底的“翻新”了一遍，也算是一个新的开始吧。</p><p>本次“翻新”对 Hexo 和 NexT 主题的版本进行了升级，更换了域名，重新设计（调整）了主题样式，包括博客名称之类的也进行了更换，变动可谓是相当的大。</p><span id="more"></span><h2 id="主要变动"><a href="#主要变动" class="headerlink" title="主要变动"></a>主要变动</h2><p>这次博客的“翻新”并不是传统意义上升级的那种形式，而是直接建了一个新的博客，然后把原博客的文章搬过来，这也是标题中我把这个过程叫做“迁移”的主要原因。下面简单的列举一下主要的变动项吧：</p><ul><li>博客域名：<code>xirikm.net</code> -&gt; <code>blog.inkuang.com</code></li><li>博客名称：<code>昔日的夕日</code> -&gt; <code>Ming&#39;s Blog</code></li><li>博主昵称： <code>夕日</code> -&gt; <code>Ming</code></li><li>Hexo 版本：<code>3.x</code> -&gt; <code>5.x</code></li><li>NexT 主题版本：<code>7.1.0</code> -&gt; <code>8.x</code></li><li>主题样式修改：<code>都是自己魔改的，没有具体名字</code></li></ul><p>总的来说，这次“翻新”的变动还是挺大的，完全可以当作是一个全新的博客了，只是两个博客的博主是同一个人而已。</p><p>扔掉旧的包袱，站在新的起点，迎接一个新的开始！</p><h2 id="旧文章处理"><a href="#旧文章处理" class="headerlink" title="旧文章处理"></a>旧文章处理</h2><p>在本文发布后，“旧博客”那边会发布一篇类似的文章，然后正式停更，后续的文章更新都在这个“新博客”进行。</p><p>我会将旧博客的大部分文章迁移过来，但不是全部。那些我认为没什么意义的，或者跟旧博客本身高度相关的文章（如博客日志、更新情况之类的），就让它们随着旧博客一起消亡吧。</p><p>旧博客站点将会继续保留到其域名过期或者服务器到期，其中已迁移的那些文章会进行重定向操作，将其链接跳转到这个新博客中对应的文章。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间因为自己忙于其他的事情，再加上懒，博客鸽了有大半年没有更新。最近终于闲下来了，重新折腾一下，把博客彻底的“翻新”了一遍，也算是一个新的开始吧。&lt;/p&gt;
&lt;p&gt;本次“翻新”对 Hexo 和 NexT 主题的版本进行了升级，更换了域名，重新设计（调整）了主题样式，包括博客名称之类的也进行了更换，变动可谓是相当的大。&lt;/p&gt;</summary>
    
    
    
    <category term="博客日志" scheme="https://blog.inkuang.com/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Hexo" scheme="https://blog.inkuang.com/tags/Hexo/"/>
    
    <category term="博客" scheme="https://blog.inkuang.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的那些官方彩蛋</title>
    <link href="https://blog.inkuang.com/2020/719/"/>
    <id>https://blog.inkuang.com/2020/719/</id>
    <published>2020-07-19T12:58:04.000Z</published>
    <updated>2020-07-19T12:58:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近比较忙，都没怎么碰过博客，刚刚发现好像已经有将近两个月没有更新了，赶紧过来<del>发</del>水一篇压压惊。</p><h2 id="彩蛋一：antigravity"><a href="#彩蛋一：antigravity" class="headerlink" title="彩蛋一：antigravity"></a>彩蛋一：antigravity</h2><p>antigravity 翻译过来是反重力、反引力的意思，在 Python 中 <code>import antigravity</code> 会自动打开一个 Python 的经典 XKCD 漫画页面：<a href="https://xkcd.com/353/">https://xkcd.com/353/</a></p><span id="more"></span><p><img data-src="/images/2020/0719/1.png"></p><p>XKCD 是由兰德尔·门罗（Randall Munroe）所绘制的网络漫画，他给作品的定义是一部“关于浪漫、讽刺、数学和语言的网络漫画”。上面的这幅漫画就是在表现 Python 的简单易用，飞一般的感觉，翻译如下：</p><blockquote><p>A：你在飞！怎么做到的？<br>B：Python！我昨晚刚刚学会了 Python。一切都变得如此简单！写一个 Hello World 程序只要一行代码 print “Hello World!” 就搞定了！<br>A：什么情况？呃……动态类型？泛空格符？<br>B：来加入我们吧，有了 Python，编程再次变得有趣。这是一个全新的世界！<br>A：但是你到底是怎么飞在天上的？<br>B：我只是输入了“import antigravity”命令而已。<br>A：就这样？<br>B：我还把药柜中的药嗑了个遍……但我觉得还是 Python 的原因。</p></blockquote><p>这个模块是 Python 开发人员发布的少数复活节彩蛋之一。不止如此，在这个复活节彩蛋中还有另一个彩蛋：如果你看一下<a href="https://github.com/python/cpython/blob/master/Lib/antigravity.py#L7-L17">该模块的代码</a>，就会发现其中还有一个函数实现了另一则 XKCD 漫画中的 <a href="https://xkcd.com/426/">geohashing 算法</a>。</p><h2 id="彩蛋二：this"><a href="#彩蛋二：this" class="headerlink" title="彩蛋二：this"></a>彩蛋二：this</h2><p>在 Python 标准库中有一个叫做 <code>this</code> 的模块，导入这个模块会输出著名的“Python 之禅”的内容，除此之外没有任何其他功能，如下图：</p><p><img data-src="/images/2020/0719/2.png"></p><p>这是一个关于 Python 之禅的复活节彩蛋（<a href="https://www.python.org/dev/peps/pep-0020/">PEP 20</a>），有兴趣的可以自己去看看它的<a href="https://github.com/python/cpython/blob/master/Lib/this.py">实现代码</a>。有趣的是，这个输出 Python 之禅的代码似乎自己违反了 Python 之禅。</p><h2 id="彩蛋三：-future"><a href="#彩蛋三：-future" class="headerlink" title="彩蛋三：__future__"></a>彩蛋三：__future__</h2><p>在 Python 中 <code>__future__</code> 模块通常会提供一些未来版本的功能，比如 <code>from __future__ import print_function</code> 可以让你在 Python2 中使用 Python3 的 <code>print()</code>。</p><p>如果你不喜欢在 Python 中使用空格来表示作用域，试试导入 C 语言风格的 <code>&#123;&#125;</code> ？使用代码 <code>from __future__ import braces</code> （大括号的英文为 braces），很遗憾，你会得到如下报错：SyntaxError: not a chance，没有机会这样做。</p><p><img data-src="/images/2020/0719/3.png"></p><p>这是一个表达社区对此类问题态度的复活节彩蛋。不要想着这样做了，没有机会的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近比较忙，都没怎么碰过博客，刚刚发现好像已经有将近两个月没有更新了，赶紧过来&lt;del&gt;发&lt;/del&gt;水一篇压压惊。&lt;/p&gt;
&lt;h2 id=&quot;彩蛋一：antigravity&quot;&gt;&lt;a href=&quot;#彩蛋一：antigravity&quot; class=&quot;headerlink&quot; title=&quot;彩蛋一：antigravity&quot;&gt;&lt;/a&gt;彩蛋一：antigravity&lt;/h2&gt;&lt;p&gt;antigravity 翻译过来是反重力、反引力的意思，在 Python 中 &lt;code&gt;import antigravity&lt;/code&gt; 会自动打开一个 Python 的经典 XKCD 漫画页面：&lt;a href=&quot;https://xkcd.com/353/&quot;&gt;https://xkcd.com/353/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="逸趣杂谈" scheme="https://blog.inkuang.com/categories/%E9%80%B8%E8%B6%A3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="Python" scheme="https://blog.inkuang.com/tags/Python/"/>
    
    <category term="杂谈" scheme="https://blog.inkuang.com/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="彩蛋" scheme="https://blog.inkuang.com/tags/%E5%BD%A9%E8%9B%8B/"/>
    
  </entry>
  
  <entry>
    <title>解决腾讯云服务器内存不足量的问题</title>
    <link href="https://blog.inkuang.com/2020/524/"/>
    <id>https://blog.inkuang.com/2020/524/</id>
    <published>2020-05-24T01:35:54.000Z</published>
    <updated>2020-05-24T01:35:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯云服务器安装 Debian 或 Ubuntu 系统后使用 <code>free</code> 命令查看内存大小往往会发现比所购买配置的标称内存要小很多，1G 内存的实例通常只有 860M 左右，2G 内存的查出来也只有 1870M 左右。</p><span id="more"></span><p>如下图所示（2G 内存）：</p><p><img data-src="/images/2020/0524/1.png"></p><p>一开始我也和大多数人想的一样，认为这是黑心商家为了多赚钱故意少分配了内存，然而最近了解了一下情况之后发现这事还真是误会腾讯云了，下面简单的记录一下问题原因和解决方案吧。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>使用命令 <code>dmidecode</code> 查看底层硬件信息，可以看到我的 2G 内存的服务器是分配足了 2048M 内存的。</p><p><img data-src="/images/2020/0524/2.png" alt="使用 dmidecode 命令查看底层硬件信息"></p><p>但是为什么使用 <code>free</code> 命令看到的内存变少了呢？查阅资料找到了答案：<code>free</code> 命令看到的是伙伴系统管理的内存，这部分内存是不包括 OS 内核一些基本数据结构消耗以及内核预留内存的。</p><p>使用命令 <code>dmesg | grep -i memory</code> 查看内核预留内存，注意到如下部分：</p><p><img data-src="/images/2020/0524/3.png" alt="查看系统中的内核预留内存"></p><p>嗯，为 <code>crashkernel</code> 预留了 128M 的内存，很明显这就是导致我们“内存不足量”的罪魁祸首。</p><p>腾讯云提供的 Debian 和 Ubuntu 系统镜像默认开启了 kdump 服务，当 Linux 内核出现了故障时 kdump 会协助产生一个 dump 文件，记录下此时的内存运行参数等信息，便于用户后续对内核问题的定位分析。而上面提到的“为 <code>crashkernel</code> 预留的内存”就是用于这一服务的，也就是导致我们“内存不足量”的元凶。</p><p>这一服务对于那些注重安全的大公司来说可能会有些用处，但我们这种个人用途的低配置服务器也开着的话就没有什么必要了，本身内存就不大，还要为这服务分出去一部分不能用，想想还是有点浪费的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然问题是由于系统为 kdump 服务预留了一部分内存导致的，那我们把 kdump 服务关了就行了。</p><p>暴力点，直接卸载 kdump-tools：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt purge kdump-tools</span><br></pre></td></tr></table></figure><p>卸载后顺便清理一下它的那些已经用不到了的依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt autoremove</span><br></pre></td></tr></table></figure><p>然后编辑 <code>/etc/default/grub</code> 文件，将其中的 <code>crashkernel=xxx</code> 字段全部删掉，我这里的修改情况如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 待修改的两行配置</span></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;crashkernel=384M-:128M&quot;</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;net.ifnames=0 biosdevname=0 console=ttyS0,115200 console=tty0 panic=5 crashkernel=auto&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的配置</span></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;&quot;</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;net.ifnames=0 biosdevname=0 console=ttyS0,115200 console=tty0 panic=5&quot;</span></span><br></pre></td></tr></table></figure><p>修改完之后执行 <code>update-grub2</code> 更新 grub 引导文件，最后再重启一下服务器就可以啦！</p><p>如下图所示，重启后可用内存变成了 2004M（比之前多了 128M）：</p><p><img data-src="/images/2020/0524/4.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;腾讯云服务器安装 Debian 或 Ubuntu 系统后使用 &lt;code&gt;free&lt;/code&gt; 命令查看内存大小往往会发现比所购买配置的标称内存要小很多，1G 内存的实例通常只有 860M 左右，2G 内存的查出来也只有 1870M 左右。&lt;/p&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.inkuang.com/tags/Linux/"/>
    
    <category term="内存" scheme="https://blog.inkuang.com/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="腾讯云" scheme="https://blog.inkuang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 SMTP 发送邮件</title>
    <link href="https://blog.inkuang.com/2020/414/"/>
    <id>https://blog.inkuang.com/2020/414/</id>
    <published>2020-04-14T11:02:21.000Z</published>
    <updated>2020-09-06T14:35:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>SMTP 全称为 Simple Mail Transfer Protocol，即简单邮件传输协议，它是一组用于从源地址到目的地址传送邮件的规则，同时会控制信件的中转方式，一般我们发送邮件都是通过这一协议来完成的。</p><p>Python 内置的 smtplib 模块对 SMTP 协议进行了简单的封装，借助它我们可以很轻松的实现用代码来发送邮件。</p><span id="more"></span><h2 id="连接-SMTP-服务器"><a href="#连接-SMTP-服务器" class="headerlink" title="连接 SMTP 服务器"></a>连接 SMTP 服务器</h2><p>要发送邮件，很明显需要先连接到一个可用的邮件服务器，为此我们需要指定服务器地址和端口。</p><p>由于各种历史遗留问题，现在仍在使用的 SMTP 服务端口有三个，分别是：25端口（明文传输）、465端口（SSL 加密）和 587端口（STARTTLS 加密）。不同的端口处理情况稍有不同，下面在代码中分别演示三种端口的连接方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 25端口（明文传输）</span></span><br><span class="line">smtp_server = smtplib.SMTP(host=<span class="string">&quot;smtp.xxx.xxx&quot;</span>, port=<span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 465端口（SSL加密）</span></span><br><span class="line">smtp_server = smtplib.SMTP_SSL(host=<span class="string">&quot;smtp.xxx.xxx&quot;</span>, port=<span class="number">465</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 587端口（STARTTLS加密）</span></span><br><span class="line">smtp_server = smtplib.SMTP(host=<span class="string">&quot;smtp.xxx.xxx&quot;</span>, port=<span class="number">587</span>)</span><br><span class="line">smtp_server.starttls()</span><br></pre></td></tr></table></figure><h2 id="登录-SMTP-服务器"><a href="#登录-SMTP-服务器" class="headerlink" title="登录 SMTP 服务器"></a>登录 SMTP 服务器</h2><p>连上服务器之后还需要用我们的邮箱登录才能发送邮件（注意 QQ 邮箱、163 邮箱等使用 SMTP 服务需要的密码是在后台申请的授权码，不是你在网页上登录邮箱时用的密码）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smtp_server.login(user=<span class="string">&quot;test@xxx.xxx&quot;</span>, password=<span class="string">&quot;test_password&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="构造邮件"><a href="#构造邮件" class="headerlink" title="构造邮件"></a>构造邮件</h2><p>电子邮件本质上可以看作一种按特定格式组织的文本文件，除了正文内容之外，标准邮件一般还需要三个头部信息： From（发件人）, To（收件人）和 Subject（邮件主题）。所以说发送邮件并不是将你想发的内容传过去就行了，我们还需要先按照一定的规则“构造”一封邮件。</p><p>常见的邮件主要有纯文本邮件、HTML 邮件、带附件的邮件几种类型，下面分别演示这三种类型邮件的构造方式。</p><h3 id="纯文本邮件"><a href="#纯文本邮件" class="headerlink" title="纯文本邮件"></a>纯文本邮件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line">content = <span class="string">&quot;这是一封纯文本邮件&quot;</span></span><br><span class="line">subject = <span class="string">&quot;纯文本邮件测试&quot;</span></span><br><span class="line">from_user = <span class="string">&quot;test@xxx.xxx&quot;</span></span><br><span class="line">to_user = <span class="string">&quot;test2@xxx.xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造邮件主体</span></span><br><span class="line">my_mail = MIMEText(content, _subtype=<span class="string">&quot;plain&quot;</span>, _charset=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"><span class="comment"># 添加发件人</span></span><br><span class="line">my_mail[<span class="string">&quot;From&quot;</span>] = from_user</span><br><span class="line"><span class="comment"># 添加收件人</span></span><br><span class="line">my_mail[<span class="string">&quot;To&quot;</span>] = to_user</span><br><span class="line"><span class="comment"># 添加邮件主题</span></span><br><span class="line">my_mail[<span class="string">&quot;subject&quot;</span>] = subject</span><br></pre></td></tr></table></figure><h3 id="HTML-邮件"><a href="#HTML-邮件" class="headerlink" title="HTML 邮件"></a>HTML 邮件</h3><p>构造 HTML 邮件只需要将构造纯文本邮件代码中 <code>MIMEText()</code> 的 _subtype 参数修改为 html 即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_mail = MIMEText(content, _subtype=<span class="string">&quot;html&quot;</span>, _charset=<span class="string">&quot;utf8&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="带附件的邮件"><a href="#带附件的邮件" class="headerlink" title="带附件的邮件"></a>带附件的邮件</h3><p>带附件的邮件与上面两种稍有不同，我们需要借助 <code>MIMEMultipart()</code> 构造一封多组件邮件，再将文本内容、附件内容依次添加进去，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line">content = <span class="string">&quot;这是一封带附件的邮件&quot;</span></span><br><span class="line">subject = <span class="string">&quot;带附件的邮件测试&quot;</span></span><br><span class="line">from_user = <span class="string">&quot;test@xxx.xxx&quot;</span></span><br><span class="line">to_user = <span class="string">&quot;test2@xxx.xxx&quot;</span></span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;xxx/test.txt&quot;</span>   <span class="comment"># 附件所在的路径</span></span><br><span class="line">file_name = <span class="string">&quot;test.txt&quot;</span>   <span class="comment"># 附件在邮件中显示的文件名</span></span><br><span class="line">file_content = <span class="built_in">open</span>(file_path, <span class="string">&quot;rb&quot;</span>).read()  <span class="comment"># 读取附件内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造一封多组件的邮件</span></span><br><span class="line">my_mail = MIMEMultipart()</span><br><span class="line"><span class="comment"># 往多组件邮件中加入文本内容</span></span><br><span class="line">text_msg = MIMEText(content, _subtype=<span class="string">&quot;plain&quot;</span>, _charset=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">my_mail.attach(text_msg)</span><br><span class="line"><span class="comment"># 往多组件邮件中加入附件</span></span><br><span class="line">file_msg = MIMEApplication(file_content)</span><br><span class="line">file_msg.add_header(<span class="string">&quot;content-disposition&quot;</span>, <span class="string">&quot;attachment&quot;</span>, filename=file_name)</span><br><span class="line">my_mail.attach(file_msg)</span><br><span class="line"><span class="comment"># 添加发件人</span></span><br><span class="line">my_mail[<span class="string">&quot;From&quot;</span>] = from_user</span><br><span class="line"><span class="comment"># 添加收件人</span></span><br><span class="line">my_mail[<span class="string">&quot;To&quot;</span>] = to_user</span><br><span class="line"><span class="comment"># 添加邮件主题</span></span><br><span class="line">my_mail[<span class="string">&quot;subject&quot;</span>] = subject</span><br></pre></td></tr></table></figure><h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><p>构造好了邮件，连接并登录了 SMTP 服务器，接下来要发送邮件就很简单了，直接调用 <code>send_message()</code> 函数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接到服务器并登录好的SMTP对象</span></span><br><span class="line">smtp_server = ......</span><br><span class="line"><span class="comment"># 前面构造好的邮件</span></span><br><span class="line">my_mail = ......</span><br><span class="line"><span class="comment"># 发件人邮箱</span></span><br><span class="line">from_user = <span class="string">&quot;test@xxx.xxx&quot;</span></span><br><span class="line"><span class="comment"># 收件邮箱</span></span><br><span class="line">to_user = <span class="string">&quot;test2@xxx.xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送邮件</span></span><br><span class="line">smtp_server.send_message(my_mail)</span><br></pre></td></tr></table></figure><h2 id="封装邮件发送方法"><a href="#封装邮件发送方法" class="headerlink" title="封装邮件发送方法"></a>封装邮件发送方法</h2><p>像上面这样一步步构造邮件、发送邮件，写一次还好，经常需要这样写的话还是有点繁琐的，所以我们来给它稍微封装一下，以后直接调用即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> email</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MailSender</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    邮件发送器，封装smtp发送邮件的常用操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, user: <span class="built_in">str</span>, password: <span class="built_in">str</span>, host: <span class="built_in">str</span>, port: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化smtp服务器连接</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param user: 邮箱用户，支持 name&lt;prefix@example.com&gt; 的形式，会自动从中提取邮箱地址用于登录</span></span><br><span class="line"><span class="string">        :param password: smtp登录密码</span></span><br><span class="line"><span class="string">        :param host: smtp服务器地址</span></span><br><span class="line"><span class="string">        :param port: smtp服务器端口，仅能使用25、465和587</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__user = user</span><br><span class="line">        <span class="comment"># 提取出邮箱地址用于登录</span></span><br><span class="line">        self.__login_mail = email.utils.getaddresses([user])[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 连接到smtp服务器，限制只允许使用25、465、587这三个端口</span></span><br><span class="line">        <span class="keyword">if</span> port == <span class="number">25</span>:</span><br><span class="line">            self.__smtp_server = smtplib.SMTP(host=host, port=port)</span><br><span class="line">        <span class="keyword">elif</span> port == <span class="number">465</span>:</span><br><span class="line">            self.__smtp_server = smtplib.SMTP_SSL(host=host, port=port)</span><br><span class="line">        <span class="keyword">elif</span> port == <span class="number">587</span>:</span><br><span class="line">            self.__smtp_server = smtplib.SMTP(host=host, port=port)</span><br><span class="line">            self.__smtp_server.starttls()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Can only use port 25, 465 and 587&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 登录smtp服务器</span></span><br><span class="line">        self.__smtp_server.login(user=self.__login_mail, password=password)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self, to_user: <span class="built_in">str</span>, subject: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>, content: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>, subtype: <span class="built_in">str</span> = <span class="string">&quot;plain&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        发送纯文本邮件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param to_user: 收件人，支持 name&lt;prefix@example.com&gt; 的形式，如需同时发给多人，将多个收件人用半角逗号隔开即可</span></span><br><span class="line"><span class="string">        :param subject: 邮件主题，默认为空字符串</span></span><br><span class="line"><span class="string">        :param content: 邮件正文，默认为空字符串</span></span><br><span class="line"><span class="string">        :param subtype: 邮件文本类型，只能为 plain 或 html，默认为 plain</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__check_subtype(subtype)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造邮件</span></span><br><span class="line">        msg = MIMEText(content, _subtype=subtype, _charset=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        msg[<span class="string">&quot;From&quot;</span>] = self.__user</span><br><span class="line">        msg[<span class="string">&quot;To&quot;</span>] = to_user</span><br><span class="line">        msg[<span class="string">&quot;subject&quot;</span>] = subject</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送邮件</span></span><br><span class="line">        self.__smtp_server.send_message(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_with_attachment</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        to_user: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        attachment_path: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        attachment_name: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        subject: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        content: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        subtype: <span class="built_in">str</span> = <span class="string">&quot;plain&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        发送带附件的邮件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param to_user: 收件人，支持 name&lt;prefix@example.com&gt; 的形式，如需同时发给多人，将多个收件人用半角逗号隔开即可</span></span><br><span class="line"><span class="string">        :param attachment_path: 附件文件的路径</span></span><br><span class="line"><span class="string">        :param attachment_name: 附件在邮件中显示的名字，设为空字符串时（默认）直接使用文件名</span></span><br><span class="line"><span class="string">        :param subject: 邮件主题，默认为空字符串</span></span><br><span class="line"><span class="string">        :param content: 邮件正文，默认为空字符串</span></span><br><span class="line"><span class="string">        :param subtype: 邮件文本类型，只能为 plain 或 html，默认为 plain</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.__check_subtype(subtype)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 读取附件内容</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(attachment_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            file_content = f.read()</span><br><span class="line">        <span class="comment"># 默认以文件名作为附件名</span></span><br><span class="line">        <span class="keyword">if</span> attachment_name == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            attachment_name = os.path.basename(attachment_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造一封多组件邮件</span></span><br><span class="line">        msg = MIMEMultipart()</span><br><span class="line">        <span class="comment"># 添加文本内容</span></span><br><span class="line">        text_msg = MIMEText(content, _subtype=subtype, _charset=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">        msg.attach(text_msg)</span><br><span class="line">        <span class="comment"># 添加附件</span></span><br><span class="line">        file_msg = MIMEApplication(file_content)</span><br><span class="line">        file_msg.add_header(</span><br><span class="line">            <span class="string">&quot;content-disposition&quot;</span>, <span class="string">&quot;attachment&quot;</span>, filename=attachment_name</span><br><span class="line">        )</span><br><span class="line">        msg.attach(file_msg)</span><br><span class="line"></span><br><span class="line">        msg[<span class="string">&quot;From&quot;</span>] = self.__user</span><br><span class="line">        msg[<span class="string">&quot;To&quot;</span>] = to_user</span><br><span class="line">        msg[<span class="string">&quot;subject&quot;</span>] = subject</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送邮件</span></span><br><span class="line">        self.__smtp_server.send_message(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__check_subtype</span>(<span class="params">self, subtype: <span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> subtype <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&quot;plain&quot;</span>, <span class="string">&quot;html&quot;</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Error subtype, only &quot;plain&quot; and &quot;html&quot; can be used&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>调用时只需要先实例化一个 <code>MailSender</code> 对象，然后就可以使用对应的 send 函数来发送邮件了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test_msg = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;p&gt;邮件发送测试&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;&lt;a href=&quot;https://xirikm.net/&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    attachment_path = <span class="string">&quot;xxx/xxx.txt&quot;</span>  <span class="comment"># 附件的文件路径</span></span><br><span class="line"></span><br><span class="line">    sender = MailSender(<span class="string">&quot;test@xxx.xxx&quot;</span>, <span class="string">&quot;test_password&quot;</span>, <span class="string">&quot;smtp.xxx.xxx&quot;</span>, <span class="number">587</span>)</span><br><span class="line"></span><br><span class="line">    sender.send(<span class="string">&quot;test2@xxx.xxx&quot;</span>, <span class="string">&quot;纯文本邮件&quot;</span>, test_msg, <span class="string">&quot;plain&quot;</span>)</span><br><span class="line">    sender.send(<span class="string">&quot;test2@xxx.xxx&quot;</span>, <span class="string">&quot;html邮件&quot;</span>, test_msg, <span class="string">&quot;html&quot;</span>)</span><br><span class="line">    sender.send_with_attachment(</span><br><span class="line">        <span class="string">&quot;test2@xxx.xxx&quot;</span>, attachment_path, <span class="string">&quot;xxx.txt&quot;</span>, <span class="string">&quot;带附件的html邮件&quot;</span>, test_msg, <span class="string">&quot;html&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 默认参数测试</span></span><br><span class="line">    sender.send_with_attachment(<span class="string">&quot;test2@xxx.xxx&quot;</span>, attachment_path)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SMTP 全称为 Simple Mail Transfer Protocol，即简单邮件传输协议，它是一组用于从源地址到目的地址传送邮件的规则，同时会控制信件的中转方式，一般我们发送邮件都是通过这一协议来完成的。&lt;/p&gt;
&lt;p&gt;Python 内置的 smtplib 模块对 SMTP 协议进行了简单的封装，借助它我们可以很轻松的实现用代码来发送邮件。&lt;/p&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Python" scheme="https://blog.inkuang.com/tags/Python/"/>
    
    <category term="邮件" scheme="https://blog.inkuang.com/tags/%E9%82%AE%E4%BB%B6/"/>
    
    <category term="SMTP" scheme="https://blog.inkuang.com/tags/SMTP/"/>
    
  </entry>
  
  <entry>
    <title>测试 TCP BBR 对网络丢包的改善效果</title>
    <link href="https://blog.inkuang.com/2020/322/"/>
    <id>https://blog.inkuang.com/2020/322/</id>
    <published>2020-03-22T03:36:08.000Z</published>
    <updated>2020-03-22T03:36:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP BBR 出来已经有挺长一段时间了，都说它可以减少 TCP 连接的延迟、改善存在丢包的网络环境速度，虽然我自己一直在用，但由于从来没有测试过，所以对它具体能发挥多大的作用还是存疑的。</p><p>正好最近了解到了一个命令 <code>tc</code> ，可以模拟网络延迟和丢包，于是决定来亲自测试一下 BBR 对网络丢包的改善效果。</p><span id="more"></span><p>TCP BBR 开启和关闭的教程可以查看之前的文章：<a href="/2019/318/">内核版本 4.9 以上的 Linux 系统开启/关闭 BBR 的方法</a></p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>为了获得充足的网速以便能够看到明显效果，同时排除其他环境因素的影响，本次测试在本地回环地址 <code>127.0.0.1</code> 上进行。输入 <code>ifconfig</code> 可以查看网卡情况，我这里绑定地址 <code>127.0.0.1</code> 的网卡名为 <code>lo</code> 。</p><p>在本地起一个监听 <code>127.0.0.1</code> 的 http 服务（我这里是用 caddy 实现的），然后在其中放一个比较大的文件（我这里是一个 600 多兆的系统镜像），后续将通过 wget 下载该文件来测试网络速度。</p><p>为了避免硬盘本身写入速度的限制，这里直接将文件 wget 到内存当中去（使用内存设备文件 <code>/dev/shm</code> ）</p><h2 id="模拟丢包网络环境"><a href="#模拟丢包网络环境" class="headerlink" title="模拟丢包网络环境"></a>模拟丢包网络环境</h2><p>这里使用 <code>tc</code> 命令来模拟所需要的网络环境，该命令的具体用法不再多说，自己输入 <code>man tc</code> 查看即可。</p><p>执行以下命令可以在网卡 <code>lo</code> 上模拟 10% 的丢包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev lo root netem loss 10%</span><br></pre></td></tr></table></figure><p>要恢复正常情况的话执行以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc del root dev lo</span><br></pre></td></tr></table></figure><h2 id="测试过程及结果"><a href="#测试过程及结果" class="headerlink" title="测试过程及结果"></a>测试过程及结果</h2><p>先进入内存设备文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;dev&#x2F;shm</span><br></pre></td></tr></table></figure><p>使用以下命令从回环地址 <code>127.0.0.1</code> 的 http 服务中下载文件进行测速：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;debian-10.3.0-amd64-xfce-CD-1.iso</span><br></pre></td></tr></table></figure><h3 id="不开启-BBR-的结果"><a href="#不开启-BBR-的结果" class="headerlink" title="不开启 BBR 的结果"></a>不开启 BBR 的结果</h3><p>不开启 BBR ，<strong>在正常（无丢包）网络环境下</strong>的测试结果如下图，640M 的文件下载花了 0.7s ，还是很快的。</p><p><img data-src="/images/2020/0322/1.png" alt="不开启 BBR，正常网络环境的下载速度"></p><p>不开启 BBR ，<strong>在 1% 丢包网络环境下</strong>的测试结果如下图，640M 的文件花了 5.5s 下完，相比正常情况下的网络速度有一定程度降低。</p><p><img data-src="/images/2020/0322/2.png" alt="不开启 BBR，1% 丢包网络环境的下载速度"></p><p>不开启 BBR ，<strong>在 10% 丢包网络环境下</strong>的测试结果如下图，可以看到同样 640M 的文件下载花了 50s ，相比正常情况下网络速度发生了大幅度降低。</p><p><img data-src="/images/2020/0322/3.png" alt="不开启 BBR，10% 丢包网络环境的下载速度"></p><h3 id="开启-BBR-的结果"><a href="#开启-BBR-的结果" class="headerlink" title="开启 BBR 的结果"></a>开启 BBR 的结果</h3><p>开启 BBR ，<strong>在正常（无丢包）网络环境下</strong>的测试结果如下图，640M 的文件同样花了 0.7s 下完，跟不开启 BBR 时的速度没有差别。</p><p><img data-src="/images/2020/0322/4.png" alt="开启 BBR，正常网络环境的下载速度"></p><p>开启 BBR ，<strong>在 1% 丢包网络环境下</strong>的测试结果如下图，640M 的文件还是花了 0.7s 下完，跟正常网络环境下的速度几乎一样，这相比同样 1% 丢包网络环境但不开启 BBR 时的 5.5s 有很大的提升。</p><p><img data-src="/images/2020/0322/5.png" alt="开启 BBR，1% 丢包网络环境的下载速度"></p><p>开启 BBR ，<strong>在 10% 丢包网络环境下</strong>的测试结果如下图，可以看到同样 640M 的文件下载花了 7.5s ，这虽然没有前面跟正常网络环境下速度几乎一样那么恐怖，但相比同样 10% 丢包网络环境不开启 BBR 时的 50s 还是有很大程度提升的。</p><p> <img data-src="/images/2020/0322/6.png" alt="开启 BBR，10% 丢包网络环境的下载速度"></p><h2 id="结果总结"><a href="#结果总结" class="headerlink" title="结果总结"></a>结果总结</h2><p>上面的测试通过一个简单的场景来验证了 TCP BBR 对于丢包情况下网络速度的优化。从结果中可以看到 TCP BBR 对于网络丢包的改善效果十分显著，在少量丢包的情况下甚至可以做到与正常网络环境速度无异，虽然在大量丢包时速度仍会下降，但跟不开启 BBR 的情况相比还是有很大的提升（比不开启 BBR 的情况速度降得更少）。</p><p>所以，如果你的机器、网络环境存在丢包导致跑不满带宽的话，不妨开启 BBR 试一下吧！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TCP BBR 出来已经有挺长一段时间了，都说它可以减少 TCP 连接的延迟、改善存在丢包的网络环境速度，虽然我自己一直在用，但由于从来没有测试过，所以对它具体能发挥多大的作用还是存疑的。&lt;/p&gt;
&lt;p&gt;正好最近了解到了一个命令 &lt;code&gt;tc&lt;/code&gt; ，可以模拟网络延迟和丢包，于是决定来亲自测试一下 BBR 对网络丢包的改善效果。&lt;/p&gt;</summary>
    
    
    
    <category term="趣味分享" scheme="https://blog.inkuang.com/categories/%E8%B6%A3%E5%91%B3%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="BBR" scheme="https://blog.inkuang.com/tags/BBR/"/>
    
    <category term="常用命令" scheme="https://blog.inkuang.com/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
    <category term="测试" scheme="https://blog.inkuang.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>记一次参与 JetBrains Quest 活动的过程</title>
    <link href="https://blog.inkuang.com/2020/310/"/>
    <id>https://blog.inkuang.com/2020/310/</id>
    <published>2020-03-10T14:32:54.000Z</published>
    <updated>2020-03-14T14:32:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>JetBrains 公司是干啥的自然不用我多说，无意中得知 JetBrains Quest 活动的消息，就也手痒的参与了一把。题目不难，一步步探索、揭晓谜底的过程还是挺有趣的，在这里简单记录一下本次解谜的过程。</p><p><strong>注：</strong> 最后到手的奖励是三个月的全产品订阅，不得不说 JetBrains 在优惠活动方面从来没让人失望过。</p><span id="more"></span><h2 id="第一步，读懂题目"><a href="#第一步，读懂题目" class="headerlink" title="第一步，读懂题目"></a>第一步，读懂题目</h2><p>先来看看 JetBrains 发布活动消息的这则推文：</p><p><img data-src="/images/2020/0310/1.png" alt="JetBrains Quest 活动消息的推文"></p><p>从中我们得到了如下的一串字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48 61 76 65 20 79 6f 75 20 73 65 65 6e 20 74 68 65 20 73 6f 75 72 63 65 20 63 6f 64 65 20 6f 66 20 74 68 65 20 4a 65 74 42 72 61 69 6e 73 20 77 65 62 73 69 74 65 3f</span><br></pre></td></tr></table></figure><p>观察发现，字符串中同时包含数字和字母，但是字母最大只有 <code>f</code> （按 a 最小，z 最大排序），这是很明显的 16 进制字符串的特征。</p><p>尝试一下把上面每个数字按 16 进制转成 10 进制，然后再根据 ASCII 码表取出对应的字符（肯定是写个脚本来自动转换啦），我们得到了如下的一句话：<code>Have you seen the source code of the JetBrains website?</code> 。嗯，让我们看看 JetBrains 网站的源码，那就来看看呗。</p><h2 id="第二步，源码中的信息"><a href="#第二步，源码中的信息" class="headerlink" title="第二步，源码中的信息"></a>第二步，源码中的信息</h2><p>打开 <a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a> ，右键查看网页源码，用鼠标拉动滑块快速的扫过去，很快发现在第400行附近有如下的一段注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">      O</span><br><span class="line">&#123;o)xxx|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-</span><br><span class="line">      O</span><br><span class="line"></span><br><span class="line">Welcome to the JetBrains Quest.</span><br><span class="line"></span><br><span class="line">What awaits ahead is a series of challenges. Each one will require a little initiative, a little thinking, and a whole lot of JetBrains to get to the end. Cheating is allowed and in some places encouraged. You have until the 15th of March at 12:00 CET to finish all the quests.</span><br><span class="line">Getting to the end of each quest will earn you a reward.</span><br><span class="line">Let the quest commence!</span><br><span class="line"></span><br><span class="line">JetBrains has a lot of products, but there is one that looks like a joke on our Products page, you should start there... (hint: use Chrome Incognito mode)</span><br><span class="line">It’s dangerous to go alone take this key: Good luck! &#x3D;&#x3D; Jrrg#oxfn$</span><br><span class="line"></span><br><span class="line">                 O</span><br><span class="line">-&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|xxx(o&#125;</span><br><span class="line">                 O</span><br></pre></td></tr></table></figure><p>这里给出了活动截止时间等信息，还有一条下一步的提示 —— 产品页面有一个看起来像玩笑的应用，我们需要从那里开始（提示：使用 Chrome 隐身模式）。</p><h2 id="第三步，奇怪的应用"><a href="#第三步，奇怪的应用" class="headerlink" title="第三步，奇怪的应用"></a>第三步，奇怪的应用</h2><p>根据上一步的提示，我们来到产品页面：<a href="https://www.jetbrains.com/products.html">https://www.jetbrains.com/products.html</a></p><p>凭着对 JetBrains 产品的印象和大胆猜测，很快锁定了那个看起来像开玩笑的应用：</p><p><img data-src="/images/2020/0310/2.png" alt="JetBrains Quest 线索"></p><p>点击 <code>Learn more</code> ，页面上弹出了一个窗口，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">You have discovered our JetBrains Quest! If you don’t know what this is, you should start from Twitter, Facebook or LinkedIn.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">To continue to the next challenge you need to go to the following link… But there is a problem, the last 3 digits are missing:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;jb.gg&#x2F;###</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">To get these digits you need to know how many prime numbers there are between 500 and 5000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Good Luck!</span><br></pre></td></tr></table></figure><p>很明显，我们找对了地方，并再次获得了下一步的提示 —— 一个残缺的链接，后面三位是 500 到 5000 内素数的个数。</p><h2 id="第四步，素数的个数"><a href="#第四步，素数的个数" class="headerlink" title="第四步，素数的个数"></a>第四步，素数的个数</h2><p>根据上一步的提示，我们随便撸一段脚本计算一下 500 到 5000 内素数的个数，发现结果是 574，于是我们访问链接 <a href="https://jb.gg/574">https://jb.gg/574</a> 进入下一步。</p><p>页面最终跳转到了 <a href="https://www.jetbrains.com/help/pycharm/getting-help.html#quest">https://www.jetbrains.com/help/pycharm/getting-help.html#quest</a> ，这次给了一张图片作为提示。注意到了图片上的如下部分：</p><p><img data-src="/images/2020/0310/3.png" alt="JetBrains Quest 线索"></p><p>那个“YT”的标志是 JetBrains 的产品 YouTrack，另外，对 JetBrains 稍微了解深入一点的人应该能意识到“MPS-31816”是一个 Issues 号。根据这些信息，配合搜索引擎，我们找到了如下页面：<a href="https://youtrack.jetbrains.com/issue/MPS-31816">https://youtrack.jetbrains.com/issue/MPS-31816</a> 。下面是页面上所给出的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“The key is to think back to the beginning.” -- The JetBrains Quest team</span><br><span class="line"></span><br><span class="line">Qlfh$#Li#|rx#duh#uhdglqj#wklv#|rx#pxvw#kdyh#zrunhg#rxw#krz#wr#ghfu|sw#lw1#Wklv#lv#rxu#lvvxh#wudfnhu#ghvljqhg#iru#djloh#whdpv1#Lw#lv#iuhh#iru#xs#wr#6#xvhuv#lq#Forxg#dqg#iru#43#xvhuv#lq#Vwdqgdorqh&#x2F;#vr#li#|rx#zdqw#wr#jlyh#lw#d#jr#lq#|rxu#whdp#wkhq#zh#wrwdoo|#uhfrpphqg#lw1#|rx#kdyh#ilqlvkhg#wkh#iluvw#Txhvw&#x2F;#qrz#lw“v#wlph#wr#uhghhp#|rxu#iluvw#sul&#125;h1#Wkh#frgh#iru#wkh#iluvw#txhvw#lv#‟WkhGulyhWrGhyhors†1#Jr#wr#wkh#Txhvw#Sdjh#dqg#xvh#wkh#frgh#wr#fodlp#|rxu#sul&#125;h1#kwwsv&#x3D;22zzz1mhweudlqv1frp2surpr2txhvw2</span><br></pre></td></tr></table></figure><p>至此，我们得到了一长串的奇怪字符串外加一句话 —— 关键是要回过头去思考。</p><h2 id="第五步，早已给出的提示"><a href="#第五步，早已给出的提示" class="headerlink" title="第五步，早已给出的提示"></a>第五步，早已给出的提示</h2><p>有没有觉得上面那些字符排列的方式有点眼熟？没错，还记得我们在第二步拿到的线索吗？还有一句话没用上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It’s dangerous to go alone take this key: Good luck! &#x3D;&#x3D; Jrrg#oxfn$</span><br></pre></td></tr></table></figure><p>最后这个 <code>Jrrg#oxfn$</code> 跟上面的字符串是不是有点同出一辙的感觉，再结合提示信息“回过头去思考”，我们这不就是回头来寻找线索吗？基本能够确定这一句话就是关键。</p><p>我们来简单分析一下，最先注意到的就是 <code>==</code> ，这是编程语言中的“等于”，提醒我们 <code>Good luck!</code> 和 <code>Jrrg#oxfn$</code> 相等；数一下两者字符的个数，发现都是 10 个（包括空格）；再注意到相同字符变换后对应的字符不变（前者两个连续的 <code>o</code> 在后者中就对应两个连续的 <code>r</code> ）。</p><p>基于上面这些分析，大胆猜测这是某种基于单个字符的加密方式，再配合一点直觉和实际的操作尝试，嗯，很典型的凯撒密码。简单来说，这里所用的加密操作就是将每个字符在 ASCII 码表中的值 +3，再取出新的值对应的字符。</p><p>知道了这一点之后再去解密上面的长字符串就很简单了，反过来将每个字符的 ASCII 值减 3 ，然后取出对应的字符，下面是最终解密出来的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nice! If you are reading this you must have worked out how to decrypt it. This is our issue tracker designed for agile teams. It is free for up to 3 users in Cloud and for 10 users in Standalone, so if you want to give it a go in your team then we totally recommend it. you have finished the first Quest, now it’s time to redeem your first prize. The code for the first quest is “TheDriveToDevelop”. Go to the Quest Page and use the code to claim your prize. https:&#x2F;&#x2F;www.jetbrains.com&#x2F;promo&#x2F;quest&#x2F;</span><br></pre></td></tr></table></figure><p>根据该信息，我们已经成功完成了本次 <code>JetBrains Quest</code> 的所有流程（这只是第一个 Quest ，后续还有其他挑战），接下来就就可以去领取奖励啦：打开 <a href="https://www.jetbrains.com/promo/quest/">https://www.jetbrains.com/promo/quest/</a> ，输入你的邮箱和解密信息中的 Code：<code>TheDriveToDevelop</code> ，稍等一会儿就会收到一封包含 3 个月全产品订阅兑换码的邮件，下面是我收到邮件的部分截图（去除了关键信息，只是邮件的上半部分）。</p><p><img data-src="/images/2020/0310/4.png" alt="JetBrains Quest 奖励发放邮件"></p><h2 id="更新：第二轮活动开始"><a href="#更新：第二轮活动开始" class="headerlink" title="更新：第二轮活动开始"></a>更新：第二轮活动开始</h2><p>题目详见：<a href="https://twitter.com/jetbrains/status/1237694815283879943">https://twitter.com/jetbrains/status/1237694815283879943</a></p><p>这里不会再记录详细解密过程（包括本次活动后续的题目），虽然我已经拿到奖励啦~~~</p><h2 id="更新：最后一轮活动开始"><a href="#更新：最后一轮活动开始" class="headerlink" title="更新：最后一轮活动开始"></a>更新：最后一轮活动开始</h2><p>题目详见：<a href="https://twitter.com/jetbrains/status/1238420744817782784">https://twitter.com/jetbrains/status/1238420744817782784</a></p><p>需要注意的是，与前面两次的三个月全产品订阅不同，这次的奖励是全产品订阅的八折优惠码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;JetBrains 公司是干啥的自然不用我多说，无意中得知 JetBrains Quest 活动的消息，就也手痒的参与了一把。题目不难，一步步探索、揭晓谜底的过程还是挺有趣的，在这里简单记录一下本次解谜的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 最后到手的奖励是三个月的全产品订阅，不得不说 JetBrains 在优惠活动方面从来没让人失望过。&lt;/p&gt;</summary>
    
    
    
    <category term="趣味分享" scheme="https://blog.inkuang.com/categories/%E8%B6%A3%E5%91%B3%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="字符编码" scheme="https://blog.inkuang.com/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
    <category term="JetBrains" scheme="https://blog.inkuang.com/tags/JetBrains/"/>
    
    <category term="解谜" scheme="https://blog.inkuang.com/tags/%E8%A7%A3%E8%B0%9C/"/>
    
  </entry>
  
  <entry>
    <title>ElGamal 密码体制简记</title>
    <link href="https://blog.inkuang.com/2020/217/"/>
    <id>https://blog.inkuang.com/2020/217/</id>
    <published>2020-02-17T07:32:07.000Z</published>
    <updated>2020-03-30T03:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="离散对数问题"><a href="#离散对数问题" class="headerlink" title="离散对数问题"></a>离散对数问题</h2><p>给定乘法群 $(G, \quad\cdot)$ ，一个 $n$ 阶元素 $\alpha \in G$ 和元素 $\beta \in\langle\alpha\rangle$ 。要求找到惟一的整数 $a,0 \leq a \leq n-1$ ，满足 $\alpha^{a}=\beta$ 。一般将这个整数 $a$ 记为 $a=\log _{\alpha} \beta$ 。</p><p>通常取 $G$ 为有限域 $\mathbb{Z}_{p}$ 的乘法群（$p$ 为素数），$\alpha$ 为模 $p$ 的本原元，这时 $n=|\langle\alpha\rangle|=p-1$ 。或取 $\alpha$ 为乘法群 $\mathbb{Z}_{p}^{*}$ 的一个素数 $q$ 阶元素，$q | p-1$ 。</p><span id="more"></span><h2 id="ElGamal-密码体制定义"><a href="#ElGamal-密码体制定义" class="headerlink" title="ElGamal 密码体制定义"></a>ElGamal 密码体制定义</h2><p>考虑 $\mathbb{Z}_{p}^{*}$ 上的情况，设 $p$ 是一个素数，使得 $\left(\mathbb{Z}_{p}^{*}, \quad\cdot\right)$ 上的离散对数问题是难解的，令 $\alpha \in \mathbb{Z}_{p}^{*}$ 是一个本原元。另 $P=\mathbb{Z}_{p}^{*}, C=\mathbb{Z}_{p}^{*} \times \mathbb{Z}_{p}^{*}$ ，定义<br>$$<br>K=\left\{(p, \alpha, a, \beta): \beta \equiv \alpha^{a} \bmod p\right\}<br>$$<br>其中 $(p, \alpha, \beta)$ 是公钥， $a$ 是私钥。对 $k=(p, \alpha, a, \beta)$ ，以及一个秘密的随机数 $s \in \mathbb{Z}_{p-1}$ ，定义加密<br>$$<br>e_{k}(x, s)=\left(y_{1}, y_{2}\right),\quad y_{1}=\alpha^{s} \bmod p,\quad y_{2}=x \beta^{s} \bmod p<br>$$<br>对 $y_{1}, y_{2} \in \mathbb{Z}_{p}^{*}$ ，定义解密<br>$$<br>d_{k}\left(y_{1}, y_{2}\right)=y_{2}\left(y_{1}^{a}\right)^{-1} \bmod p<br>$$<br><strong>注意：</strong> 这里我们在加密时使用了一个随机选取的变量 $s$ ，但是解密时并不需要知道这一参数。更换 $s$ 的值，可以为同一段明文生成多个不同的密文，但这对解密过程没有任何影响。</p><h2 id="加解密示例"><a href="#加解密示例" class="headerlink" title="加解密示例"></a>加解密示例</h2><p>设 $p=2597$ ，$\alpha=2$ 是模 $p$ 的本原元。令 $a=765$ ，则可以算出 $\beta=2^{765} \bmod 2579=949$ 。于是 Bob 发布公钥 $(p, \alpha, \beta)$ ，保留私钥 $a$ 。</p><p>若 Alice 想加密明文 $x=1299$ 并发送给 Bob 密文 $y$ ，选择随机数 $s=853$ （由 Alice 随机选取，不需要告诉 Bob），她将计算<br>$$<br>y_{1}=2^{853} \bmod p=435,\quad y_{2}=1299 \cdot 949^{853} \bmod p=2396<br>$$<br>于是密文为 $y=(435,2396)$ 。</p><p>Bob 收到密文 $y$ 后利用私钥 $a$ 来解密：$x=2396 \cdot\left(435^{765}\right)^{-1} \bmod p=1299$ 。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;离散对数问题&quot;&gt;&lt;a href=&quot;#离散对数问题&quot; class=&quot;headerlink&quot; title=&quot;离散对数问题&quot;&gt;&lt;/a&gt;离散对数问题&lt;/h2&gt;&lt;p&gt;给定乘法群 $(G, \quad\cdot)$ ，一个 $n$ 阶元素 $\alpha \in G$ 和元素 $\beta \in\langle\alpha\rangle$ 。要求找到惟一的整数 $a,0 \leq a \leq n-1$ ，满足 $\alpha^{a}=\beta$ 。一般将这个整数 $a$ 记为 $a=\log _{\alpha} \beta$ 。&lt;/p&gt;
&lt;p&gt;通常取 $G$ 为有限域 $\mathbb{Z}_{p}$ 的乘法群（$p$ 为素数），$\alpha$ 为模 $p$ 的本原元，这时 $n=|\langle\alpha\rangle|=p-1$ 。或取 $\alpha$ 为乘法群 $\mathbb{Z}_{p}^{*}$ 的一个素数 $q$ 阶元素，$q | p-1$ 。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.inkuang.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://blog.inkuang.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="密码学" scheme="https://blog.inkuang.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="非对称加密" scheme="https://blog.inkuang.com/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>RSA 密码体制简记</title>
    <link href="https://blog.inkuang.com/2020/216/"/>
    <id>https://blog.inkuang.com/2020/216/</id>
    <published>2020-02-16T06:10:10.000Z</published>
    <updated>2020-03-28T06:10:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RSA-密码体制定义"><a href="#RSA-密码体制定义" class="headerlink" title="RSA 密码体制定义"></a>RSA 密码体制定义</h2><p>设 $n=p q$ ，其中 $p, q$ 为素数。设 $P=C=\mathbb{Z}_{n}$ ，且定义 $K={(n, p, q, a, b): a b \equiv 1 \bmod \phi(n)}$ 。对于 $k=(n, p, q, a, b), x, y \in \mathbb{Z}_{n}$ ，定义加密和解密分别为：<br>$$<br>e_{k}(x)=x^{b} \bmod n,\quad d_{k}(y)=y^{a} \bmod n<br>$$<br>值 $(n, b)$ 组成了公钥，$(p, q, a)$ 组成了私钥。</p><span id="more"></span><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>RSA 密码体制的安全性基于相信加密函数 $e_{k}(x) \equiv x^{b} \bmod n$ 是一个（陷门）单向函数 [1] 。允许解密的陷门是分解 $n=p q$ 。</p><p>若知道这个分解，则可计算 $\phi(n)=(p-1)(q-1)$ ，由于 $a b \equiv 1 \bmod \phi(n)$ ，即 $a \equiv b^{-1} \bmod \phi(n) $ ，进而可以利用扩展 Euclidean 算法 [2] 来计算解密指数 $a$ 。</p><p><em>[1] 单向函数：一个函数容易计算但难于求逆。陷门单向函数：一个单向函数在具有特定的陷门知识后容易求逆。</em><br><em>[2] 扩展 Euclidean 算法：欧几里得算法的扩展，可以用来求模的逆元。 <a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">百度词条</a></em></p><h2 id="加解密示例"><a href="#加解密示例" class="headerlink" title="加解密示例"></a>加解密示例</h2><p>假定 $p=101, q=113$ ，则 $n=11413, \phi(n)=100 \times 112=11200$ 。若 Bob 选取 $b=3533$ ，则可计算 $a=b^{-1} \equiv 6597 \bmod 11200$ 。于是 Bob 发布公钥 $(n, b)$ ，保留私钥 $(p, q, a)$ 。</p><p>若 Alice 想加密明文 $x=9726$ 并发送给 Bob 密文 $y$ ，她将计算 $y=9726^{3533} \bmod 11413 \equiv 5761$ 。</p><p>Bob 收到密文 $y$ 后利用私钥中的解密指数来计算 $x=5761^{a}=5761^{6597} \bmod 11413 \equiv 9726$ 。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;RSA-密码体制定义&quot;&gt;&lt;a href=&quot;#RSA-密码体制定义&quot; class=&quot;headerlink&quot; title=&quot;RSA 密码体制定义&quot;&gt;&lt;/a&gt;RSA 密码体制定义&lt;/h2&gt;&lt;p&gt;设 $n=p q$ ，其中 $p, q$ 为素数。设 $P=C=\mathbb{Z}_{n}$ ，且定义 $K={(n, p, q, a, b): a b \equiv 1 \bmod \phi(n)}$ 。对于 $k=(n, p, q, a, b), x, y \in \mathbb{Z}_{n}$ ，定义加密和解密分别为：&lt;br&gt;$$&lt;br&gt;e_{k}(x)=x^{b} \bmod n,\quad d_{k}(y)=y^{a} \bmod n&lt;br&gt;$$&lt;br&gt;值 $(n, b)$ 组成了公钥，$(p, q, a)$ 组成了私钥。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.inkuang.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://blog.inkuang.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="密码学" scheme="https://blog.inkuang.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="非对称加密" scheme="https://blog.inkuang.com/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PIL.Image 和 OpenCV 图像格式互转</title>
    <link href="https://blog.inkuang.com/2020/212/"/>
    <id>https://blog.inkuang.com/2020/212/</id>
    <published>2020-02-12T09:04:20.000Z</published>
    <updated>2020-02-12T09:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近做一些图像处理的时候经常用到 PIL.Image 和 OpenCV 这两个东西。</p><p>稍微有点了解的应该都清楚，这两个库在图像处理方面很多功能类似，但是它们读取图片的格式却是不一样的，这就导致在混用一些图像处理工具的时候经常需要进行格式转换，在这里记录一下两种格式互转的方法。</p><span id="more"></span><h2 id="PIL-Image-转换成-OpenCV-格式"><a href="#PIL-Image-转换成-OpenCV-格式" class="headerlink" title="PIL.Image 转换成 OpenCV 格式"></a>PIL.Image 转换成 OpenCV 格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"> </span><br><span class="line">pil_im = Image.<span class="built_in">open</span>(<span class="string">&quot;image.jpg&quot;</span>)</span><br><span class="line">cv2_im = cv2.cvtColor(numpy.asarray(pil_im),cv2.COLOR_RGB2BGR)</span><br></pre></td></tr></table></figure><p>由于 PIL.Image 使用的颜色模式是 RGB ，而 OpenCV 使用的是 BGR ，所以我们在二者间进行格式转换的时候使用了 <code>cv2.COLOR_RGB2BGR</code> 控制颜色模式的转换。</p><h2 id="OpenCV-转换成-PIL-Image-格式"><a href="#OpenCV-转换成-PIL-Image-格式" class="headerlink" title="OpenCV 转换成 PIL.Image 格式"></a>OpenCV 转换成 PIL.Image 格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy  </span><br><span class="line"></span><br><span class="line">cv2_im = cv2.imread(<span class="string">&quot;image.jpg&quot;</span>)  </span><br><span class="line">pil_im = Image.fromarray(cv2.cvtColor(cv2_im,cv2.COLOR_BGR2RGB))  </span><br></pre></td></tr></table></figure><p>同上，使用 <code>cv2.COLOR_BGR2RGB</code> 控制颜色模式的转换。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近做一些图像处理的时候经常用到 PIL.Image 和 OpenCV 这两个东西。&lt;/p&gt;
&lt;p&gt;稍微有点了解的应该都清楚，这两个库在图像处理方面很多功能类似，但是它们读取图片的格式却是不一样的，这就导致在混用一些图像处理工具的时候经常需要进行格式转换，在这里记录一下两种格式互转的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://blog.inkuang.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="https://blog.inkuang.com/tags/Python/"/>
    
    <category term="图像处理" scheme="https://blog.inkuang.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>将现有 Linux 系统替换安装为 Arch Linux</title>
    <link href="https://blog.inkuang.com/2020/114/"/>
    <id>https://blog.inkuang.com/2020/114/</id>
    <published>2020-01-14T04:02:58.000Z</published>
    <updated>2020-01-15T04:02:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前文 <a href="/2020/104/">Arch Linux 从零开始安装</a> 里就提到过我把服务器上的系统在线替换安装成了 Arch Linux，拖了这么久终于有时间来整理一下折腾过程，在这里简单记录一下。</p><p>本文所涉及的内容在 Arch Wiki 中也有相关教程，可以对照查看：<a href="https://wiki.archlinux.org/index.php/Install_Arch_Linux_from_existing_Linux">Install Arch Linux from existing Linux</a> 。</p><span id="more"></span><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>博主自己初次测试时用的是阿里云的轻量服务器，原系统（标题中的“现有 Linux 系统”）是 Debian 9 。</p><p>考虑到我们并没有太多的操作需要在原系统中进行，所以原系统是啥应该影响不大，唯一的要求就是如果在云服务器上操作的话必须要能够通过网页进行 vnc 连接（在配置网络管理器、ssh 之前需要重启，但此时网络环境还没弄好，重启后就无法再通过 ssh 连上服务器了）。</p><h2 id="启动-chroot-环境"><a href="#启动-chroot-环境" class="headerlink" title="启动 chroot 环境"></a>启动 chroot 环境</h2><p>和从镜像安装 Arch Linux 一样，我们的安装操作首先要做的就是进入一个“最小化的安装环境”。这里我们通过官方提供的引导镜像启动一个 chroot 环境以满足这一要求。</p><p>首先从 Arch Linux 的镜像站点下载引导镜像文件（名字一般是 <code>archlinux-bootstrap-YYYY.MM.DD-x86_64.tar.gz</code> 的形式）到 <code>/tmp</code> 目录下。为了加快下载速度，我这里是从中科大的镜像源下载的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;tmp</span><br><span class="line">wget http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinux&#x2F;iso&#x2F;2020.01.01&#x2F;archlinux-bootstrap-2020.01.01-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>下载之后解压可以得到一个名为 <code>root.x86_64</code> 的文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf archlinux-bootstrap-2020.01.01-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>然后我们通过 <code>mount --bind</code> 命令将这个文件夹与自己连接起来，这一步主要是为了让我们在进入 chroot 环境后能够使用使用 pacman 安装软件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount --bind &#x2F;tmp&#x2F;root.x86_64 &#x2F;tmp&#x2F;root.x86_64</span><br></pre></td></tr></table></figure><p>在进入 chroot 环境后需要安装一些软件用于后续系统的安装，而引导镜像中不包含任何编辑软件，所以我们最好提前利用原系统上的编辑软件修改好引导镜像中使用的镜像源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;tmp&#x2F;root.x86_64&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist</span><br></pre></td></tr></table></figure><p>去除自己想用的镜像源前面的 <code>#</code> 号即可启用（默认是全部注释掉了的，至少需启用一个）。</p><p>之后利用引导镜像中的可执行文件 <code>/tmp/root.x86_64/bin/arch-chroot</code> 将我们的引导镜像目录 <code>/tmp/root.x86_64/</code> 启动为 chroot 环境（感觉有点绕…）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;tmp&#x2F;root.x86_64&#x2F;bin&#x2F;arch-chroot &#x2F;tmp&#x2F;root.x86_64&#x2F;</span><br></pre></td></tr></table></figure><p>不出意外的话此时就成功进入了从我们下载的引导镜像启动的 chroot 环境。</p><h2 id="使用-chroot-环境"><a href="#使用-chroot-环境" class="headerlink" title="使用 chroot 环境"></a>使用 chroot 环境</h2><p>进入 chroot 环境其实就相当于我们使用镜像安装时的“启动到 live 环境”这一步，这个环境已经拥有了安装系统所必需的软件包，下面介绍具体的安装操作。</p><h3 id="初始化-pacman-密钥"><a href="#初始化-pacman-密钥" class="headerlink" title="初始化 pacman 密钥"></a>初始化 pacman 密钥</h3><p>在这个 chroot 环境中我们是可以使用 pacman 安装软件的，但在那之前需要先初始化一下 pacman 的密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman-key --init</span><br><span class="line">pacman-key --populate archlinux</span><br></pre></td></tr></table></figure><p>初始化完成之后你就可以随意安装自己需要的软件了，我这里只安装一个了 vim 编辑器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syy</span><br><span class="line">pacman -S vim</span><br></pre></td></tr></table></figure><h3 id="抹除原系统"><a href="#抹除原系统" class="headerlink" title="抹除原系统"></a>抹除原系统</h3><p>首先将我们原系统所在的<strong>分区</strong>（我这里是 <code>/dev/vda1</code> ）挂载到当前系统（chroot 环境）的 <code>/mnt</code> 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;vda1 &#x2F;mnt</span><br></pre></td></tr></table></figure><p>需要注意的是，我们无法对原系统所在的硬盘重新分区（重新分区后需要格式化，而我们现在所在的 chroot 环境还依赖着 <code>/tmp/root.x86_64</code> 目录下的文件），所以这里挂载的分区就是我们用来安装新系统的分区。</p><p><strong>注意：到这一步我们的原系统还是安全的，你可以随时使用 <code>exit</code> 退出 chroot 环境，但是一旦执行了下面的步骤就再也无法回头了，要么成功，要么重装，请谨慎操作！！！</strong></p><p>接下来进入 <code>/mnt</code> 目录，将除了 <code>tmp</code>、<code>dev</code>、<code>proc</code>、<code>run</code>、<code>sys</code> 几个目录外的其他所有文件/文件夹全部删掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;mnt</span><br><span class="line">rm -rf ......</span><br></pre></td></tr></table></figure><h3 id="安装新系统"><a href="#安装新系统" class="headerlink" title="安装新系统"></a>安装新系统</h3><p>再接下来我们就可以按照正常安装 Arch Linux 的步骤开始安装我们的新系统了。</p><p>具体操作参见 <a href="/2020/104/">Arch Linux 从零开始安装</a> ，从“安装系统”这一步开始一直到“配置 GRUB 引导”（包括配置 GRUB 引导这一步）。</p><h2 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h2><p>在配置好 GRUB 引导之后我们的系统安装就已经基本完成了，这时候需要重启一下机器，正式启动我们新安装好的 Arch Linux 系统。</p><p>由于 chroot 环境没有重启权限，原系统中的文件又已经被我们全删掉了，所以只能通过断电来“硬重启”（云服务器可以通过服务商的控制台重启）。</p><p>若无意外的话重新启动的就是我们新安装好的 Arch Linux 系统了。此时还没有进行网络配置，机器无法联网，所以云服务器需要通过控制台的 vnc 连接来完成后续的步骤（阿里云轻量服务器就是后台的救援连接）</p><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>配置网络的步骤跟我们正常安装时的操作一模一样，详见 <a href="/2020/104/">Arch Linux 从零开始安装</a> 的“网络配置”部分，这里不再赘述。</p><h2 id="配置-SSH-连接"><a href="#配置-SSH-连接" class="headerlink" title="配置 SSH 连接"></a>配置 SSH 连接</h2><p>首先使用 <code>pacman -Syy</code> 更新一下软件包数据库，然后安装 openssh，启动 ssh 服务并设置开机自启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S openssh</span><br><span class="line">systemctl start sshd</span><br><span class="line">systemctl enable sshd</span><br></pre></td></tr></table></figure><p>最后我们修改一下配置文件允许 root 用户登录（openssh 现在默认禁止 root 用户登录）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br></pre></td></tr></table></figure><p>将 <code>#PermitRootLogin prohibit-password</code> 这一行修改为 <code>PermitRootLogin yes</code> 后保存即可。</p><p>全部弄好之后重启一下就能够使用 ssh 工具连接机器了，接下来就可以尽情的定制属于自己的 Arch Linux 啦！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前文 &lt;a href=&quot;/2020/104/&quot;&gt;Arch Linux 从零开始安装&lt;/a&gt; 里就提到过我把服务器上的系统在线替换安装成了 Arch Linux，拖了这么久终于有时间来整理一下折腾过程，在这里简单记录一下。&lt;/p&gt;
&lt;p&gt;本文所涉及的内容在 Arch Wiki 中也有相关教程，可以对照查看：&lt;a href=&quot;https://wiki.archlinux.org/index.php/Install_Arch_Linux_from_existing_Linux&quot;&gt;Install Arch Linux from existing Linux&lt;/a&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.inkuang.com/tags/Linux/"/>
    
    <category term="系统安装" scheme="https://blog.inkuang.com/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    
    <category term="Arch Linux" scheme="https://blog.inkuang.com/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 自动获取 Hostloc 论坛积分</title>
    <link href="https://blog.inkuang.com/2020/111/"/>
    <id>https://blog.inkuang.com/2020/111/</id>
    <published>2020-01-11T09:38:43.000Z</published>
    <updated>2021-05-19T03:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>博主其实在 GitHub Actions 还没正式推出时就申请到了测试资格，奈何自己的博客早就配置了 Travis CI 自动构建（现已更换），懒得修改了，又没有什么其他项目，所以根本没有实践过。</p><p>最近闲了下来，稍微过了一下 GitHub Actions  的文档，然后折腾了个自动获取 <a href="https://www.hostloc.com/forum.php">Hostloc 论坛（全球主机交流论坛）</a>积分的小工具，在这里简单介绍一下吧。</p><span id="more"></span><h2 id="2021年5月19日更新"><a href="#2021年5月19日更新" class="headerlink" title="2021年5月19日更新"></a>2021年5月19日更新</h2><p>由于 GitHub 的使用政策更新，似乎不再允许该类用途，本仓库在近期的严查中不幸被封禁了，在跟 GitHub 联系后已确认无法解封（他们不接受任何整改意愿，甚至都不能让我将数据备份一下）。</p><p>本项目将不再更新，原代码库备份可以从以下链接获取：<a href="https://git.inkuang.com/inkuang/hostloc-auto-get-points">https://git.inkuang.com/inkuang/hostloc-auto-get-points</a></p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>如果你对那些代码、原理不感兴趣，只是想要用这么个东西的话只要看这一小节就够了，详细讲解放在后面。</p><p>首先 Fork 我写好代码的仓库：<a href="https://github.com/inkuang/hostloc-auto-get-points">https://github.com/inkuang/hostloc-auto-get-points</a></p><p>然后在你 Fork 的仓库页面点击右上角的 Settings，找到 Secrets 这一项，添加两个秘密环境变量。</p><p><img data-src="/images/2020/0111/1.png" alt="设置秘密环境变量"></p><p>其中 <code>HOSTLOC_USERNAME</code> 存放你在 Hostloc 的帐户名，<code>HOSTLOC_PASSWORD</code> 存放你的帐户密码。支持同时添加多个帐户，数据之间用半角逗号 <code>,</code> 隔开即可，帐户名和帐户密码需一一对应。</p><p>设置好环境变量后点击你的仓库上方的 Actions 选项，会打开一个如下的页面，点击 <code>I understand...</code> 按钮确认在 Fork 的仓库上启用 GitHub Actions 。</p><p><img data-src="/images/2020/0111/2.png" alt="在 Fork 的仓库上面启用 GitHub Actions"></p><p>此时页面上会显示当前仓库所有的 Workflows，点击左侧的 <code>Hostloc Auto Get Points</code>，然后点击页面上黄色提醒框 <code>This scheduled workflow is disabled...</code> 处的 <code>Enable workflow</code> 按钮确认在 Fork 的仓库上启用 GitHub Actions 定时任务。</p><p>最后在你这个 Fork 的仓库内随便改点什么（比如给 README 文件删掉或者增加几个字符）提交一下手动触发一次 GitHub Actions 就可以了。</p><p>仓库内包含的 GitHub Actions 配置文件会在每天国际标准时间 17 点（北京时间凌晨 1 点）自动执行获取积分的脚本文件，你也可以通过 <code>Push</code> 操作手动触发执行（测试发现定时任务的执行可能有 5 到 10 分钟的延迟，属正常现象，耐心等待即可）。</p><p><strong>注意：</strong> 为了实现某个链接/帐户访问出错时不中断程序继续尝试下一个，GitHub Actions 的状态将永远是“通过”（显示绿色的✔），请自行检查 GitHub Actions 日志 <code>Get points</code> 项的输出确定程序执行情况。</p><h2 id="获取积分原理及代码"><a href="#获取积分原理及代码" class="headerlink" title="获取积分原理及代码"></a>获取积分原理及代码</h2><p>在 Hostloc 论坛上，访问他人用户空间每次可以获得 2 积分，每天最多 20 积分。这个小工具就是基于这一原理，使用代码模拟用户登录，然后随机访问用户空间来实现的。</p><p>详细代码可以到我的 <a href="https://github.com/inkuang/hostloc-auto-get-points/blob/master/hostloc_get_points.py">GitHub 仓库</a> 查看，这里只介绍几个关键点。</p><p>观察发现，用户空间的链接都是类似 <code>https://www.hostloc.com/space-uid-&#123;&#125;.html</code> 的格式，大括号内就是用户 id，基于此，我们随机生成一定数量的用户 id，然后构造一系列的用户空间链接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomly_gen_uspace_url</span>():</span></span><br><span class="line">    url_list = []</span><br><span class="line">    <span class="comment"># 访问小黑屋用户空间不会获得积分、生成的随机数可能会重复，这里多生成两个链接用作冗余</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">        uid = random.randint(<span class="number">10000</span>, <span class="number">50000</span>)</span><br><span class="line">        url = <span class="string">&quot;https://hostloc.com/space-uid-&#123;&#125;.html&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(uid))</span><br><span class="line">        url_list.append(url)</span><br><span class="line">    <span class="keyword">return</span> url_list</span><br></pre></td></tr></table></figure><p>比较关键的，登录，可以打开浏览器开发者工具的 Network 选项，然后在论坛首页使用错误的用户名、密码登录一次（正确的帐户在点击登录后页面会发生跳转，就看不到数据了），会发现我们请求了 <code>member.php</code> 这个文件，在它的 Headers 里可以看到我们使用 post 发送了一组数据。</p><p>利用这些获取的数据和 <code>requests</code> 的 <code>Session</code> 对象，我们可以很轻松的实现登录功能： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">username, password</span>):</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;https://www.hostloc.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;referer&quot;</span>: <span class="string">&quot;https://www.hostloc.com/forum.php&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    login_url = <span class="string">&quot;https://www.hostloc.com/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;infloat=yes&amp;lssubmit=yes&amp;inajax=1&quot;</span></span><br><span class="line">    login_data = &#123;</span><br><span class="line">        <span class="string">&quot;fastloginfield&quot;</span>: <span class="string">&quot;username&quot;</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">        <span class="string">&quot;quickforward&quot;</span>: <span class="string">&quot;yes&quot;</span>,</span><br><span class="line">        <span class="string">&quot;handlekey&quot;</span>: <span class="string">&quot;ls&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    s = requests.Session()</span><br><span class="line">    s.headers.update(headers)</span><br><span class="line">    res = s.post(url=login_url, data=login_data)</span><br><span class="line">    res.raise_for_status()</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><p>接下来只要使用登录后的 <code>Session</code> 对象，依次 <code>get</code> 前面生成的用户空间链接即可，这里不再详述。</p><p>需要注意的是，为了安全和方便他人使用，我们这里不把用户名和密码写在代码中，而是通过环境变量获取，这样也方便后面与 GitHub Actions 结合使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = os.environ[<span class="string">&quot;HOSTLOC_USERNAME&quot;</span>]</span><br><span class="line">password = os.environ[<span class="string">&quot;HOSTLOC_PASSWORD&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="GitHub-Actions-配置"><a href="#GitHub-Actions-配置" class="headerlink" title="GitHub Actions 配置"></a>GitHub Actions 配置</h2><p>代码写好之后我们只需要将它每天运行一遍就行了。你完全可以手动操作，但那样无疑很麻烦，这里我们使用 GitHub Actions 来自动完成这一步骤。完整配置文件请到我的 <a href="https://github.com/inkuang/hostloc-auto-get-points/blob/master/.github/workflows/action.yml">GitHub 仓库</a> 查看，这里只简单做一下介绍。</p><p><strong>注：</strong> GitHub Actions 配置文件的格式请到官方文档查看了解，这里不会涉及。</p><p>首先要考虑的就是我们什么时候需要运行这个脚本。很明显，从我们的需求来看具体的运行时间并不重要，只要每天运行一次就行了，这里使用 GitHub Actions 的定时任务来实现，在配置文件的 <code>on</code> 字段中指定（为了方便测试，这里将 push 操作触发也加进来）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&#x27;0 17 * * *&#x27;</span></span><br></pre></td></tr></table></figure><p>这里指定在每次 push 操作后或者每天国际标准时间 17 点（也就是北京时间凌晨 1 点）执行。</p><p>接下来就是考虑运行环境了。首先检出代码，然后设置 python 版本，再接着安装一下依赖（我们的依赖只有 <code>requests</code> 这一个包）。这样我们的 python 脚本所需要的运行环境就配置完成了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;Checkout codes&#x27;</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;Set python&#x27;</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/setup-python@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">python-version:</span> <span class="string">&#x27;3.x&#x27;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;Install dependencies&#x27;</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">--upgrade</span> <span class="string">requests</span></span><br></pre></td></tr></table></figure><p>最后，也是最关键的一步：运行我们的脚本。前面提到我们的脚本中登录使用的用户名和密码是从环境变量中读取的，所以在这里我们需要设置一下环境变量。为了安全，我们将用户名和密码存在仓库的 <code>Secrets</code> 中，然后从 GitHub Actions 配置文件的 <code>secrets</code> 域中读取出来并设置为对应的环境变量：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;Get points&#x27;</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="attr">HOSTLOC_USERNAME:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOSTLOC_USERNAME</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">HOSTLOC_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOSTLOC_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">python</span> <span class="string">hostloc_get_points.py</span></span><br></pre></td></tr></table></figure><p>好啦，基本原理之类的东西就这么些了，花了几个小时撸出来的（主要花在看 GitHub Actions 的文档和折腾论坛的登录机制上面），如果你觉得有用的话不要忘了点个 star 哦~~~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;博主其实在 GitHub Actions 还没正式推出时就申请到了测试资格，奈何自己的博客早就配置了 Travis CI 自动构建（现已更换），懒得修改了，又没有什么其他项目，所以根本没有实践过。&lt;/p&gt;
&lt;p&gt;最近闲了下来，稍微过了一下 GitHub Actions  的文档，然后折腾了个自动获取 &lt;a href=&quot;https://www.hostloc.com/forum.php&quot;&gt;Hostloc 论坛（全球主机交流论坛）&lt;/a&gt;积分的小工具，在这里简单介绍一下吧。&lt;/p&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="GitHub Actions" scheme="https://blog.inkuang.com/tags/GitHub-Actions/"/>
    
    <category term="自动化" scheme="https://blog.inkuang.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux 从零开始安装</title>
    <link href="https://blog.inkuang.com/2020/104/"/>
    <id>https://blog.inkuang.com/2020/104/</id>
    <published>2020-01-04T11:00:14.000Z</published>
    <updated>2020-01-06T11:00:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前的一份记录，本来不打算发的，但最近折腾了一下把服务器上的系统在线替换安装成了 Arch Linux，中间涉及到很多本文的步骤，所以还是稍微整理一下发出来吧。</p><p>由于之前做记录只是用于自己备忘，所以全程无图，一些细节部分请对照 <a href="https://wiki.archlinux.org/index.php/Installation_guide">官方wiki</a> 查看，注意安装时需要联网。</p><span id="more"></span><h2 id="启动到-live-环境"><a href="#启动到-live-环境" class="headerlink" title="启动到 live 环境"></a>启动到 live 环境</h2><p>安装过 Linux 系统的人对这一步自然不会陌生，完全没有安装 Linux 系统经验的人我也不建议你直接上手折腾 Arch Linux。这里我们不再详述，简单概括一下的话就下面几个步骤：刻录 U 盘、从 U 盘启动、选择第一项启动 Arch Linux。</p><p>不同于一般的 Linux 发行版提供了图形界面（类图形界面）的安装方式，Arch Linux 的安装全程在命令行下进行，此时我们从 U 盘启动 Arch Linux 后进入的就是这么一个临时的命令行环境。</p><h2 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h2><p>输入 <code>fdisk -l</code> 列出自己所有的硬盘，结果中以 <code>rom</code>，<code>loop</code> 或者 <code>airoot</code> 结束的可以忽略。这里我们将系统装在 <code>/dev/sda</code> 中。</p><p>对于一个正常的 Linux 系统，根分区 <code>/</code> 是必须要有的，如果你使用 UEFI 模式，则还会需要一个 EFI 分区。除此之外你还可以分配交换空间（SWAP），将 <code>/boot</code>  、<code>/home</code> 分区单独挂载等。</p><p>我们这里一切从简，只分配一个根分区。我虽然曾经配置过 UEFI 模式，但并没有记录下当时的步骤，所以本文暂不会涉及 UEFI ，以后若我重新折腾了相关的东西可能会补发上来。</p><p>在只分配一个根分区的情况下我们需要考虑的事情就少了很多，直接将所有空间分到一个分区内即可。输入 <code>fdisk /dev/sda</code> 进入分区程序，输入 <code>o</code> 新建一个分区表（开始分区），输入 <code>n</code> 新建一个分区，然后一路按回车键 <code>Enter</code> 选择默认的配置即可，在完成后输入 <code>p</code> 可以查看我们的分区情况，输入 <code>w</code> 写入分区信息并退出。</p><p>之后输入 <code>lsblk</code> 可以看到 <code>sda</code> 下面分出了一个名为 <code>sda1</code> 的分区。</p><h2 id="硬盘格式化"><a href="#硬盘格式化" class="headerlink" title="硬盘格式化"></a>硬盘格式化</h2><p>分好区后我们还需要对其格式化，输入 <code>mkfs.ext4 /dev/sda1</code> 将 <code>sda1</code> 分区格式化为 <code>ext4</code> 格式。</p><h2 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h2><p>再之后就属于正式安装的步骤了，输入 <code>mount /dev/sda1 /mnt</code> 将 <code>sda1</code> 分区挂载到我们当前系统的 <code>/mnt</code> 目录下。</p><h2 id="选择镜像源"><a href="#选择镜像源" class="headerlink" title="选择镜像源"></a>选择镜像源</h2><p>选择一个中国用起来比较快的镜像源能够很大程度上加快我们后面安装时的进度。</p><p>输入 <code>cd /etc/pacman.d</code> 进入镜像配置文件目录，输入 <code>cp mirrorlist mirrorlist.bk</code> 备份一下原文件，然后输入以下命令提取出所有的中国镜像写入 <code>mirrorlist</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat mirrorlist.bk | grep China -A 1 | grep -v &#39;-&#39; &gt; mirrorlist</span><br></pre></td></tr></table></figure><p>最后使用你喜欢的编辑器（这个 live 系统中内置了 vim 和 nano）手动编辑 <code>mirrorlist</code> 文件，使用 <code>#</code> 注释掉不用的镜像，我这里一般最后留下中科大（ustc）和清华大学（tuna.tsinghua）的镜像源。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>这里的安装系统本质上其实是在我们挂载 <code>sda1</code> 分区的目录 <code>/mnt</code> 下安装系统所必需的文件和软件包。这里具体要安装哪些软件包是自己可选的，详情可以查看 <a href="https://wiki.archlinux.org/index.php/Installation_guide#Install_essential_packages">官方wiki</a> ，我一般在这里只安装一些必需软件包，像文本编辑器之类的东西可以在等下 chroot 进入新系统后使用 <code>pacman</code> 手动安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap &#x2F;mnt base base-devel linux linux-firmware</span><br></pre></td></tr></table></figure><h2 id="生成自动挂载配置"><a href="#生成自动挂载配置" class="headerlink" title="生成自动挂载配置"></a>生成自动挂载配置</h2><p>使用以下命令生成挂载配置并写入 <code>fstab</code> 文件中 (用 -U 或 -L 选项设置UUID 或卷标)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U &#x2F;mnt &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;fstab</span><br></pre></td></tr></table></figure><p>强烈建议在执行完以上命令后检查一下生成的 <code>/mnt/etc/fstab</code> 文件是否正确。</p><h2 id="进入新系统"><a href="#进入新系统" class="headerlink" title="进入新系统"></a>进入新系统</h2><p>输入 <code>arch-chroot /mnt</code> 临时进入我们的新系统来完成最后的一些配置。</p><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><p>此时这个新系统还处于啥也没有的状态，我们可以使用 <code>pacman</code> 来安装自己想要的软件（考虑到下载速度，你可能需要对这个新系统中的镜像源配置文件做同样的处理），需要注意的是你此时安装的软件在最终配置好的系统中都会保留下来。</p><h3 id="设置文字编码"><a href="#设置文字编码" class="headerlink" title="设置文字编码"></a>设置文字编码</h3><p>编辑 <code>/etc/locale.gen</code> 文件，将 zh_CN 开头的行全部取消注释，再找到 en_US.UTF-8 UTF-8 也取消注释。然后输入 <code>locale-gen</code> 生成 locale 。最后再编辑 <code>/etc/locale.conf</code> 设置本地编码配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LANG&#x3D;en_US.UTF-8</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 最好不要在这里设置任何中文 locale，不然可能会导致命令行乱码。</p><h3 id="设置时区和时间"><a href="#设置时区和时间" class="headerlink" title="设置时区和时间"></a>设置时区和时间</h3><p>运行以下命令将时区设置为 <code>Asia/Shanghai</code> （中国所用的时区）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br></pre></td></tr></table></figure><p>运行 <code>hwclock</code> 以生成 <code>/etc/adjtime</code> （这个命令假定硬件时间已被设置为 UTC 时间）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><p>编辑 <code>/etc/hostname</code> 文件设置自己想要的主机名，编辑 <code>/etc/hosts</code> 设置 host 信息。</p><p>然后输入 <code>mkinitcpio -P</code> 生成启动镜像。</p><p>在那之后输入 <code>passwd</code> 设置一下 root 用户的登录密码。</p><h2 id="配置-GRUB-引导"><a href="#配置-GRUB-引导" class="headerlink" title="配置 GRUB 引导"></a>配置 GRUB 引导</h2><p>还是在我们临时进入的这个新系统里面，输入 <code>pacman -S grub</code> 安装 grub 引导程序，然后输入以下命令安装 BOIS 引导到 <code>/dev/sda</code> 这块硬盘上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target&#x3D;i386-pc &#x2F;dev&#x2F;sda</span><br></pre></td></tr></table></figure><p>最后输入 <code>grub-mkconfig -o /boot/grub/grub.cfg</code> 生成 grub 配置文件就可以了。</p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>之后我们重启一下机器，如果前面的操作没有问题的话应该是能够正常启动我们新安装好的系统的。</p><p>但此时你会发现机器无法联网，因为我们还缺少一个网络管理软件。本着尽量少安装软件的原则，我这里选用的是 <code>systemd-networked</code>，无需单独安装，直接配置好后启动即可。更多设置可以参见 <a href="https://wiki.archlinux.org/index.php/Network_configuration">Network configuration</a> 。</p><p>首先输入 <code>ip a</code> 查看自己机器的网卡配置，并记下网卡名，我这里是 <code>ens3</code> 。</p><p>进入 <code>/etc/systemd/network/</code> 文件夹下，新建一个配置文件 <code>dhcp.network</code> （名字可以任取，后缀为 network 即可），写入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Match]</span><br><span class="line">Name&#x3D;ens3</span><br><span class="line"></span><br><span class="line">[Network]</span><br><span class="line">DHCP&#x3D;ipv4</span><br><span class="line"></span><br><span class="line">[DHCPv4]</span><br><span class="line">UseHostname&#x3D;false</span><br></pre></td></tr></table></figure><p>这表示在 <code>ens3</code> 这张网卡上启用 DHCP 自动分配 ipv4 地址，不使用 DHCP 分配的主机名。<code>[Match]</code> 部分可以使用通配符，例如写成 <code>Name=en*</code> 。</p><p>配置好后启动 <code>systemd-networkd.service</code> 服务，并设置开机自启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start systemd-networkd.service</span><br><span class="line">systemctl enable systemd-networkd.service</span><br></pre></td></tr></table></figure><p>此时你再去测试，会发现仍然无法上网，提示信息翻译过来大意是无法解析到主机，这是因为我们还没有指定一个 DNS 服务器，无法解析域名，所有使用域名的服务都无法使用。</p><p>要解决这个问题只需要编辑 <code>/etc/resolv.conf</code> 写入一组 DNS 服务器即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>要是你不想自己指定 DNS 服务器，也可以使用 DHCP 服务器分配的 DNS（个人比较推荐这样做，速度快一些，能够避免一些奇奇怪怪的问题）。</p><p>首先启动并设置 <code>systemd-resolved.service</code> 开机自启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start systemd-resolved.service</span><br><span class="line">systemctl enable systemd-resolved.service</span><br></pre></td></tr></table></figure><p>然后将 <code>/etc/resolv.conf</code> 设为 <code>systemd-resolved</code> 服务下 DNS 配置文件的软链接即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf &#x2F;run&#x2F;systemd&#x2F;resolve&#x2F;resolv.conf &#x2F;etc&#x2F;resolv.conf</span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>在前面的操作完成后检查一下系统时间，如果不准确，可以启用 NTP 服务来自动更新系统时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl status</span><br><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure><p>如果你的机器需要远程连接，那么还应当安装 <code>ssh</code> 工具并设置开机自启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S openssh</span><br><span class="line">systemctl start sshd</span><br><span class="line">systemctl enable sshd</span><br></pre></td></tr></table></figure><p>需要注意的是 openssh 现在默认禁止 root 用户登录，所以在安装好之后需要新建一个普通用户用于登录或者修改配置文件  <code>/etc/ssh/sshd_config</code> 设置允许 root 用户登录，</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很久之前的一份记录，本来不打算发的，但最近折腾了一下把服务器上的系统在线替换安装成了 Arch Linux，中间涉及到很多本文的步骤，所以还是稍微整理一下发出来吧。&lt;/p&gt;
&lt;p&gt;由于之前做记录只是用于自己备忘，所以全程无图，一些细节部分请对照 &lt;a href=&quot;https://wiki.archlinux.org/index.php/Installation_guide&quot;&gt;官方wiki&lt;/a&gt; 查看，注意安装时需要联网。&lt;/p&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.inkuang.com/tags/Linux/"/>
    
    <category term="系统安装" scheme="https://blog.inkuang.com/tags/%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    
    <category term="Arch Linux" scheme="https://blog.inkuang.com/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统查看某个用户组下面的所有用户</title>
    <link href="https://blog.inkuang.com/2020/103/"/>
    <id>https://blog.inkuang.com/2020/103/</id>
    <published>2020-01-02T21:14:12.000Z</published>
    <updated>2020-01-02T21:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 系统中有关用户组的信息放在 <code>/etc/group</code> 这个文件中，而用户信息放在 <code>/etc/passwd</code> 文件中。</p><p>要查看某个用户组下面的所有用户，很明显我们需要把这两个文件提供的信息结合起来，下面做一些简单的介绍。</p><span id="more"></span><h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><p>在实际动手之前我们先来看看这两个文件中到底存了些啥。由于是纯文本文件，直接使用 <code>cat</code> 命令查看即可。</p><h3 id="用户组信息"><a href="#用户组信息" class="headerlink" title="用户组信息"></a>用户组信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;group</span><br><span class="line">root:x:0:root</span><br><span class="line">sys:x:3:bin</span><br><span class="line">mem:x:8:</span><br><span class="line">ftp:x:11:</span><br><span class="line">mail:x:12:</span><br><span class="line">log:x:19:</span><br><span class="line">smmsp:x:25:</span><br><span class="line">proc:x:26:</span><br><span class="line">adm:x:999:daemon</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到一行表示一个用户组，总共有四个字段，字段之间使用冒号分隔，从左往右依次为：用户组名、用户组密码、用户组ID（GID）、用户列表（可以为空）。详细解释如下：</p><ul><li>用户组名：就是用户组的名字，在同一个 Linux 操作系统中不允许重复</li><li>用户组密码：出于保密性考虑，在这个文件中都是用 x 代替的，真正的密码信息存放在 <code>/etc/gshadow</code> 中</li><li>用户组ID：用户组的唯一标识，这是我们能够实现查找某个用户组下面的所有用户的关键</li><li>用户列表：每个用户之间用 <code>,</code> 号分割，可以为空，如果字段为空表示用户组为 GID 的用户名</li></ul><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0::&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1::&#x2F;:&#x2F;usr&#x2F;bin&#x2F;nologin</span><br><span class="line">daemon:x:2:2::&#x2F;:&#x2F;usr&#x2F;bin&#x2F;nologin</span><br><span class="line">mail:x:8:12::&#x2F;var&#x2F;spool&#x2F;mail:&#x2F;usr&#x2F;bin&#x2F;nologin</span><br><span class="line">ftp:x:14:11::&#x2F;srv&#x2F;ftp:&#x2F;usr&#x2F;bin&#x2F;nologin</span><br><span class="line">http:x:33:33::&#x2F;srv&#x2F;http:&#x2F;usr&#x2F;bin&#x2F;nologin</span><br><span class="line">nobody:x:65534:65534:Nobody:&#x2F;:&#x2F;usr&#x2F;bin&#x2F;nologin</span><br><span class="line">uuidd:x:68:68::&#x2F;:&#x2F;usr&#x2F;bin&#x2F;nologin</span><br><span class="line">git:x:977:977:git daemon user:&#x2F;:&#x2F;usr&#x2F;bin&#x2F;git-shell</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>同样的一行表示一个用户，共有七个字段，字段之间使用冒号分隔，从左往右依次为：用户名、用户密码、用户ID（UID），用户所在组的ID（GID），一些说明信息，用户的家目录，用户登录后的 shell。详细解释如下：</p><ul><li>用户名：用户登录时使用的名字，区分大小写，在同一个 Linux 操作系统中不允许重复</li><li>用户密码：用户密码都是同样的都是用 x 代替。真正的密码信息存放在 <code>/etc/shadow</code> 文件中</li><li>用户ID：用户的唯一标识，系统是通过 UID 来识别不同的用户和分配用户权限的。只有 UID&gt;500 的用户才是普通用户，其他都是系统用户（也称为伪用户），是用来运行系统服务的，不能登录，也不能删除</li><li>用户所在组的ID：这个”用户所在组“指的是初始组，用户一登录就立即拥有这个组的相关权限。每个用户只能有一个初始组，一般就是将和组名这个用户的用户名相同的组作为这个用户的初始组。除此之外还有附加组等</li><li>一些说明信息：就是对该用户的一些描述，功能类似于注释，没有什么实际作用</li><li>用户的家目录：即用户的 <code>~</code> 所代表的路径，一般情况下用户拥有他的家目录的所有权限</li><li>用户登录后的 shell：用户登录后所使用 shell 的可执行文件路径，可以通过这里限制用户的登录行为</li></ul><h2 id="查找方式"><a href="#查找方式" class="headerlink" title="查找方式"></a>查找方式</h2><p>Linux 系统中使用 UID 唯一标识一个用户，使用 GID 唯一标识一个用户组，再结合上面两个文件中的其他信息，我们很容易就能找到一个“查看一个用户组内所有用户”的方式。</p><p>首先从 <code>/etc/group</code> 文件中找出我们需要查找的用户组的 GID（这里以 http 用户组为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;group | grep http</span><br><span class="line">http:x:33:</span><br></pre></td></tr></table></figure><p>从上面的结果中可以看到 http 用户组的 GID 是 33，接下来我们从 <code>/etc/passwd</code> 文件中找出所有的用户所在组ID为 33 的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F &quot;:&quot; &#39;&#123;print $1&quot;\t&quot;$4&#125;&#39; &#x2F;etc&#x2F;passwd | grep &#39;33&#39;</span><br></pre></td></tr></table></figure><p>会一点 shell 编程的人应该很容易看懂这句命令的意思。先是使用 <code>awk</code> 的 <code>-F</code> 参数指定使用使用冒号作为分隔符，然后 <code>&#123;print $1&quot;\t&quot;$4&#125;</code> 打印输出第一列和第四列（即用户名和 GID），中间用一个制表符 <code>\t</code> 分隔开来，最后将结果通过管道送给 <code>grep</code> 处理，从中查找出所有包含字符串“33”的行。</p><p>上述命令的输出结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http33</span><br></pre></td></tr></table></figure><p>这说明在我使用的系统中 http 用户组下只有一个名为 http 的用户。查找其他用户组的操作同理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 系统中有关用户组的信息放在 &lt;code&gt;/etc/group&lt;/code&gt; 这个文件中，而用户信息放在 &lt;code&gt;/etc/passwd&lt;/code&gt; 文件中。&lt;/p&gt;
&lt;p&gt;要查看某个用户组下面的所有用户，很明显我们需要把这两个文件提供的信息结合起来，下面做一些简单的介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.inkuang.com/tags/Linux/"/>
    
    <category term="常用命令" scheme="https://blog.inkuang.com/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>纯 Nginx 实现一个 IP 地址显示 API</title>
    <link href="https://blog.inkuang.com/2019/1203/"/>
    <id>https://blog.inkuang.com/2019/1203/</id>
    <published>2019-12-03T07:11:07.000Z</published>
    <updated>2019-12-03T07:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>如标题所示，不依赖任何后端方法，使用纯 Nginx 实现（Nginx-Lua 也不需要）一个“显示我的 IP 地址”的 API。</p><p>实际上这是我在很久之前看过的一篇文章中介绍的技巧，时间有点久了，一时半会儿也找不到原文地址，但发现自己当时写的 Nginx 配置文件还在，所以翻出来分享一下。</p><span id="more"></span><h2 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h2><p>Nginx 的配置文件中提供了一个变量 <code>$remote_addr</code> 用来获取用户访问本实例时的 IP 地址，我们只要将这个变量的值返回给用户就行了（没错，就是这么简单！）：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">default_type</span> text/plain;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> $remote_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>default_type text/plain</code> 来向浏览器表明我们返回的值是一个纯文本，从而能够被浏览器直接显示出来。</p><h2 id="JSON-版本"><a href="#JSON-版本" class="headerlink" title="JSON 版本"></a>JSON 版本</h2><p>同样依赖于 <code>$remote_addr</code> 这个变量，我们可以将返回值稍微修饰一下，实现一个返回 JSON 数据的 API：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /json &#123;</span><br><span class="line">    <span class="attribute">default_type</span> application/json;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;&#123;\&quot;ip\&quot;:\&quot;$remote_addr\&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中的 <code>default_type application/json</code> 向浏览器表明我们的返回的值是 JSON 数据。</p><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>配置好后可以使用 <code>curl</code> 来测试一下（下面的 API 域名和返回值中的 IP 地址都做了替换处理，非真实情况）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;example.com&#x2F;</span><br><span class="line">xx.xx.xx.xx</span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;example.com&#x2F;json</span><br><span class="line">&#123;&quot;ip&quot;:&quot;xx.xx.xx.xx&quot;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如标题所示，不依赖任何后端方法，使用纯 Nginx 实现（Nginx-Lua 也不需要）一个“显示我的 IP 地址”的 API。&lt;/p&gt;
&lt;p&gt;实际上这是我在很久之前看过的一篇文章中介绍的技巧，时间有点久了，一时半会儿也找不到原文地址，但发现自己当时写的 Nginx 配置文件还在，所以翻出来分享一下。&lt;/p&gt;</summary>
    
    
    
    <category term="趣味分享" scheme="https://blog.inkuang.com/categories/%E8%B6%A3%E5%91%B3%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="Nginx" scheme="https://blog.inkuang.com/tags/Nginx/"/>
    
    <category term="自建服务" scheme="https://blog.inkuang.com/tags/%E8%87%AA%E5%BB%BA%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>为 Debian 下 root 用户的 ls 命令开启颜色显示</title>
    <link href="https://blog.inkuang.com/2019/1118/"/>
    <id>https://blog.inkuang.com/2019/1118/</id>
    <published>2019-11-18T02:39:39.000Z</published>
    <updated>2019-11-18T02:39:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>平时自己折腾时还是比较喜欢更轻量一些的 Debian 系统。然而用过 Debian 的应该都知道，它的 root 用户使用 ls 命令时的输出默认是不带颜色显示的。</p><p>这虽然不是什么大问题，但对使用体验的影响还是不小的。查了一些资料后找到了解决方案，在这里记录一下吧。</p><span id="more"></span><h2 id="问题详情"><a href="#问题详情" class="headerlink" title="问题详情"></a>问题详情</h2><p>使用 root 用户登录一个刚刚安装好的 Debian 系统，然后使用 ls 命令试试。如下图，输出结果是不带颜色显示的。这导致我们很难把文件、文件夹、可执行文件、普通文件区分开来，十分影响使用体验。</p><p><img data-src="/images/2019/1118/1.jpg" alt="不带颜色显示的 ls 命令输出结果"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决方法其实很简单，修改用户目录下的 <code>.bashrc</code> 文件，把 ls 设置为带颜色参数的 ls 命令的别名（alias）即可。当然，这个别名实际上也不需要我们去手动添加，<code>.bashrc</code> 文件中本来就有，我们只要将其取消注释就行了。</p><p>使用 vim 编辑 <code>.bashrc</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>打开该文件后我们可以找到如下几行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># You may uncomment the following lines if you want `ls&#x27; to be colorized:</span></span><br><span class="line"><span class="comment"># export LS_OPTIONS=&#x27;--color=auto&#x27;</span></span><br><span class="line"><span class="comment"># eval &quot;`dircolors`&quot;</span></span><br><span class="line"><span class="comment"># alias ls=&#x27;ls $LS_OPTIONS&#x27;</span></span><br><span class="line"><span class="comment"># alias ll=&#x27;ls $LS_OPTIONS -l&#x27;</span></span><br><span class="line"><span class="comment"># alias l=&#x27;ls $LS_OPTIONS -lA&#x27;</span></span><br></pre></td></tr></table></figure><p>这里第一行的注释已经说得很清楚了：如果你想要 ls 命令被“着色”，可以把下面几行取消注释。根据这一说明，我们把下面几行的注释取消掉后保存文件即可。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>按照上面的步骤修改好后，重新开一个对话使用 ls 命令试试看。可以发现输出结果已经自动带上颜色显示了，文件、文件夹等不同类型的输出一目了然。</p><p><img data-src="/images/2019/1118/2.jpg" alt="带颜色显示的 ls 命令输出结果"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;平时自己折腾时还是比较喜欢更轻量一些的 Debian 系统。然而用过 Debian 的应该都知道，它的 root 用户使用 ls 命令时的输出默认是不带颜色显示的。&lt;/p&gt;
&lt;p&gt;这虽然不是什么大问题，但对使用体验的影响还是不小的。查了一些资料后找到了解决方案，在这里记录一下吧。&lt;/p&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.inkuang.com/tags/Linux/"/>
    
    <category term="常用命令" scheme="https://blog.inkuang.com/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>在没有管理员权限的 Linux 服务器上安装 vim</title>
    <link href="https://blog.inkuang.com/2019/1006/"/>
    <id>https://blog.inkuang.com/2019/1006/</id>
    <published>2019-10-06T09:40:46.000Z</published>
    <updated>2019-10-06T09:40:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近拿到了一个实验室的服务器帐号用来跑一些计算，是一个没有 <code>sudo</code> 权限的普通用户帐号。</p><p>本来以为有没有管理员权限对我都没啥影响，结果登上去一看，发现这台新配的服务器很多东西都还没来得及装，连 vim 都没有，在命令行下改东西只能用 vi，十分的不方便（没有高亮）。</p><span id="more"></span><p>由于没有管理员权限，用 apt 安装肯定是不用想的，只能尝试源码编译安装了。</p><h2 id="尝试编译"><a href="#尝试编译" class="headerlink" title="尝试编译"></a>尝试编译</h2><p>首先从 vim 的官网或者 GitHub 下载源码，截至本文发布官网最新版本是 8.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载源码</span><br><span class="line">wget ftp:&#x2F;&#x2F;ftp.vim.org&#x2F;pub&#x2F;vim&#x2F;unix&#x2F;vim-8.1.tar.bz2</span><br><span class="line"># 解压</span><br><span class="line">tar -jxvf vim-8.1.tar.bz2</span><br></pre></td></tr></table></figure><p>解压后我们进入源码文件夹执行 <code>./configure</code> 尝试生成 Makefile 文件。这里需要注意的是，vim 默认将最后的编译产物放在 <code>/usr/local</code> 下（可以执行 <code>./configure --help</code> 查看），而我们没有管理员权限，无权操作该文件夹（一般普通用户只能操作自己用户目录下面的文件夹），所以需要手动指定一下安装目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vim81</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;km&#x2F;opt&#x2F;vim81</span><br></pre></td></tr></table></figure><p>我们自然是没有那份能够一次性成功的运气，执行过程中遇到了如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checking for tgetent()... configure: error: NOT FOUND!</span><br><span class="line">      You need to install a terminal library; for example ncurses.</span><br><span class="line">      Or specify the name of the library with --with-tlib.</span><br></pre></td></tr></table></figure><p>这个报错说的算是比较清楚了：没有找到终端库，让我们去安装一个。</p><p>根据这个报错说明，装 ncurses 肯定是可以的。一般遇到这种情况都是直接用 apt 去安装（有管理员权限的话，ubuntu 下执行 <code>sudo apt install libncurses5-dev</code> 即可安装），然而跟我们无法直接安装 vim 同样的原因：<strong>没有管理员权限</strong>，这个依赖库也只能靠编译安装了。</p><h2 id="编译安装-ncurses"><a href="#编译安装-ncurses" class="headerlink" title="编译安装 ncurses"></a>编译安装 ncurses</h2><p>同样的首先需要下载源码，截至本文发布最新的版本是 6.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">wget https:&#x2F;&#x2F;ftp.gnu.org&#x2F;pub&#x2F;gnu&#x2F;ncurses&#x2F;ncurses-6.1.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar -xzvf ncurses-6.1.tar.gz</span><br></pre></td></tr></table></figure><p>同样的，执行 <code>./configure</code> 的时候我们需要指定一个自己有操作权限的安装目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ncurses-6.1</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;km&#x2F;opt&#x2F;ncurses-6.1</span><br></pre></td></tr></table></figure><p>这次倒是一次成功没有遇到任何问题，接下来编译后安装就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>执行完之后可以在我们指定的安装目录下找到 <code>bin、include、lib、share</code> 几个文件夹。</p><h2 id="重新尝试编译"><a href="#重新尝试编译" class="headerlink" title="重新尝试编译"></a>重新尝试编译</h2><p>在编译安装好 ncurses 之后我们回到 vim 源码所在的目录重新执行 <code>./configure</code> 。需要注意的是，我们安装的 ncurses 不在标准目录下，所以在编译其他依赖 ncurses 的程序的时候需要手动指定一下相关文件所在的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;km&#x2F;opt&#x2F;vim81 LDFLAGS&#x3D;-L&#x2F;home&#x2F;km&#x2F;opt&#x2F;ncurses-6.1&#x2F;lib CPPFLAGS&#x3D;-I&#x2F;home&#x2F;km&#x2F;opt&#x2F;ncurses-6.1&#x2F;include</span><br></pre></td></tr></table></figure><p>这次直接一路到底，没有出现任何报错，接下来编译后安装一下就可以啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>在安装完之后可以在我们指定的安装目录下（我这里是 <code>/home/km/opt/vim81</code> ）找到 <code>bin</code> 和 <code>share</code> 两个目录，vim 的可执行文件就存放在 <code>bin</code> 目录下。</p><p>用绝对路径执行一下试试： <code>/home/km/opt/vim81/bin/vim</code> ，可以看到熟悉的界面就说明编译安装成功啦。</p><h2 id="一些其他设置"><a href="#一些其他设置" class="headerlink" title="一些其他设置"></a>一些其他设置</h2><p>每次都像上面那样用相对/绝对路径来运行 vim 无疑是很麻烦的，我们这里为编译出来的可执行文件设置一个 alias 以方便使用（将 vim 的可执行文件路径添加到 PATH 环境变量中也能实现同样地效果）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 编辑用户目录下的 .bashrc文件</span><br><span class="line">vi ~&#x2F;.bashrc</span><br><span class="line"># 在最后添加一行 alias</span><br><span class="line">alias vim&#x3D;&#39;&#x2F;home&#x2F;km&#x2F;opt&#x2F;vim81&#x2F;bin&#x2F;vim&#39;</span><br></pre></td></tr></table></figure><p>保存文件后使用 <code>source ~/.bashrc </code> 激活设置，之后就可以在任何位置直接输入 <code>vim</code> 使用啦。</p><p>另外，在实际使用中发现这样自己编译出来的 vim 存在这篇文章：<a href="/2019/504/">Debian9 下为 vim 启用鼠标复制粘贴</a> 中提到的无法使用鼠标右键复制粘贴的问题（系统是 Ubuntu 18.04）。要解决这个问题也很简单，修改一下 vim 的用户配置文件即可（由于这样安装的 vim 只有自己一个账户能用，所以修改用户个人配置文件即可，那篇文章中修改的是 vim 的全局配置文件）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在当前用户目录下新建 vim 配置文件目录</span><br><span class="line">mkdir ~&#x2F;.vim</span><br><span class="line"># 新建 vim 用户配置文件并编辑</span><br><span class="line">vim ~&#x2F;.vim&#x2F;vimrc</span><br><span class="line"></span><br><span class="line"># 在其中写入如下内容（注意将 source 后面的文件路径修改为自己的）</span><br><span class="line">source &#x2F;home&#x2F;km&#x2F;opt&#x2F;vim81&#x2F;share&#x2F;vim&#x2F;vim81&#x2F;defaults.vim</span><br><span class="line">let skip_defaults_vim &#x3D; 1</span><br><span class="line">if has(&#39;mouse&#39;)</span><br><span class="line">    set mouse-&#x3D;a</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>保存文件并退出，再次使用 vim 时就会发现能够正常的使用鼠标右键来进行复制粘贴操作啦！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在这样一顿操作编译安装好 vim 后的第二天，成功找当初给我分配服务器帐号的学长搞到了 <code>sudo</code> 权限，所以……可执行文件、源码啥的统统删掉！然后 <code>sudo apt install vim</code> ……（手动狗头）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近拿到了一个实验室的服务器帐号用来跑一些计算，是一个没有 &lt;code&gt;sudo&lt;/code&gt; 权限的普通用户帐号。&lt;/p&gt;
&lt;p&gt;本来以为有没有管理员权限对我都没啥影响，结果登上去一看，发现这台新配的服务器很多东西都还没来得及装，连 vim 都没有，在命令行下改东西只能用 vi，十分的不方便（没有高亮）。&lt;/p&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.inkuang.com/tags/Linux/"/>
    
    <category term="vim" scheme="https://blog.inkuang.com/tags/vim/"/>
    
    <category term="编译" scheme="https://blog.inkuang.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>为什么 vim 使用 hjkl 键作为方向键</title>
    <link href="https://blog.inkuang.com/2019/930/"/>
    <id>https://blog.inkuang.com/2019/930/</id>
    <published>2019-09-30T07:11:56.000Z</published>
    <updated>2019-09-30T07:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>初次接触 vi/vim 编辑器的人可能都会有个疑问：用 <code>hjkl</code> 键（作为方向键）控制光标移动是什么鬼？</p><p>关于这个问题，以前网络上有一种说法，手指放在键盘上输入时，<code>hjkl</code> 键比方向键距离手指更近，输入效率自然就会更高。这听起来似乎很有道理，然而我最近查了一点资料，却发现真实情况有点让人啼笑皆非。</p><span id="more"></span><p>vim 是从 vi 发展出来的，使用了一样的键位设置，所以一切问题都要追述到 vi 编辑器的发明者 Bill Joy 身上。</p><p>在那个时代自然是没有我们现在这么五花八门的强大计算机，Bill Joy 是在一台 ADM-3A 终端机上开发的 vi 编辑器，它就长下面这样。</p><p><img data-src="/images/2019/0930/1.jpg"></p><p>我们重点关注一下它的键盘。</p><p><img data-src="/images/2019/0930/2.jpg"></p><p>嗯，这下知道为什么要使用 <code>hjkl</code> 键作为方向键了吗？因为它们上面标有方向箭头啊，不用这几个键用啥？</p><p>另外，vim 饱受诟病的使用 <code>Esc</code> 键切换模式的操作（模式切换属高频动作，但现代键盘上 <code>Esc</code> 键太远了，按起来很不方便）也是因为这个键盘布局导致的，看看那时候的 <code>Esc</code> 键离手指多近啊……</p><p>最后，从上面的键盘布局图中我们还能发现一个有趣的事情，看看右上角的 <code>HOME</code> 键，发现了什么吗？没错，那时候的 <code>~</code> 和 <code>HOME</code> 是在一个键上面的，这就是起源于那个时代的 UNIX/Linux 系统中使用 <code>~</code> 表示 home 目录的原因。</p><p><strong>参考资料：</strong><a href="https://catonmat.net/why-vim-uses-hjkl-as-arrow-keys">https://catonmat.net/why-vim-uses-hjkl-as-arrow-keys</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;初次接触 vi/vim 编辑器的人可能都会有个疑问：用 &lt;code&gt;hjkl&lt;/code&gt; 键（作为方向键）控制光标移动是什么鬼？&lt;/p&gt;
&lt;p&gt;关于这个问题，以前网络上有一种说法，手指放在键盘上输入时，&lt;code&gt;hjkl&lt;/code&gt; 键比方向键距离手指更近，输入效率自然就会更高。这听起来似乎很有道理，然而我最近查了一点资料，却发现真实情况有点让人啼笑皆非。&lt;/p&gt;</summary>
    
    
    
    <category term="逸趣杂谈" scheme="https://blog.inkuang.com/categories/%E9%80%B8%E8%B6%A3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="vim" scheme="https://blog.inkuang.com/tags/vim/"/>
    
    <category term="杂谈" scheme="https://blog.inkuang.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 隐藏版本号信息</title>
    <link href="https://blog.inkuang.com/2019/912/"/>
    <id>https://blog.inkuang.com/2019/912/</id>
    <published>2019-09-12T02:52:33.000Z</published>
    <updated>2019-09-12T02:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们使用 apt 或者其他包管理工具安装完 Nginx 之后，访问网站时 Header 里面会默认携带 Nginx 的版本号信息。命令行下可以使用 <code>curl -I http://your-domain</code> 查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;2 200 </span><br><span class="line">server: nginx&#x2F;1.16.1     #这里带有版本号信息</span><br><span class="line">date: Thu, 12 Sep 2019 03:06:23 GMT</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;</span><br><span class="line">cache-control: public</span><br><span class="line">content-language: auto</span><br></pre></td></tr></table></figure><span id="more"></span><p>而软件漏洞往往都是跟版本绑定的，在管理员没有及时更新修复漏洞的情况下，一旦攻击者知道了你用的 Nginx 版本就能轻松利用已知漏洞实现入侵。</p><p>这无疑是一个安全隐患，所以对版本号进行隐藏就一定必要了（当然，更新修复漏洞才是解决问题的根本途径）。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>要隐藏 Nginx 版本号其实很简单，稍微修改一下配置文件即可。这里使用 vim 编辑器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><p>在 <code>http&#123;&#125;</code> 段中添加一行 <code>server_tokens off;</code> </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后保存文件，测试 Nginx 配置文件是否正常后重载配置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -t            #测试配置文件是否正常</span><br><span class="line">sudo nginx -s reload     #重载nginx配置</span><br></pre></td></tr></table></figure><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>配置好之后可以再用 <code>curl</code> 测试一下，会发现不再显示 Nginx 版本号了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;2 200 </span><br><span class="line">server: nginx       #版本号信息没有了</span><br><span class="line">date: Thu, 12 Sep 2019 03:32:16 GMT</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;</span><br><span class="line">cache-control: public</span><br><span class="line">content-language: auto</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;当我们使用 apt 或者其他包管理工具安装完 Nginx 之后，访问网站时 Header 里面会默认携带 Nginx 的版本号信息。命令行下可以使用 &lt;code&gt;curl -I http://your-domain&lt;/code&gt; 查看：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HTTP&amp;#x2F;2 200 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server: nginx&amp;#x2F;1.16.1     #这里带有版本号信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: Thu, 12 Sep 2019 03:06:23 GMT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;content-type: text&amp;#x2F;html; charset&amp;#x3D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache-control: public&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;content-language: auto&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="技术教程" scheme="https://blog.inkuang.com/categories/%E6%8A%80%E6%9C%AF%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="配置文件" scheme="https://blog.inkuang.com/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
    <category term="Nginx" scheme="https://blog.inkuang.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>浏览器野史 —— UserAgent 列传【转载】</title>
    <link href="https://blog.inkuang.com/2019/825/"/>
    <id>https://blog.inkuang.com/2019/825/</id>
    <published>2019-08-25T06:56:14.000Z</published>
    <updated>2019-08-25T06:56:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。<br>控制台敲下：<code>navigator.userAgent</code><br>浏览器回应：<code>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36</code></p><span id="more"></span><p>天，这串是啥？你怎么连话都说不清楚？<br>我对 UserAgent 并不陌生，但明明一个单词就可以说清楚的事情，却是这么掏心掏肺的回答。怪可怜的，一定有冤情。<br>后来我查阅了很多资料，发现历史非常的精彩。</p><h2 id="大事年表"><a href="#大事年表" class="headerlink" title="大事年表"></a>大事年表</h2><ul><li>1990年: Nexus ( WorldWideWeb )诞生</li><li>1993年1月23日：Mosaic 诞生</li><li>1994年12月：Netscape ( Mozilla )诞生</li><li>1995年4月：Opera 诞生</li><li>1995年8月16日：Internet Explorer 诞生</li><li>2002年9月23日：Firefox 诞生</li><li>2003年1月7日：Safari 诞生</li><li>2008年9月2日：Chrome 诞生</li></ul><h2 id="一、盘古开天地"><a href="#一、盘古开天地" class="headerlink" title="一、盘古开天地"></a>一、盘古开天地</h2><p>很久很久之前，上古大神 Berners-Lee 发明了 WorldWideWeb ，即万维网。同时，李大神也发明了第一款浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？<br>但大神就是大神，大神内心的想法又岂是尔等凡人能够肆意揣摩？</p><p>万万没想到，李大神说，我这浏览器，也叫 WorldWideWeb ！不行么？<br>行行行。</p><p>虽然李大神起名字这么拽，但他后来发觉，还是得赋予一点承上启下的历史意义，就改名成“Nexus”。值得注意的是，这浏览器，居然是可以兼容 Unix 跟 Microsoft DOS 的。它在当时流行的各种电脑上跑得飞起，应用也越来越广，被称为“杀手级应用”。杀手级…你们看互联网一开始就是这么的腥风血雨。</p><p>但这个浏览器，还不支持图片的显示，这是出现 UserAgent 的导火索。</p><h2 id="二、唐尧虞舜"><a href="#二、唐尧虞舜" class="headerlink" title="二、唐尧虞舜"></a>二、唐尧虞舜</h2><p>93 年，伊利诺大学的 NCSA 组织认为，浏览器无图无真相，这不好。因而他们发明了第一款可显示图片的浏览器。<br>真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？<br>但大神就是大神，大神就是连起名字都让你惊心动魄。</p><p>NCSA 组织说，它能显示图片，偏偏我们就要叫它“马赛克( Mosaic )”！不行么？<br>行行行。</p><p>但有人就问了，Nexus 不显示图片，Mosaic 能显示，你们让 html 提供者怎么写代码？你们是不是想逼死选择困难症患者？有没有考虑过天秤座的感受？</p><p>因而 UserAgent 就诞生了。Mosaic 将自己标志为 <code>NCSA_Mosaic/2.0 (Windows 3.1)</code> ，大家该怎么写代码就怎么写，但请求会带上这个信息，服务器就知道该不该返回能显示图片的 html 。UserAgent 君，出生时跟我们设想的一样简单，仅仅标明了自己是什么浏览器，在什么系统运行，以及各自的版本号。</p><p>新旧浏览器们像彬彬有礼的君王，商议和让位是为了更好的繁荣。但风雨欲来。</p><h2 id="三、楚汉争霸"><a href="#三、楚汉争霸" class="headerlink" title="三、楚汉争霸"></a>三、楚汉争霸</h2><p>像刘邦一样，走出来一个搅局的小流氓。当然他还是很有志向的，他的目标，就是战胜霸主 Mosaic。后来，他还真的做到了。<br>如今，所有现代浏览器的 UserAgent 里都有它的标志，就像汉朝之后，我们都称为“汉”人。一群很有天赋的程序员，一起缔造了它的辉煌。</p><p>真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？<br>但大神就是大神，大神就是让你永远也猜不到他们想了个什么名字。<br>大神们说，叫 Mozilla，不行么？<br>行。但什么意思呢？</p><p>含义有二。其一，哥斯拉( Godzilla )谐音，诚然是一头野心勃勃的怪兽；其二，”Mosaic Killa”之意， Killa 是俚语中 Killer 的拼法，即“马赛克的终结者”，赤裸裸的挑战。</p><p>惊呆了的 Mosaic 小心翼翼的念着 Mozilla 这发音：“Mo…摸咋了？”勃然大怒，“摸你妹！”</p><p>鉴于 Mosaic 当时的权势，Mozilla 改名成 Netscape Navigator (网景航海家)。小怪兽突然变成有点文艺小清新的名字，郁闷得很，但内心的血液沸腾着。虽然叫大名叫网景，但它把 UserAgent 偷偷设置成 <code>Mozilla/1.0 (Win3.1)</code> 。还是摸咋了？咬我？</p><h2 id="四、宋元之战"><a href="#四、宋元之战" class="headerlink" title="四、宋元之战"></a>四、宋元之战</h2><p>很快， NetScape 战胜了 Mosaic ，成为了新的霸主，因为其更优的展示。<br>NetScape 最先支持了 html 框架显示，就是简单的 table 布局，内外边距之类，仅仅这点就将 Mosaic 抛诸身后。区别这两个浏览器，还是用的 UserAgent 。如果是 UserAgent 里含有“Mozilla”字样，那就发送支持框架的页面，否则，就发送不含框架的页面。</p><p>NetScape 帝国日益庞大，歌舞升平，一切风平浪静，直到微软的铁骑挥军南下。</p><p>微软发布了一款跟系统强绑定的浏览器，真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？<br>不用想了，就是 IE 。这命名也相当简单粗暴， Internet Explorer ，直接把这工具的用途拍在你脸上。连说明书都可以免了。</p><p>IE也是支持 html 标准框架的，但由于前面的历史原因，人们只会给 UserAgent 里含有“Mozilla”字样的浏览器发送含框架的页面。但这点小事能难倒我大微软？ IE 呵呵一笑，把自己的 UserAgent 改成 <code>Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)</code> 。看，我这里也有 “Mozilla” 字样，也能收到含框架的页面了！</p><p>当然，这个小流氓行为，跟后来把 IE 和 Windows 捆绑一起销售的大流氓行为比起来，根本不为足道。后面的故事我们也知道了， IE 把 NetScape 干掉了。但它的身体上，却永远的烙上了“Mozilla”的印记。</p><h2 id="五、康乾盛世"><a href="#五、康乾盛世" class="headerlink" title="五、康乾盛世"></a>五、康乾盛世</h2><p>看过奥特曼的都知道，怪兽被打败了会再回来。别忘了 NetScape 曾拥有一批大神们，失败后，他们围绕着浏览器排版引擎 Gecko (壁虎)成立了非正式组织 Mozilla 。小怪兽再次出发。大神们发明了另一款优秀的浏览器，它在插件拓展和开发调试领域做出的贡献，绝对可以载入互联网历史。</p><p>真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？<br>但大神就是大神，大神就是即使你知道了 Mozilla 的命名都是野兽，却还是猜不到是什么。<br>Mozilla 说，我们浴火重生，叫 Phoenix (凤凰)！不行么？<br>真不行。</p><p>刚推出就被人告了，原来已经有一家公司叫做“凤凰科技”。<br>Mozilla 瀑布汗，改名叫 Firebird (火鸟)！还不行么？<br>我们得原谅一下他们的取名，虽然现在看来满满的山寨感，可放在那个时代， Firebird 这名字很炫酷。就像你当初的 QQ 昵称叫赤炎天使感觉依然良好一样。</p><p>但是，他们发现，业内有个数据库系统，也叫的 Firebird …泪流满面的 Mozilla 感慨重生好难呀。最后才决定叫Firefox (火狐)。</p><p>基于 Gecko 引擎的 Firefox 非常优秀，为了告诉大家，我使用了这个引擎，它标志自己的 UserAgent 为 <code>Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0</code> 。<br>这时候的 UserAgent ，虽然长了点，但它并不混乱，准确的标明了系统，排版引擎，浏览器名称等信息。虽然 IE 这时已经占有了很大的市场份额，但基本停步不前；而 Mozilla 经过一段时间的修生养息，Firefox 在业内广受好评，得到了快速的发展。</p><p>时值 2003 年， web2.0 的浪潮前夕，浏览器的发展达到了空前的盛世。<br>然而所谓否极泰来，盛极则衰。涅槃的 Firefox 迎来盛世，却又恰恰由于盛世，决定了 UserAgent 纠结的命运。</p><h2 id="六、师夷长技"><a href="#六、师夷长技" class="headerlink" title="六、师夷长技"></a>六、师夷长技</h2><p>前面说到，微软靠 Windows 系统捆绑IE销售。而 Windows 自然也有它的对手，Linux 。一个技术快速发展的时代，系统的世界里也是战火纷飞。 Linux 系统自从有了可视化界面，也需要浏览器呀。桌面系统 KDE 的缔造者们就发明了一个。</p><p>真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？<br>但大神就是大神，大神就是讲究先从文字上占据压垮你的气势。<br>先有 Navigator 航海家，再有 Explorer 探索者，咱就叫 Konqueror ( Conqueror 的变体)征服者吧。<br>行行行。我已懒得理这帮大神…</p><p>可是，问题来了。 Konqueror 使用 KHTML 排版引擎，即使它们认为自己跟 Gecko 引擎一样优秀，但用户不买单。你 UserAgent 里没有“Gecko”字样，我就不给你经过优良排版的 html。<br>结果， Konqueror 思来想去，做了一个艰难但很萌的决定，把 UserAgent 写成 <code>Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)</code> …<br>这就是现代浏览器里 <code>like Gecko</code> 这一萌词的由来。</p><p>就这样，伟大的排版引擎 KHTML 为了获得更好的资源，师夷长技。这并没什么不好，却造成了 UserAgent 的越发混乱。<br>KHTML 与 Gecko 这一对，永远卿卿我我比翼双飞在 UserAgent 里面了。那个满含深意的“like”，有人觉得翻译成“像”，但也有人觉得应该是“喜欢”…</p><h2 id="七、世界大战"><a href="#七、世界大战" class="headerlink" title="七、世界大战"></a>七、世界大战</h2><p>首先是 IE 冷静下来了，他觉得，你们不带这么玩的？<br>就我年少时不懂事，首先改了个 Mozilla 字样，后面追究这历史我岂不是成了罪魁祸首？我改还不行吗？<br>在 IE6 ，它明确自己 UserAgent 为 <code>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)</code> 。除去已经注定不可抹去的“Mozilla”字样，其余信息简洁，准确，清晰。</p><p>但事态已经不可收拾。</p><p>Opera 给这狂躁的世界添了一把火。它觉得，易容术非常炫酷呀。Opera 直接在菜单提供了 <code>Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51</code> ， <code>Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51</code> ， <code>Opera/9.51 (Windows NT 5.1; U; en)</code> 三个选择项。第一个是易容成 IE ，第二个是易容成火狐，第三个才是自己，选谁就是谁！</p><p>其实这并不是一件坏事。因为 Opera 是站在能够让用户通过选择，去获得更好的浏览体验的基础上的。你提供选择，或是不提供，混乱的 UserAgent 还是在这，不离，不弃。再者，这对网页的开发者有极大的好处，在某些情况，你不必同时打开几个不同的浏览器去调试。到目前，最新的 Chrome 浏览器更加炫酷，能够支持近 40 种不同的 UserAgent ，甚至你还可以自定义。当然这是后话。</p><p>与此同时，苹果公司依靠内核 WebKit ，开发出 Safari ，命名 UserAgent 为 <code>Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5</code> 。</p><p>有人就会问了，不是 Webkit 内核吗，怎么还有 <code>KHTML, like Gecko</code> ？注意，内核 Webkit 包含了一个排版引擎叫 WebCore ，而 WebCore 是 KHTML 衍生而来的。也就是说， WebCore 是 KHTML 的儿子，子承父业，基因差不多。为了能够正常排版， safari 只能这么写。</p><p>后来， google 也开发了自己的浏览器 Chrome ，其内核也是 Webkit ，但它设定 UserAgent 为 <code>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13</code> 。Safari一看，不对劲啊！你怎么也在后面写有 Safari ？ Chrome 呵呵一笑，你懂的。</p><p>因此，请让我一口气说完下面这一段：<br>Chrome 希望能得到为 Safari 编写的网页，于是决定装成 Safari ， Safari 使用了 WebKit 渲染引擎，而 WebKit 呢又伪装自己是 KHTML ， KHTML 呢又是伪装成 Gecko 的。同时所有的浏览器又都宣称自己是 Mozilla 。</p><p>这就是整个 UserAgent 世界大战的格局…</p><h2 id="八、军阀混战"><a href="#八、军阀混战" class="headerlink" title="八、军阀混战"></a>八、军阀混战</h2><p>将目光聚焦到国内，更是狼烟四起，混乱不堪。大家都知道，浏览器是互联网的入口，这块肥肉谁也不想丢。因而一个接一个的“国产”浏览器进入斗兽场。<br>360 ，百度， QQ ， UC ，搜狗，猎豹，遨游，世界之窗…你能说出一大堆。连淘宝，酷狗， hao123 都有浏览器，不信你搜。<br>注意我前面“国产”两个字必须加上双引号，因为这个 made in china 并不纯。国人并没能像远古大神一样，硬生生发明一个内核出来，我们更擅长“微创新”。</p><p>利用 Trident （ IE 的内核），包装一下皮肤，美化一下，就可以说：完美兼容<br>利用 Webkit ，包装一下皮肤，美化一下，就可以说：极速浏览<br>把两个内核都包起来，就可以说：智能双核</p><p>是微创新！读书人的事，能叫偷吗？</p><p>在这插播一下，浏览器的“双核”，并不是你听说手机双核电脑双核那回事。再多个核，速度也不会更快，当然这么说，会显得很厉害的样子。德艺双馨，智勇双全，名利双收，才貌双绝，夫妻双双把家还，你看带“双”字的词都很牛的。</p><p>但我上面的叙述，的确有夸张的成分。浏览器的诞生，肯定不仅仅是包一下皮肤那么简单，国内的工程师们，也苦心研究做了许多工作。如果要说优化策略，我可以再写一篇超级长的文章。优化无止境，路漫漫其修远，向同行们致敬。只是我非常讨厌那些不把事实说清楚，纯粹靠文案去忽悠人的产品…</p><p>话说回来，这么多国产浏览器，总得靠不同 UserAgent 标志自己呀。<br>大家自动分为两个阵营：使用 Trident 内核的，在 IE 已有 UserAgent 后添加自己的名称；使用 Webkit 内核的，就在 Chrome 的 UserAgent 后面添加。</p><p>前者像 QQ 浏览器： <code>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.7.26717.400)</code> 。<br>后者像猎豹： <code>Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER</code> 。<br>当然双核浏览器诚然就是墙头草，切换内核时 UserAgent 也需要跟着变化。</p><p>如此的混战格局，这厢的 IE 和 Chome 想必也是醉了。</p><h2 id="九、国共内战"><a href="#九、国共内战" class="headerlink" title="九、国共内战"></a>九、国共内战</h2><p>适者生存是不变的生存法则，国产浏览器们经过一段时间的用户筛选，自然优胜劣汰。时值 2010 年，真正还在运营和更新的浏览器数量慢慢下降，用户集中在几家表现更优异的厂商手中。就在这时，好看的故事来了—— 3Q 大战爆发。</p><p>有人说，腾讯电脑管家的推出是导火索。其实这场仗，大家都忍了好久，推不推出，都一定会在某个事件后爆发。 360 浏览器是奇虎的重量级产品，用户量众多， 2009 年它推出一个功能：过滤其它网站的广告。诚然民众们都很喜欢。可是其他互联网公司肯定就不乐意了，用户看不到更点击不到广告，这钱还怎么赚？</p><p>因而在 3Q 大战爆发后，腾讯的一个手段就是：如果你使用 360 浏览器，就不能访问 QQ 的网站（单单 QQ 空间就有巨大的用户量），也直接反攻 360 的最大收入来源。一个艰难的决定背后，往往是需要无数种的技术战略支撑的。企鹅判断用户是否使用 360 浏览器，依靠的就是 UserAgent 里是否有“360SE”的字样。</p><p>战报传来：号外， 360 浏览器上不了 QQ 空间！已经买了黄钻的杀马特贵族急了呀！只能换浏览器了呀！感覺侢乜卟哙噯嘞呀！<br>2011年11月3日，腾讯网站封杀 360 浏览器<br>2011年11月4日，360 浏览器访问量仅为昨日一半<br>2011年11月5日，360 浏览器访问量几乎为 0</p><p>有人说，腾讯就这么快赢了？恰恰相反，360 浏览器通过一次强制的自动升级，又可以访问 QQ 的网站了。 360 的工程师们在 5 日使用了伪装术——把“360SE”字样从 UserAgent 中去掉！<br>意思就是， 360 浏览器的 UserAgent 跟 IE 完全一样，你根本判断不出来（因而访问量为 0 ）。就怕流氓有文化！企鹅傻眼了，总不能把大微软的 IE 也一并给禁了吧…</p><p>这场土匪遇恶霸的耍流氓大战，最终通过法律而化解。企鹅在技术侧拿 360 没办法，而 360 则得到了一个跟 IE 一样的身份证。在这场内战中，受伤的除了广大网民们，其实还有令人心疼 UserAgent 君，以往让它越长越长就算了，这次长了还得阉割掉，真心 dan 疼呀。</p><h2 id="十、明日边缘"><a href="#十、明日边缘" class="headerlink" title="十、明日边缘"></a>十、明日边缘</h2><p>看到这里，大家会明白一个道理：如果未来不出现一款霸主级别的浏览器（或内核）， UserAgent 应该不会有大变化了。<br>不过，这道理并不全对。别忘了，移动侧也是有浏览器的。<br>在早期能上网的手机里，内置了各手机厂商自研的浏览器。这些浏览器并不需要像 PC一样的复杂设计，可以访问 wap 网页就足够了。因而它们的 UserAgent 命名，怎么简单怎么来，就直接叫 <code>诺基亚 3100 Nokia3100/06.01 (UCWEB 3.3B)</code> ， <code>PHILIPS755 ObigoInternetBrowser/2.0</code> 这样，有甚者连浏览器叫什么都不带 <code>TCL-3199</code> ， <code>三星 E618 SEC-SGHE618</code> 。</p><p>这样任由发展下去，一种要历史重演，往日重现的即视感压迫而来。<br>web 世界的联合国 —— W3C 组织，站在明日边缘，面对着历史和未来，终于发话，它制定 UserAgent 标准，以后都得按这规范去起名字。详细请阅 <a href="https://www.w3.org/TR/UAAG/">User Agent Accessibility Guidelines</a> 。至此，命运坎坷的 UserAgent 终于逐步走向规范。 W3C 大法好，有人说你怎么不早点来拯救世界呀！其实 W3C 一直在努力，但规范的制定，到推广至大家认可并执行，是一条漫长的道路，需要时间，也需要实践。<br>W3C 组织，在制定 web 标准这件工作之外，再我看来，还有两个身份：1、和事佬；2、背黑锅。和事不成，就得背黑锅。是的就是这样。</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>那么，我们的故事接近尾声。还有一些有趣的小彩蛋。</p><ol><li>Chome 28 开始，与苹果正式分道扬镳，采用 Blink 内核，但它的 UserAgent 并不改变。</li><li>淘宝封杀微信打开淘宝页面，靠的就是微信内置浏览器 UserAgent 里的 MicroMessenger 字样。其实微信也可以像当初 360 一样把 UserAgent 去掉，但微信并不这样做。</li><li>360 出招之时留有后招。也许，它一开始就想到了腾讯会告他们对于 UserAgent 的欺瞒，因而它其实提供了设置项。默认设置是“保持跟 IE 一样的 UserAgent ”，但用户也可以不勾选。只是这选项比较隐蔽，而且你重启浏览器后…又会变回默认设置。如果没有这个小小的设置，结果大家可以自行想象。</li><li>微软又玩新花样了，在泄露版 IE11 中，去掉了以往的 MSIE 字样。初步猜测此举是为了使现有的 CSS hack  失效，避免过去网页设计师对 IE 差别对待的情况再度发生。但又会引发其他问题啊亲。</li></ol><p><strong>注：本文转载自 <a href="http://litten.me/">Litten</a> 的文章“浏览器野史 UserAgent 列传 <a href="http://litten.me/2014/09/26/history-of-browser-useragent/">(上)</a> <a href="http://litten.me/2014/10/05/history-of-browser-useragent2/">(下)</a>” ，内容二合一，特此注明！</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。&lt;br&gt;控制台敲下：&lt;code&gt;navigator.userAgent&lt;/code&gt;&lt;br&gt;浏览器回应：&lt;code&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="逸趣杂谈" scheme="https://blog.inkuang.com/categories/%E9%80%B8%E8%B6%A3%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="https://blog.inkuang.com/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="浏览器" scheme="https://blog.inkuang.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="转载" scheme="https://blog.inkuang.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
    <category term="UserAgent" scheme="https://blog.inkuang.com/tags/UserAgent/"/>
    
  </entry>
  
</feed>

[{"title":"N 卡电脑安装 Ubuntu 时卡在安装界面的问题","url":"/2019/310/","content":"前不久给自己的 Win10 笔记本装上 Ubuntu 弄成了双系统，在这里记录一下折腾过程中踩过的一个大坑。\n问题描述在修改 Bios 从U盘启动后，能够顺利进入安装页面，但是整个页面会很快卡住，鼠标、键盘全部失效，完全无法进行任何操作，只能长按电源键来重启。\n\n\n问题排查由于本人所用的镜像是从 Ubuntu 官网下的，经过文件校验后，首先排除掉了系统镜像的问题。\n怀疑所用是U盘的原因，于是换了一个不同品牌的U盘重新刻录安装盘，但经过测试，问题依旧存在。\n在排除了这些自身影响因素后，怀疑这种情况是 Ubuntu 本身的某些问题导致的，于是上网搜查，果然发现了大量我这样情况的案例。经过多方的对比测试，最终发现问题是由于 Ubuntu 内置的 Nvidia 的第三方驱动 nouveau 引起的。\nUbuntu 内置了 nouveau 这一 Nvidia 第三方开源驱动，在安装时如果识别到了 Nvidia 显卡便会自动加载该驱动。而 nouveau 驱动对于桌面用户来说效果实在是惨不忍睹，经常导致一堆奇奇怪怪的问题。我的电脑是 Intel 核显 + Nvidia 独显的双显卡配置，所以自然而然的踩到了这个坑里。\n解决办法既然是这个驱动引起的，我们禁止它的自动加载就可以了，具体的操作如下：\n\n在从U盘启动后刚开始的 GRUB 引导界面将光标移至 Install Ubuntu 选项，然后按下 e 键进入配置编辑界面。\n找到开头是 linux 的那一行（一般来说是倒数第二行），在 quiet splash 后面先空一格再加上 acpi_osi=linux nomodeset\n在 quiet splash 后面有时还会有一些其他字符，我们不用管它，只要保证上面的参数加在 splash 后面就行了。添加完参数后按下 F10 键即可进入正常安装流程。\n\n按上面这样操作完后就可以正常安装 Ubuntu 啦！\n注意： 在系统安装完后由于我们仍然没有安装 Nvidia 的官方驱动，在首次重启时还是可能会卡住。这时需要在 grub 界面把光标移动到 Ubuntu 选项后按下 e 键，然后跟上面一样添加参数即可。在成功进入系统后记得第一时间安装 Nvidia 的官方驱动（可以直接在 Ubuntu 的软件更新里安装）。\n","categories":["技术教程"],"tags":["Linux","Nvidia","系统安装","踩坑"]},{"title":"解决 ibus 输入法系统无法在 Qt5 应用内输入中文的问题","url":"/2019/312/","content":"前面就提到过我给我的电脑装上了 Win10 + Ubuntu 的双系统。由于我最近在自学 Qt，所以在系统装好后我就尝试在 Ubuntu 下配置了 Qt5 的开发环境。\n而这两天在 Ubuntu 下尝试写一些 Qt 应用程序的时候，发现一个奇怪的问题： Qt Creator 内无法输入中文，并且在这种情况下写出来的 Qt 应用内也有同样的现象。\n\n\n经过多次测试复现，发现可以在其他编辑器内写好中文后复制粘贴进去，且粘贴进去的中文不会影响到程序的正常运行，因此可以基本排除当前 Qt 环境本身不支持中文的可能，怀疑是输入法系统的相关问题导致的。\n环境参数下面是我出现此问题的开发环境的一些相关参数：\n\n系统版本：Ubuntu 18.04 LTS\n输入法系统：ibus\n输入法引擎：Rime\nQt版本：5.12.0\nIDE版本：Qt Creator 4.8.1\n\n解决方案在一番搜索查找之后，最终证实这种现象是 ibus 和 Qt5 的一些兼容问题导致的，需要设置一下环境变量才可以正常使用，最终找到的实测有效解决方案如下：\n编辑 /etc/profile 文件，在文件最后面加入\nexport GTK_IM_MODULE&#x3D;ibusexport XMODIFIERS&#x3D;@im&#x3D;ibusexport QT_IM_MODULE&#x3D;ibus\n\n保存后重启一下系统即可。在重启后可以打开 Qt Creator 测试一下，应该是可以正常输入中文的了。\n","categories":["技术教程"],"tags":["踩坑","输入法","Qt5"]},{"title":"Linux 系统下删除无用的旧内核","url":"/2019/317/","content":"Linux 系统在内核更新时大多只会下载安装新的内核，并不会自动删除旧内核。这就导致随着时间的推移，无用的旧内核占用硬盘空间可能会越来越大。\n对于个人电脑或独服来说，这么点占用可能算不得什么，而对于那些乞丐版配置的 VPS，总共就这么几 G 的硬盘空间让旧内核占用掉这么多无疑是十分浪费的，所以就需要我们去手动删除这些旧内核了。\n\n\n下面介绍一下 Linux 系统（主要是 RedHat 和 Debian 系的系统）下删除旧内核的具体操作流程。\n警告：删除内核属高危行为，如非特别需要，请勿随意操作！！！\n查看当前内核我们需要删除的是无用的旧内核，所以在删除操作前需要确定自己当前正在使用的系统内核版本，输入：\nuname -r\n\n这会返回形如 4.15.0-46-generic 这样的的一串字符串，就是你当前系统使用的内核版本。\n查看已安装的内核对于 RedHat/CentOS 系的系统，使用：\nrpm -qa | grep kernel\n\n这会输出系统中安装的所有的内核包，形式如下：\nkernel-3.10.0-327.el7.x86_64kernel-headers-3.10.0-514.6.1.el7.x86_64kernel-tools-libs-3.10.0-327.el7.x86_64kernel-3.10.0-514.16.1.el7.x86_64kernel-tools-3.10.0-327.el7.x86_64\n\n对于 Debian/Ubuntu 系的系统，使用：\ndpkg --list | grep linux-image\n\n输出形式如下（这是我自用系统的输出，没有什么旧内核）：\nii  linux-image-4.15.0-46-generic              4.15.0-46.49                                 amd64        Signed kernel image genericii  linux-image-generic                        4.15.0.46.48                                 amd64        Generic Linux kernel image\n\n删除旧内核上面输出的所有已安装内核中版本号比当前使用版本低的都可以删除（但是一般建议保留一个最近版本的旧内核作为备用选项，以防止当前内核出现问题导致无法启动系统的情况）\n对于确定要删除的内核，使用系统的包管理器即可卸载删除：\n# RedHat&#x2F;CentOS 系的系统使用yum remove kernel-***# Debian&#x2F;Ubuntu 系的系统使用apt purge linux-image-***\n\n非 root 用户操作时需加上 sudo。部分系统在此时可能会弹出警告，询问你是否终止该过程，请看清楚具体内容后再做选择。\n","categories":["技术教程"],"tags":["Linux","卸载"]},{"title":"内核版本 4.9 以上的 Linux 系统开启/关闭 BBR 的方法","url":"/2019/318/","content":"了解计算机网络的人都知道，在 TCP 连接中，为了维持连接的可靠性，引入了拥塞控制和流量管理的方法。\n而 BBR 就是一项由 Google 开源的 TCP 拥塞控制算法，在网络优化、加速等方面都有着极其可观的效果，某种程度上来说也可以算是一大神器了。\n\n\n下面就来介绍一下怎么在 Linux 系统下开启和关闭 BBR 吧。\n内核版本确定从 Linux 4.9 版本开始，TCP BBR 就已经成为了 Linux 系统内核的一部分。因此，开启 BBR 的首要前提就是当前系统内核版本大于等于 4.9。\n查看当前内核版本：\nuname -r\n\n只有返回的值大于等于 4.9 时才可以进行下一步操作，否则需要先手动将内核版本升级至 4.9 以上（这里不再赘述）\n开启 BBR整个开启过程其实很简单，在特定文件中写入几行配置就行了。\n修改系统配置使用 echo 写入配置：\necho &quot;net.core.default_qdisc&#x3D;fq&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.confecho &quot;net.ipv4.tcp_congestion_control&#x3D;bbr&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf\n\n保存生效修改完之后需要保存才能生效：\nsysctl -p\n\n验证开启状态操作完后最好验证一下 BBR 是否正常开启并启动。\n查看内核开启情况sysctl net.ipv4.tcp_available_congestion_control\n\n显示内容如下，包含含“bbr”字样则 BBR 已正常开启\n# sysctl net.ipv4.tcp_available_congestion_controlnet.ipv4.tcp_available_congestion_control &#x3D; bbr cubic reno\n\n查看 BBR 是否启动lsmod | grep bbr\n\n显示如下则已启动成功（后面的数字不一定跟我这里一样）\n# lsmod | grep bbrtcp_bbr                20480  14\n\n关闭 BBR前面开启 BBR 时我们写入了两行配置，关闭 BBR 只需要将这两行配置删掉即可。编辑 /etc/sysctl.conf 文件：\nvim &#x2F;etc&#x2F;sysctl.conf\n\n移动光标至文件最底端（vim 编辑器在普通模式下输入一个 G 即可跳转到文件结尾），将如下两行配置删除（前面开启 BBR 时添加的）：\nnet.core.default_qdisc&#x3D;fqnet.ipv4.tcp_congestion_control&#x3D;bbr\n\n保存文件并退出后我们需要重新加载一下配置：\nsysctl -p\n\n最后再重启一下系统（必须）就会发现 BBR 已经关闭啦！你可以用上面“验证开启状态”步骤中的命令测试一下，已经没有“bbr”字样了。\n","categories":["技术教程"],"tags":["Linux","BBR"]},{"title":"Jupyter Notebook 中添加 conda 虚拟环境","url":"/2019/319/","content":"最近在查深度学习有关的资料时了解到了 Jupyter Notebook 这一交互式 python 编辑器，抱着好奇的心态去试用了一下，结果瞬间就被它吸粉了。\n由于不怎么熟悉，我在刚接触这一工具时也遇到了一些问题，“如何在 Jupyter Notebook 中使用 conda 创建的虚拟环境”就是其中最主要的一点。\n\n\n需求详情我在电脑上安装的 python 发行版是 anaconda，平时使用 conda 来创建和管理 python 虚拟环境。\nanaconda 在主环境（base）里默认安装了 Jupyter，可以直接启动，但是这样的话只能使用主环境里安装的 python 和 python 包。\n那如果需要使用虚拟环境来运行代码该怎么办呢？\n解决办法首先想到的解决办法就是在虚拟环境里也安装一遍 Jupyter ，使用时先在命令行下切到虚拟环境里再去运行。这种方法经测试是可行的，但显然有点过于麻烦了，有没有更方便的办法呢？\n经过查找资料，Jupyter Notebook 是支持在运行时切换 python kernel 的，不过需要对切换的环境做一点配置。\n安装 ipykernel首先切换到想要在 Jupyter Notebook 里使用的虚拟环境：\nconda activate 环境名称\n\n安装 ipykernel：\nconda install ipykernel\n\n写入 Jupyter 的 kernel在当前虚拟环境里执行：\npython -m ipykernel install --user --name 环境名称 --display-name &quot;Python (环境名称)&quot;\n\n“环境名称”为当前虚拟环境的名称，最后面引号内的字符串是该虚拟环境显示在 Jupyter Notebook 界面的名字，可以随意修改。\n切换 kernel上面两步后就完成了 Jupyter 的相关配置，启动 Jupyter Notebook：\njupyter notebook\n\n之后在其打开的浏览器页面里新建文件时就可以看到刚刚添加的虚拟环境的选项了。\n也可以在已经创建的项目的运行界面直接切换内核（Change kernel），如下图：\n\n删除 kernel 环境上面写入 kernel 的配置并不会随虚拟环境的删除而删除。也就是说即使删除了该虚拟环境，Jupyter Notebook 的界面上仍会有它的选项，只是无法正常使用。\n此时就需要去手动删除 kernel 环境了：\njupyter kernelspec remove 环境名称\n","categories":["技术教程"],"tags":["Python","Jupyter","conda"]},{"title":"配置 Jupyter Notebook 允许远程访问","url":"/2019/321/","content":"前面就已经提到过 Jupyter Notebook 这一强大的工具了，今天再来记录一篇跟它的配置有关的教程吧。\n用过 Jupyter Notebook 的人应该都清楚，这个强大的工具其实是一个 web 应用，我们在本地使用时也是通过浏览器访问 http://localhost:8888 来进行操作的。\n\n\n既然是 web 应用，那我能不能把它部署在服务器上来远程访问呢？答案当然是可以的，只需要修改一下配置文件即可！\n生成配置文件新安装的 Jupyter Notebook 是没有附带配置文件的，所以需要先生成：\njupyter notebook --generate-config\n\n此命令会输出生成的配置文件的位置，需记录下来。\n生成密码sha1值开启远程访问的话意味着你的 Jupyter Notebook 服务会暴露在公网中，所以为了安全我们需要设置一下页面密码。\n在 Jupyter 的配置文件中要填写的并不是密码的明文，而是想要设置密码的sha1值。在这里我们使用 ipython 的 passwd 库来生成密码的 sha1 值。\n输入 ipython ，进入 ipython 的交互界面，然后依次输入及其输出如下，按输出说明填写密码：\nIn [1]: from notebook.auth import passwdIn [2]: passwd()Enter password:Verify password:Out[2]: &#39;sha1:ce23d945972f:34769685a7ccd3d08c84a18c63968a41f1140274&#39;\n\n把 out[2] 的内容复制下来备用。\n修改配置文件vim ~&#x2F;.jupyter&#x2F;jupyter_notebook_config.py\n\nvim 后面换成你自己的配置文件路径。\n将如下几项内容去除注释后修改值如下并保存：\n# 服务ip地址，0.0.0.0代表绑定到本机所有的ip上c.NotebookApp.ip&#x3D;&#39;0.0.0.0&#39;# 密码设置，前面的u是表示对单引号内的内容不转义c.NotebookApp.password &#x3D; u&#39;sha:ce...刚才复制的那个out[2]的内容&#39;# 启动时是否打开本地浏览器，我们远程访问的话自然不需要c.NotebookApp.open_browser &#x3D; False# 工作端口c.NotebookApp.port &#x3D;8888 #随便指定一个端口\n\n启动服务在想要工作的目录下输入 jupyter notebook 即可启动服务，但这样的前台服务在 ssh 断开后也会中断。若是想要保持其运行状态的话，可以用 screen 命令将其挂在后台运行。\n# 新建一个 screen 窗口，若报错则可能需先安装 screenscreen -S jupyter# 启动 jupyter notebook 服务jupyter notebook\n\n之后同时按下键盘上的 ctrl+a+d 键即可将当前 screen 窗口挂到后台，这样即使 ssh 连接断开了也不会导致服务中断。\n在服务启动后用浏览器访问 http://你的服务ip地址:你的端口 即可打开 Jupyter Notebook 的密码页面，输入前面设置的密码后就可以跟本地一样正常使用啦。\n","categories":["技术教程"],"tags":["Python","Jupyter","远程访问"]},{"title":"彻底卸载阿里云服务器上的各种监控服务","url":"/2019/331/","content":"用过阿里云服务器（ECS、轻量应用服务器）的人应该都知道，阿里云提供的系统镜像里预装了它的各种监控服务。\n这些监控服务可以让用户直接在控制台查看当前系统的状态，某种程度上来说确实方便了服务器的管理。但是对于我们这种“爱折腾党”来说，很少用到这些服务却还是得一直被这些监控盯着，总有种不爽的感觉。\n\n\n所以在这里介绍一下怎么卸载阿里云服务器上的各种监控服务。\n卸载云盾（安骑士）在官方文档页面只介绍了怎么在控制台去卸载，手动卸载的操作步骤需要提交工单获取，不是很方便。\n在这里介绍一种用脚本手动卸载的方法（其实用的也是官方提供的两个脚本），执行以下命令即可。\nwget http:&#x2F;&#x2F;update.aegis.aliyun.com&#x2F;download&#x2F;uninstall.sh &amp;&amp; chmod +x uninstall.sh &amp;&amp;.&#x2F;uninstall.shwget http:&#x2F;&#x2F;update.aegis.aliyun.com&#x2F;download&#x2F;quartz_uninstall.sh &amp;&amp; chmod +x quartz_uninstall.sh &amp;&amp; .&#x2F;quartz_uninstall.sh\n\n测试发现上面的脚本运行完之后可能还会有一些服务/文件/文件夹残留，所以我们手动清理一下，顺便把刚刚下下来的两个脚本文件也删了（如果提示文件不存在就不用管了）。\nsudo rm -r &#x2F;usr&#x2F;local&#x2F;aegissudo systemctl disable aliyun.servicesudo rm &#x2F;usr&#x2F;sbin&#x2F;aliyun-servicesudo rm &#x2F;usr&#x2F;sbin&#x2F;aliyun-service.backupsudo rm &#x2F;usr&#x2F;sbin&#x2F;aliyun_installersudo rm &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;aliyun.servicesudo rm &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;aliyun.servicerm uninstall.sh quartz_uninstall.sh\n\n卸载云监控（Cloudmonitor）云监控有 Java 版本和 Go 语言版本两种（Java 版本已经不再提供升级了，现在新开的服务器应该都是 Go 语言版本的），可以根据其安装目录 /usr/local/cloudmonitor/ 下的文件名判断你的服务器上装的具体是哪一种。下面分别介绍两个版本的卸载方法。\n卸载云监控 Go 语言版云监控 Go 语言版的可执行文件名为 CmsGoAgent.linux-$&#123;ARCH&#125; ，其中的 ARCH 根据 Linux 架构的不同，分为 amd64 和 386 ，可以在其安装目录 /usr/local/cloudmonitor/ 下找到具体的文件名。\n为了方便表述，下面的命令中也使用 $&#123;ARCH&#125; 替代文件名中的系统架构部分。要能够直接复制下面的命令行去执行的话，可以先设置一下临时环境变量（相当于后面输入命令中的 $&#123;ARCH&#125; 会被自动替换成我们在这里设置的值）\n# 64 位系统export ARCH&#x3D;amd64# 32 位系统export ARCH&#x3D;386\n\n或者的话你也可以在找到具体的文件名后自行替换。下面是卸载相关的一些命令：\n# 从系统服务中移除&#x2F;usr&#x2F;local&#x2F;cloudmonitor&#x2F;CmsGoAgent.linux-$&#123;ARCH&#125; uninstall# 停止&#x2F;usr&#x2F;local&#x2F;cloudmonitor&#x2F;CmsGoAgent.linux-$&#123;ARCH&#125; stop# 卸载&#x2F;usr&#x2F;local&#x2F;cloudmonitor&#x2F;CmsGoAgent.linux-$&#123;ARCH&#125; stop &amp;&amp; \\&#x2F;usr&#x2F;local&#x2F;cloudmonitor&#x2F;CmsGoAgent.linux-$&#123;ARCH&#125; uninstall &amp;&amp; \\rm -rf &#x2F;usr&#x2F;local&#x2F;cloudmonitor\n\n附上官方文档页面链接：https://help.aliyun.com/document_detail/97929.html\n卸载云监控 Java 版# 停止&#x2F;usr&#x2F;local&#x2F;cloudmonitor&#x2F;wrapper&#x2F;bin&#x2F;cloudmonitor.sh stop# 卸载&#x2F;usr&#x2F;local&#x2F;cloudmonitor&#x2F;wrapper&#x2F;bin&#x2F;cloudmonitor.sh remove &amp;&amp; \\rm -rf &#x2F;usr&#x2F;local&#x2F;cloudmonitor\n\n附上官方文档页面链接：https://help.aliyun.com/knowledge_detail/38859.html\n","categories":["技术教程"],"tags":["卸载","阿里云","服务器"]},{"title":"Transmission 2.94 配置文件参数中文解释","url":"/2019/403/","content":"最近得到消息有个新开的 pt 站正在开放注册，于是赶紧去注册了个账号正式入坑 pt。\n而玩 pt，无论是做种还是挂种都离不开 Bittorrent 客户端的支持。我是在自己的空闲服务器上挂的，选用了比较有名的 Transmission 作为客户端。\n\n\nTransmission 目前最新的版本为 2.94 ，下面介绍一下它的配置文件中各个参数的作用吧。\n配置文件参数下面的参数项是直接从 Transmission 2.94 版本的默认配置文件里复制过来的，各个参数作用的解释基本是我根据官方说明翻译归纳的，应该没有啥大问题（注意 JSON 文件不能有注释，我这里使用 // 的注释形式只是为了方便对照查看 ，请勿将其粘贴到实际使用的配置文件中）。\n先附上官方说明地址：https://github.com/transmission/transmission/wiki/Editing-Configuration-Files\n&#123;    &quot;alt-speed-down&quot;: 50,   //开启时段限速时下载速度的最大值，单位KB/s    &quot;alt-speed-enabled&quot;: false,   //是否开启时段限速，默认关闭    &quot;alt-speed-time-begin&quot;: 540,   //时段限速开启时间，默认值540（这个值与具体时间的转换自己去官方说明里查看，此处不过多介绍，下同）    &quot;alt-speed-time-day&quot;: 127,   //时段限速在哪些日子启用，默认值127（每天）    &quot;alt-speed-time-enabled&quot;: false,   //是否启用时段限速日期，默认不开启，如果开启，那么alt-speed-enabled一定要是false，两者之间只能启用一项，如果同时设置为true，则alt-speed-enabled有效    &quot;alt-speed-time-end&quot;: 1020,   //时段限速结束时间，默认值1020    &quot;alt-speed-up&quot;: 50,   //开启时段限速时上传速度的最大值，单位KB/s    &quot;bind-address-ipv4&quot;: &quot;0.0.0.0&quot;,   //程序监听的ipv4地址绑定    &quot;bind-address-ipv6&quot;: &quot;::&quot;,   //程序监听的ipv6地址绑定    &quot;blocklist-enabled&quot;: false,   //是否启用黑名单，默认不启用    &quot;blocklist-url&quot;: &quot;http://www.example.com/blocklist&quot;,   //黑名单列表的url    &quot;cache-size-mb&quot;: 4,   //缓存大小，单位MB    &quot;dht-enabled&quot;: true,   //是否启用DHT网络（通过tracker寻找节点），默认启用    &quot;download-dir&quot;: &quot;/var/lib/transmission-daemon/downloads&quot;,   //下载完成的文件保存路径    &quot;download-limit&quot;: 100,   //下载限速，单位KB/s    &quot;download-limit-enabled&quot;: 0,   //是否开启下载限速，0表示不开启    &quot;download-queue-enabled&quot;: true,   //是否开启下载队列，默认开启    &quot;download-queue-size&quot;: 5,   //下载队列数设置，默认5，表示最多只能同时下载5个任务，多余的需要等待    &quot;encryption&quot;: 1,   //加密设置，等于0时不加密，1是优先加密，2是必须加密    &quot;idle-seeding-limit&quot;: 30,   //空闲多长时间停止做种，默认30，单位分钟    &quot;idle-seeding-limit-enabled&quot;: false,   //是否开启空闲时间停止做种，默认关闭    &quot;incomplete-dir&quot;: &quot;/var/lib/transmission-daemon/Downloads&quot;,   //未完成任务的文件保存路径    &quot;incomplete-dir-enabled&quot;: false,   //是否启用未下载完成文件保存路径    &quot;lpd-enabled&quot;: false,   //LDP网络（在本地网络寻找节点），默认关闭    &quot;max-peers-global&quot;: 200,    &quot;message-level&quot;: 1,   //日志消息等级，0=None，1=Error,2=Info,3=Debug    &quot;peer-congestion-algorithm&quot;: &quot;&quot;,    &quot;peer-id-ttl-hours&quot;: 6,    &quot;peer-limit-global&quot;: 200,   //全局种子最大连接数    &quot;peer-limit-per-torrent&quot;: 50,   //每个种子的最大连接数    &quot;peer-port&quot;: 51413,   //上传下载使用的连接端口号    &quot;peer-port-random-high&quot;: 65535,   //随机端口号上限    &quot;peer-port-random-low&quot;: 49152,   //随机端口号下限    &quot;peer-port-random-on-start&quot;: false,   //是否启用随机端口号，默认关闭，启用后每次重启该软件都会从上面设定的范围里随机选取一个端口使用    &quot;peer-socket-tos&quot;: &quot;default&quot;,   //设置传输TCP数据包的服务类型，详情参考：https://en.wikipedia.org/wiki/Type_of_service    &quot;pex-enabled&quot;: true,   //是否开启节点交换，详情参考：https://en.wikipedia.org/wiki/Peer_exchange    &quot;port-forwarding-enabled&quot;: false,   //是否启用端口转发（uPnP），如果路由支持并且也开启了uPnP，则路由会自动做端口映射    &quot;preallocation&quot;: 1,   //预分配磁盘空间，0=关闭，1=快速，2=完全，默认取1，防止文件下载了一半后才发现磁盘空间不够    &quot;prefetch-enabled&quot;: true,    &quot;queue-stalled-enabled&quot;: true,    &quot;queue-stalled-minutes&quot;: 30,    &quot;ratio-limit&quot;: 2,   //分享率（上传下载比率）达到多少后停止做种    &quot;ratio-limit-enabled&quot;: false,   //是否启用分享率达标停止做种，默认关闭    &quot;rename-partial-files&quot;: true,   //在未完成的文件名后添加后缀，默认开启，开启后未完成的文件会带有.part后缀    &quot;rpc-authentication-required&quot;: true,   //是否开启远程控制验证    &quot;rpc-bind-address&quot;: &quot;0.0.0.0&quot;,   //rpc服务监听地址    &quot;rpc-enabled&quot;: true,   //是否开启rpc服务（远程连接）    &quot;rpc-host-whitelist&quot;: &quot;&quot;,   //rpc域名白名单，值为以逗号分隔的域名列表，用于绑定域名访问的场景    &quot;rpc-host-whitelist-enabled&quot;: true,   //是否开启rpc域名白名单    &quot;rpc-password&quot;: &quot;&#123;cc29d57debb27f83469bbcd7fae81f64c789d3dfgw.f80LY&quot;,   //rpc连接密码，这是加密过的，将其修改为自己的密码（明文）后启动软件会自动加密    &quot;rpc-port&quot;: 9091,   //rpc服务监听端口    &quot;rpc-url&quot;: &quot;/transmission/&quot;,   //rpc服务路径    &quot;rpc-username&quot;: &quot;transmission&quot;,   //rpc连接用户名，跟上面的密码配合使用    &quot;rpc-whitelist&quot;: &quot;127.0.0.1&quot;,   //rpc连接白名单，默认只允许本地连接    &quot;rpc-whitelist-enabled&quot;: true,   //是否开启rpc连接白名单，默认开启    &quot;scrape-paused-torrents-enabled&quot;: true,   //是否运行暂停种子    &quot;script-torrent-done-enabled&quot;: false,   //是否在torrent完成时运行脚本，默认关闭    &quot;script-torrent-done-filename&quot;: &quot;&quot;,   //在torrent完成时运行的脚本路径    &quot;seed-queue-enabled&quot;: false,   //是否开启做种队列    &quot;seed-queue-size&quot;: 10,   //做种队列大小    &quot;speed-limit-down&quot;: 100,   //下载速度限制，单位KB/s    &quot;speed-limit-down-enabled&quot;: false,   //是否开启下载速度限制，默认关闭    &quot;speed-limit-up&quot;: 100,   //上传速度限制，单位KB/s    &quot;speed-limit-up-enabled&quot;: false,   //是否开其上传速度限制，默认关闭    &quot;start-added-torrents&quot;: true,   //在添加种子文件后立即开始任务    &quot;trash-original-torrent-files&quot;: false,    &quot;umask&quot;: 18,   //文件权限掩码，默认18即755权限，如果改成0是最高权限，下载回来的文件权限就是777    &quot;upload-limit&quot;: 100,     &quot;upload-limit-enabled&quot;: 0,    &quot;upload-slots-per-torrent&quot;: 14,    &quot;utp-enabled&quot;: true   //UTP传输是否启用&#125;\n\n注意事项修改配置文件时还需要注意以下几点：\n\n在 Linux 系统下，修改 download-dir 和 incomplete-dir 选项时需要注意目录权限问题，使用 apt 安装 Transmission 时会自动创建一个名为 debian-transmission 的用户，你设置的目录需要让该用户有可写权限。\nDHT 网络可能会造成 tracker 服务器记录数据出错而被认为作弊，一般的 pt 站都会建议关闭这一选项。\n在启用 rpc 后大部分配置项可以远程在线修改，建议配置文件中不了解作用的选项不要随意改动，想尝试其作用的话可以通过 rpc 远程连接来临时修改。\n\n另外，在上面贴出的配置文件中有一些参数是历史遗留选项，已有新的参数替代了它们的功能，只是旧参数在配置文件中还未删去而已。这也就意味着有部分参数的功能是相同的，在启用时需要注意甄别，详情可以在官方说明页面查看。\n","categories":["技术教程"],"tags":["Transmission","配置文件"]},{"title":"MySQL 常用命令记录","url":"/2019/414/","content":"折腾一些东西的时候经常会用到 MySQL ，但自己对数据库这方面不是很熟，也没有系统的去学过，每次要干啥的时候都要去查资料，十分的麻烦。\n所以在这里记录一些 MySQL 常用的语句以便自己查阅（copy）。\n\n\n登录与退出以 root 用户登录（会要求你输入密码）：\nmysql -u root -p\n\n退出当前用户：\nexit;\n\n添加新用户添加只允许本地访问的用户 testuser ，密码设为 testpassword ：\ncreate user &#x27;testuser&#x27;@&#x27;localhost&#x27; identified by &#x27;testpassword&#x27;;\n\n允许外网 IP 访问（MySQL 需允许外网访问）的用户 testuser2 ，密码设为 testpassword2 ：\ncreate user &#x27;testuser2&#x27;@&#x27;%&#x27; identified by &#x27;testpassword2&#x27;;\n\n新建数据库新建 UTF-8 编码的数据库 testdb ：\ncreate database testdb default character set utf8 collate utf8_general_ci;\n\n新建 utf8mb4 编码的数据库 testdb2 ：\ncreate database testdb2 default character set utf8mb4 collate utf8mb4_unicode_ci;\n\n分配数据库权限授予本地用户 testuser 对数据库 testdb 的所有权限：\ngrant all privileges on testdb.* to &#x27;testuser&#x27;@&#x27;localhost&#x27; identified by &#x27;testpassword&#x27;;\n\n给允许外网 IP 访问的用户授权也是类似操作。\n刷新权限MySQL 新设置用户或更改密码后都需要刷新 MySQL 的系统权限相关表，否则会出现拒绝访问：\nflush privileges;\n\n数据备份使用 testuser 用户备份 testdb 数据库下的 person 表至 /root/backup 目录：\nmysqldump -u testuser -p testdb person &gt; &#x2F;root&#x2F;backup&#x2F;test_person.sql\n\n使用 testuser 用户备份整个 testdb 数据库至 /root/backup 目录：\nmysqldump -u testuser -p testdb &gt; &#x2F;root&#x2F;backup&#x2F;test.sql\n\n使用 testuser 用户备份多个数据库至 /root/backup 目录：\nmysqldump -u testuser -p --databases testdb1 testdb2 &gt; &#x2F;root&#x2F;backup&#x2F;twotestdb.sql\n\n备份 testuser 用户下的所有数据库至 /root/backup 目录：\nmysqldump -u testuser -p --all-databases &gt; &#x2F;root&#x2F;backup&#x2F;alldb.sql\n\n数据还原为了方便描述，这里使用上面数据备份部分使用的数据库用户 、数据库名 、备份文件 做示例。\n对于数据库下表的备份需先建立空数据库再导入（假设已建立了新数据库 testdb ）\nmysql -u testuser -p testdb &lt; &#x2F;root&#x2F;backup&#x2F;test_person.sql\n\n对于整个数据库/多个数据库/所有数据库的备份直接用相应用户导入即可：\nmysql -u testuser -p &lt; &#x2F;root&#x2F;backup&#x2F;backup.sql\n\n查看数据库大小登录后复制以下代码并使用即可分别显示出当前用户下所有数据库的占用大小（以MB为单位显示）：\nselect table_schema as &#x27;数据库&#x27;,sum(table_rows) as &#x27;记录数&#x27;,sum(truncate(data_length/1024/1024, 2)) as &#x27;数据容量(MB)&#x27;,sum(truncate(index_length/1024/1024, 2)) as &#x27;索引容量(MB)&#x27;from information_schema.tablesgroup by table_schemaorder by sum(data_length) desc, sum(index_length) desc;\n\n显示效果如下图：\n\n注：持续更新中……\n","categories":["学习笔记"],"tags":["MySQL","常用命令"]},{"title":"root 用户删除的文件时显示：Operation not permitted","url":"/2019/429/","content":"最近在折腾服务器时遇到了一件怪事，如下图：\n\n在使用 root 用户的情况下竟然还有无法删除的文件！\n\n\n这着实有点超出我的认知，root 用户不是拥有最高的权限吗？连他都无法删除的文件到底是何方神圣呢？\n问题原因所幸，在经过一番查找资料，还是很快的发现了罪魁祸首：这个文件被使用 chattr 命令锁定了（第一次知道这个命令）。\n不同于 chmod 命令改变文件的读写、执行权限，chattr 控制的是一些更底层的属性，依靠内核来直接实现。\n可以使用 lsattr 命令来查看 chattr 给文件设置的属性： \nlsattr 70-persistent-net.rules\n\n如下图所示，我们之所以无法删除上面的那个文件就是因为它包含了一个 i 属性，从而不允许被修改和删除。\n\n解决方案既然是由于这个 i 属性导致的文件无法删除，那我们将这一属性去除就可以了：\nchattr -i 70-persistent-net.rulesrm 70-persistent-net.rules\n\n\n可以看到，在移除了该文件的 i 属性后就可以正常删除它了。\n顺便记录了一下 chattr 和 lsattr 命令的详细用法，有需要的话可以看看：Linux 的 chattr 与 lsattr 命令详解 。\n","categories":["技术教程"],"tags":["Linux","踩坑"]},{"title":"Linux 的 chattr 与 lsattr 命令详解","url":"/2019/430/","content":"在前面的文章 root 用户删除的文件时显示：Operation not permitted 中提到了 chattr 和 lsattr 两个命令。\n这两个命令是用来查看和改变文件、目录属性的，与 chmod 这个命令相比，chmod 只是改变文件的读写、执行权限，而更底层的属性控制是由 chattr 来改变的。\n\n\n这次踩坑也是我第一次接触这两个命令，所以查了些资料整理了一下它们的用法，在这里记录一下吧。\nlsattr 命令这个命令就是很纯粹的用来查看文件/目录属性的，一般使用时可不加任何参数，直接接文件路径即可查看其属性，当然也有一些可选的参数。\nlsattr [-RVadlpv] [files...]\n\n具体参数的含义如下： \n-R ：递归列出目录及其内容的属性。-V ：显示程序版本。-a ：列出目录中的所有文件，包括以“.”开头的文件。-d ：列出与其他文件类似的目录，而不是列出其内容。-l ：使用长名称而不是单个字符缩写打印选项。-p ：列出文件的项目编号。-v ：列出文件的版本号。\n\nchattr 命令这个命令被用来修改文件/目录的属性，比较常用的就是前面提到的 i 属性：\nchattr [ -RVf ] [ -v version ] [ -p project ] [ mode ] files...\n\n其中最关键的是 [mode] 部分，这部分是由 -+=aAcCdDeijPsStTu 这些字符组合形成的，是实际控制文件属性的参数。每个字符的具体含义如下：\n- ：在原有参数设定基础上，移除参数。+ ：在原有参数设定基础上，追加参数。&#x3D; ：更新为指定参数设定。a ：append only，设定该参数后，只能向文件中添加数据，而不能删除。A ：no atime updates，atime (access time)不可被修改(modified)。c ：compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。C ：no copy on writed ：no dump，设定文件不能成为dump程序的备份目标。D ：synchronous  directory  updates，同步目录更新e ：extent formati ：immutable，设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。j ：journal，设定此参数使得通过mount参数：data&#x3D;ordered 或者 data&#x3D;writeback 挂载的文件系统中，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data&#x3D;journal，则该参数自动失效。P ：project hierarchys ：secure deletion，保密性地删除文件或目录，即硬盘空间被全部收回。S ：synchronous updates，硬盘I&#x2F;O同步选项，功能类似sync。t ：no tail-mergingT ：top of directory hierarchyu ：undeletable，与s相反，当设定为u时，数据内容其实还存在磁盘中。\n","categories":["学习笔记"],"tags":["Linux","常用命令"]},{"title":"Debian9 下为 vim 启用鼠标复制粘贴","url":"/2019/504/","content":"最近发现在 Debian9 系统下使用 apt 安装的 vim 是没办法正常使用鼠标左右键来复制粘贴的。\n具体表现为：在使用 vim 编辑文件时按下鼠标右键后会进入如下图所示的“可视化（VISUAL）模式”，而不是正常的“弹出鼠标右键菜单”。\n\n\n\n解决方案经过查找资料后发现原来这是因为在 Debian9 下 vim8.0 的默认配置中有一项 set mouse=a 开启了所有模式的 mouse 支持导致的（ vim 的鼠标模式是个很神奇的东西，有兴趣的可以去了解一下，这里主要解决复制粘贴问题，不再过多赘述）。\n找到了问题所在后要解决就很简单了，手动添加鼠标配置项覆盖它的默认设置即可。我们这里是通过去除默认设置的鼠标模式“a”来实现的，你也可以尝试将鼠标模式设置为其他项。\n编辑 vim 配置文件（文件不存在时新建一个就行）：\nvim &#x2F;etc&#x2F;vim&#x2F;vimrc.local\n\n这里编辑的是 vim 的自定义全局配置文件，单独修改用户个人的 vim 配置文件（~/.vimrc）也可以。\n然后在文件中添加如下配置项（注意 source 这一行的功能是加载默认配置，不同系统的文件路径可能不同，比如 Debian10 是 .../vim81/defaults.vim，一定要先确定该文件路径存在再写入，否则可能会导致 vim 无法正常使用）：\nsource &#x2F;usr&#x2F;share&#x2F;vim&#x2F;vim80&#x2F;defaults.vimlet skip_defaults_vim &#x3D; 1if has(&#39;mouse&#39;)    set mouse-&#x3D;aendif\n\n保存文件并退出后，再次使用 vim 时就会发现能够正常的使用鼠标右键来进行复制粘贴操作啦！\n","categories":["技术教程"],"tags":["配置文件","vim"]},{"title":"LaTeX 数学符号语法速查表","url":"/2019/511/","content":"最近写一些报告的时候经常需要使用 LaTeX 语法输入数学公式，每次用的时候都去网上搜资料实在是太麻烦了，所以花了点时间整理了一些常用 LaTeX 数学符号的语法供自己查阅。\nPS：本文中所有的符号都是我手动敲进去的，如发现错误请联系我做出修改。\n\n\n加减乘除\n\n\n符号\n$+$\n$-$\n$\\times$\n$\\div$\n\n\n\n语法\n+\n-\n\\times\n\\div\n\n\n幂运算\n\n\n符号\n$a^x$\n$a^{xyz}$\n$\\sqrt{x}$\n$\\sqrt[n]{x}$\n\n\n\n语法\na^x\na^{xyz}\n\\sqrt{x}\n\\sqrt[n]{x}\n\n\n逻辑运算\n\n\n符号\n$\\oplus$\n$\\vee$\n$\\wedge$\n\n\n\n语法\n\\oplus\n\\vee\n\\wedge\n\n\n关系运算\n\n\n符号\n$=$\n$\\not=$\n$\\approx$\n$&gt;$\n$&lt;$\n\n\n\n语法\n=\n\\not=\n\\approx\n&gt;\n&lt;\n\n\n\n\n\n符号\n$\\equiv$\n$\\le$\n$\\ge$\n$\\ll$\n$\\gg$\n\n\n\n语法\n\\equiv\n\\le\n\\ge\n\\ll\n\\gg\n\n\n集合\n\n\n符号\n$\\in$\n$\\ni$\n$\\subset$\n$\\supset$\n$\\subseteq$\n$\\supseteq$\n\n\n\n语法\n\\in\n\\ni\n\\subset\n\\supset\n\\subseteq\n\\supseteq\n\n\n存在\n\n\n符号\n$\\exists$\n$\\forall$\n\n\n\n语法\n\\exists\n\\forall\n\n\n希腊字母要输入希腊字母只要用反斜杠 \\  加上相应字母的拼写即可。大写字母将对应拼写的首字母大写即可，这里仅列出一部分作为参考。\n\n\n\n符号（小写）\n$\\phi$\n$\\omega$\n$\\delta$\n$\\gamma$\n\n\n\n语法\n\\phi\n\\omega\n\\delta\n\\gamma\n\n\n符号（大写）\n$\\Phi$\n$\\Omega$\n$\\Delta$\n$\\Gamma$\n\n\n语法\n\\Phi\n\\Omega\n\\Delta\n\\Gamma\n\n\n箭头\n\n\n符号\n$\\gets$\n$\\to$\n$\\Leftarrow$\n$\\Rightarrow$\n$\\Leftrightarrow$\n\n\n\n语法\n\\gets\n\\to\n\\Leftarrow\n\\Rightarrow\n\\Leftrightarrow\n\n\n省略号\n\n\n符号\n$\\dots$\n$\\cdots$\n$\\vdots$\n$\\ddots$\n\n\n\n语法\n\\dots\n\\cdots\n\\vdots\n\\ddots\n\n\n头顶符号\n\n\n符号\n$\\hat{x}$\n$\\bar{x}$\n$\\vec{x}$\n$\\dot{x}$\n$\\ddot{x}$\n\n\n\n语法\n\\hat{x}\n\\bar{x}\n\\vec{x}\n\\dot{x}\n\\ddot{x}\n\n\n标准括号\n\n\n符号\n$($\n$)$\n$[$\n$]$\n\n\n\n语法\n(\n)\n[\n]\n\n\n取整括号（函数）\n\n\n符号\n$\\lfloor$\n$\\rfloor$\n$\\lceil$\n$\\rceil$\n\n\n\n语法\n\\lfloor\n\\rfloor\n\\lceil\n\\rceil\n\n\n空格LaTex 默认会忽略掉空格，要显示空格的话需要自己用命令输入（mu是一个数学单位）。\n\n\n\n效果\n说明\n语法\n\n\n\n$a \\quad b$\n空格宽度是当前字宽(18mu)\n\\quad\n\n\n$a , b$\n空格宽度是3mu\n,\n\n\n$a : b$\n空格宽度是4mu\n:\n\n\n$a ; b$\n空格宽度是5mu\n;\n\n\n$a \\! b$\n空格宽度是-3mu(向左缩)\n\\!\n\n\n$a \\  b$\n空格宽度是标准空格键效果\n在 \\ 后面敲一个空格\n\n\n$a \\qquad b$\n空格宽度是36mu\n\\qquad\n\n\n上标与下标使用 ^ 和 _ 来表示上下标，使用 &#123;&#125; 来限定上下标的所属关系，下面是一些使用示例。\n\n\n\n符号\n$x^i$\n$a_i$\n$x^{a_i}$\n$x^a_i$\n$x^{a^i}$\n$x_{i+1}$\n\n\n\n语法\nx^i\na_i\nx^{a_i}\nx^a_i\nx^{a^i}\nx_{i+1}\n\n\n上划线下划线\n\n\n符号\n$\\overline{a+bi}$\n$\\underline{xyz}$\n\n\n\n语法\n\\overline{a+bi}\n\\underline{xyz}\n\n\n分式分式有两种尺寸表示，分别用 frac 和 dfrac 关键字表示\n\n\n\n尺寸\n较小\n较小\n适中\n适中\n\n\n\n符号\n$\\frac{1}{2}$\n$\\frac{1+\\frac{1}{x}}{3x + 2}$\n$\\dfrac{1}{2}$\n$\\dfrac{1+\\frac{1}{x}}{3x + 2}$\n\n\n语法\n\\frac{1}{2}\n\\frac{1+\\frac{1}{x}}{3x + 2}\n\\dfrac{1}{2}\n\\dfrac{1+\\frac{1}{x}}{3x + 2}\n\n\n连续嵌套使用时用：\\cfrac\n\n\n\n符号显示\n语法\n\n\n\n$\\cfrac{1+\\cfrac{2}{1+\\cfrac{2}{1+\\cfrac{2}{1}}}}{2}$\n\\cfrac{1+\\cfrac{2}{1+\\cfrac{2}{1+\\cfrac{2}{1}}}}{2}\n\n\n根式\n\n\n符号\n$\\sqrt{x+y}$\n$\\sqrt{x}$\n$\\sqrt[n]{x}$\n\n\n\n语法\n\\sqrt{x+y}\n\\sqrt{x}\n\\sqrt[n]{x}\n\n\n三角函数直接反斜杠 \\ 加正常书写的符号即可，这里只列举几个。\n\n\n\n符号\n$\\cos$\n$\\sin$\n$\\arccos$\n\n\n\n语法\n\\cos\n\\sin\n\\arccos\n\n\n\n\n\n符号\n语法\n\n\n\n$\\cos^2 x +\\sin^2 x = 1$\n\\cos^2 x +\\sin^2 x = 1\n\n\n$\\cos 90^\\circ = 0$\n\\cos 90^\\circ = 0\n\n\n求和 求积 求极限\n\n\n符号\n$\\sum$\n$\\prod$\n$\\lim$\n\n\n\n语法\n\\sum\n\\prod\n\\lim\n\n\n\n\n\n符号\n$\\sum_{i=1}^{\\infty}\\frac{1}{i}$\n$\\prod_{n=1}^5\\frac{n}{n-1}$\n$\\lim_{x\\to\\infty}\\frac{1}{x}$\n\n\n\n语法\n\\sum_{i=1}^{\\infty}\\frac{1}{i}\n\\prod_{n=1}^5\\frac{n}{n-1}\n\\lim_{x\\to\\infty}\\frac{1}{x}\n\n\n求积分 偏导\n\n\n符号\n$\\int$\n$\\oint$\n$\\partial^2y$\n\n\n\n语法\n\\int\n\\oint\n\\partial^2y\n\n\n\n\n\n符号\n语法\n\n\n\n$\\frac{d}{dx}\\left(x^2\\right) = 2x$\n\\frac{d}{dx}\\left(x^2\\right) = 2x\n\n\n$\\int 2x,dx = x^2+C$\n\\int 2x,dx = x^2+C\n\n\n$\\frac{\\partial^2U}{\\partial x^2} + \\frac{\\partial^2U}{\\partial y^2}$\n\\frac{\\partial^2U}{\\partial x^2} + \\frac{\\partial^2U}{\\partial y^2}\n\n\n绝对值直接插入竖线 | 即可，可使用 \\left 、 \\right 标签来指定竖线的垂直长度与那对应字符块匹配\n直接插入竖线： |a^x|指定垂直长度相匹配： \\left|a\\right|^\\left|x\\right|\n\n直接插入竖线： $|a^x|$指定垂直长度相匹配： $\\left|a\\right|^\\left|x\\right|$\n注：所有成对出现的符号均可以像上面那样使用 \\left 、 \\right 标签来指定其大小匹配的字符块。\n矩阵和行列式所有的矩阵都是使用 \\begin&#123;matrix&#125; 开始， \\end&#123;matrix&#125; 结束。其中的 matrix 还可以改为 pmatrix 、 bmatrix 、 Bmatrix 、 vmatrix 、 Vmatrix 。\n在每一行中使用 &amp; 分隔元素，行末用双反斜杠 \\\\ 表示换行（注意在 Markdown 中反斜杠 \\ 表示转义，没有针对该情况进行优化的解析器可能需要输入四个反斜杠 \\\\\\\\ 才能换行）。\n基础格式对于下面的公式，修改大括号内的关键字分别为 matrix 、 pmatrix 、 bmatrix 、 Bmatrix 、 vmatrix 、 Vmatrix 时对应的情况如下所示。\n\\begin&#123;matrix&#125;A &amp; B &amp; C\\\\D &amp; E &amp; F\\\\G &amp; H &amp; I\\\\\\end&#123;matrix&#125;\n\nmatrix$$\\begin{matrix}A &amp; B &amp; C\\\\D &amp; E &amp; F\\\\G &amp; H &amp; I\\\\\\end{matrix}$$\npmatrix$$\\begin{pmatrix}A &amp; B &amp; C\\\\D &amp; E &amp; F\\\\G &amp; H &amp; I\\\\\\end{pmatrix}$$\nbmatrix$$\\begin{bmatrix}A &amp; B &amp; C\\\\D &amp; E &amp; F\\\\G &amp; H &amp; I\\\\\\end{bmatrix}$$\nBmatrix$$\\begin{Bmatrix}A &amp; B &amp; C\\\\D &amp; E &amp; F\\\\G &amp; H &amp; I\\\\\\end{Bmatrix}$$\nvmatrix$$\\begin{vmatrix}A &amp; B &amp; C\\\\D &amp; E &amp; F\\\\G &amp; H &amp; I\\\\\\end{vmatrix}$$\nVmatrix$$\\begin{Vmatrix}A &amp; B &amp; C\\\\D &amp; E &amp; F\\\\G &amp; H &amp; I\\\\\\end{Vmatrix}$$\n带省略号的矩阵这里使用 bmatrix 做示范，其他的类似。\n如上面“省略号”所在小节所示，时使用 \\cdots 表示水平方向省略号， \\vdots 表示竖直方向省略号， \\ddots 表示对角线方向省略号（我这里为了美观把公式按 &amp; 对齐了，这并不是必需的）。\n$$\\begin{bmatrix}A      &amp;  B     &amp; \\cdots &amp;  C    \\\\D      &amp;  E     &amp; \\cdots &amp;  F    \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\G      &amp;  H     &amp; \\cdots &amp;  I    \\\\\\end{bmatrix}$$\n\\begin&#123;bmatrix&#125;A      &amp;  B     &amp; \\cdots &amp;  C     \\\\D      &amp;  E     &amp; \\cdots &amp;  F     \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\G      &amp;  H     &amp; \\cdots &amp;  I     \\\\\\end&#123;bmatrix&#125;\n\n矩阵方程（函数）使用 \\begin&#123;equation&#125; 作为整个公式块的开始，以 \\end&#123;equation&#125; 结束。在里面再配合其他符号的语法使用即可。\n一个简单的例子如下（这里使用 bmatrix 做示范，其他的类似）。\n$$\\begin{equation}H_x=\\frac{1}{3}\\times{\\begin{bmatrix}A      &amp;  B     &amp; \\cdots &amp;  C    \\\\D      &amp;  E     &amp; \\cdots &amp;  F    \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\G      &amp;  H     &amp; \\cdots &amp;  I    \\\\\\end{bmatrix}}\\end{equation}$$\n\\begin&#123;equation&#125;H_x&#x3D;\\frac&#123;1&#125;&#123;3&#125;\\times&#123;\\begin&#123;bmatrix&#125;A      &amp;  B     &amp; \\cdots &amp;  C    \\\\D      &amp;  E     &amp; \\cdots &amp;  F    \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\G      &amp;  H     &amp; \\cdots &amp;  I    \\\\\\end&#123;bmatrix&#125;&#125;\\end&#123;equation&#125;\n\n其他符号\n\n\n符号\n$\\infty$\n$\\triangle$\n$\\angle$\n$\\checkmark$\n$\\nabla$\n\n\n\n语法\n\\infty\n\\triangle\n\\angle\n\\checkmark\n\\nabla\n\n\n","categories":["学习笔记"],"tags":["LaTeX","数学"]},{"title":"Linux 系统添加和删除 Swap 交换文件","url":"/2019/517/","content":"简介Linux 系统中的 Swap 分区，即交换分区，类似于 Windows 的虚拟内存，其作用可简单的描述为：当系统的物理内存不够用的时候，将暂时不用的数据存放到交换空间所在的硬盘上，从而可以腾出内存来让别的程序运行。\n\n\n在这里不讨论直接划出一部分硬盘作为交换分区的情况，只介绍通过添加 Swap 文件来设置交换分区的方式。\n添加 Swap 文件随便进入一个目录用于后续存放 Swap 文件，也可以直接放在根目录，这里放在 /var 目录下。\ncd &#x2F;var\n\n使用 dd 命令生成一个文件块，大小为自己想设置的 Swap 分区大小，这里生成一个名为 swapfile 的文件，大小设为 1G。\ndd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;swapfile bs&#x3D;1M count&#x3D;1024\n\n将该文件设为 Swap 文件（格式化）。\nmkswap swapfile\n\n激活 Swap 文件（启用虚拟内存）。\nswapon swapfile\n\n检查 Swap 是否正确。\nswapon -s\n\n另外为了安全建议将交换分区文件权限设为 0600 或 0644 ，执行以下命令。\nchmod 0600 swapfile\n\n此时已经成功添加了交换分区，可以使用 free 之类的命令查看验证。但这样重启后 Swap 分区会丢失，需要重新激活才行，所以我们一般在 fstab 文件为其添加开机自动挂载设置。\nvi &#x2F;etc&#x2F;fstab\n\n在最后增加以下内容：\n&#x2F;var&#x2F;swapfile swap swap defaults 0 0\n\n也可以直接执行如下命令来添加：\necho &quot;&#x2F;var&#x2F;swapfile swap swap defaults 0 0&quot; &gt;&gt; &#x2F;etc&#x2F;fstab\n\n删除 Swap 文件这里以我们上面设置的 Swap 文件（文件名、文件路径）作为示范。首先将 Swap 文件取消激活：\nswapoff &#x2F;var&#x2F;swapfile\n\n然后删除我们设置的 Swap 文件：\nrm &#x2F;var&#x2F;swapfile\n\n最后再编辑 /fstab 文件删除掉自动挂载 Swap 的设置即可：\nvi &#x2F;etc&#x2F;fstab\n","categories":["技术教程"],"tags":["Linux","常用命令","内存"]},{"title":"初等积分法求解常微分方程笔记","url":"/2019/608/","content":"初等积分法即把微分方程的求解问题化为积分问题，用有限次求积分的方法求出微分方程的解。\n对于一般的一阶常微分方程，并没有通用的初等解法。但在数学家的不断努力下，还是有大量针对特定类型方程求解的一般方法被提了出来，在这里简单的总结记录一下以供自己查阅。\n\n\n变量分离方程有着以下形式的方程称为变量分离方程\n$$\\frac{dy}{dx}=f(x)\\varphi(y)$$\n如果 $\\varphi(y)\\not= 0$，则方程可以改写为\n$$\\frac{dy}{\\varphi(y)}=f(x)dx$$\n这样，变量就被“分离”开来了。对上述方程两边积分，得到通积分\n$$\\int\\frac{dy}{\\varphi(y)}=\\int f(x)dx+C$$\n其中 $C$ 为任意常数，$\\displaystyle{\\int\\frac{dy}{\\varphi(y)}}$ 、$\\displaystyle{\\int f(x)dx}$ 分别理解为 $\\dfrac{1}{\\varphi(y)}$ 、$f(x)$ 的原函数。可以验证该通积分即为原方程的通解\n由于上式不适合 $\\varphi(y)=0$ 时的情形，因此还必须寻求 $\\varphi(y)=0$ 的解 $y_0$ ，当 $y=y_0$ 不包括在上述通解中时，必须补上特解 $y=y_0$\n齐次方程如果微分方程\n$$P(x,y)dx+Q(x,y)dy=0$$\n可以改写成如下形式：\n$$\\frac{dy}{dx}=\\Phi(\\frac{y}{x})$$\n则称其为齐次方程\n对于改写后的齐次方程，令 $u=\\dfrac{y}{x}$ ，即 $y=ux$ ，则\n$$\\frac{dy}{dx}=x\\frac{du}{dx}+u$$\n代入原改写后的齐次方程，得\n$$x\\frac{du}{dx}+u=\\Phi(u)$$\n可以整理为\n$$\\frac{du}{dx}=\\frac{\\Phi(u)-u}{x}$$\n这是一个变量分离方程，可以按变量分离方程的求解步骤求解，求解后代回原变量即可得到原方程的解。\n除了上面提到的类型，有些方程经过简单的变换可以化为齐次方程来求解，这里不再过多介绍。\n一阶线性方程有着如下形式的方程称为一阶线性微分方程\n$$\\frac{dy}{dx}+p(x)y=q(x)$$\n其中 $p(x)$ ，$q(x)$ 是区间 $I$ 上的连续函数，而称方程\n$$\\frac{dy}{dx}+p(x)y=0$$\n为相应的一阶齐次线性微分方程。如果 $q(x)\\not\\equiv 0$，也称上述“一阶线性微分方程”为一阶非齐次线性微分方程\n一阶齐次线性微分方程通解一阶齐次线性微分方程\n$$\\frac{dy}{dx}+p(x)y=0$$\n是一个变量分离方程。 $y=0$ 是它的一个解，如果 $y\\not= 0$ ，则方程可以改写为\n$$\\frac{dy}{y}+p(x)dx=0$$\n其解为\n$$ln|y|+\\int p{x}dx=C_1,\\quad C_1是任意常数$$\n它可以改写为\n$$y=Ce^{-\\int p(x)dx}$$\n其中 $C=\\pm e^{C_1} \\not= 0$ 是任意常数。不考虑 $C$ 和 $C_1$ 之间关系的话， $C$ 可以取任意数。如果允许 $C=0$ ，则特解 $y=0$ 就在上述方程定义的曲线族中。由此可知原方程的通解为：\n$$y=\\phi_c(x):=Ce^{-\\int p(x)dx}$$\n常数变易法常数变易法是一种求解一阶非齐次线性微分方程通解的方法，由法国数学家 Lagrange（拉格朗日）在 1774 年提出，具体求解过程如下：\n先求出对应一阶齐次线性微分方程的通解，再设所求的一阶非齐次线性微分方程有形如\n$$y=C(x)e^{-\\int p(x)dx}$$\n的解，其中 $C(x)$ 为待定函数。将上式代入所求方程，可得\n$$C’(x)e^{-\\int p(x)dx}=q(x)$$\n从而得\n$$C(x)=\\int q(x)e^{\\int p(x)dx}dx+C$$\n其中 $C$ 是任意常数。由此知道，前面所设通解中的 $C(x)$ 取上式时，所设的通解满足原一阶非齐次线性微分方程。所以，一阶非齐次线性微分方程的通解为\n$$y=e^{-\\int p(x)dx}\\left(C+\\int q(x)e^{\\int p(x)dx}dx\\right)$$\n其中 $C$ 为任意常数，上式也可写成\n$$y=Ce^{-\\int p(x)dx}+e^{-\\int p(x)dx}\\int q(x)e^{\\int p(x)dx}dx$$\n它由两部分组成：\n$$y=\\phi_c(x)+y_p(x)$$\n其中 $\\phi_c(x)$ 是一阶齐次线性微分方程的通解，而\n$$y_p(x)=e^{-\\int p(x)dx}\\int q(x)e^{\\int p(x)dx}dx$$\n是原一阶非齐次线性微分方程的一个特解（取 $C=0$ ）\nBernoulli 方程Bernoulli（伯努利）方程和 Riccati（里卡蒂）方程是两类形式最简单的非线性方程。其中 Bernoulli 方程是可以求解的，Riccati 方程一般不能用初等积分法求解，这里只介绍 Bernoulli 方程\n形如\n$$\\frac{dy}{dx}+p(x)y=q(x)y^n$$\n的方程称为 Bernoulli 方程，其中 $n$ 为常数，且 $n\\not=0$ 和 $1$ 。方程两边同乘 $(1-n)y^{-n}$ ，得\n$$(1-n)y^{-n}\\frac{dy}{dx}+(1-n)y^{1-n}p(x)=(1-n)q(x)$$\n再令 $z=y^{1-n}$ ，就有\n$$\\frac{dz}{dz}+(1-n)p(x)z=(1-n)q(x)$$\n这是关于未知函数 $z$ 的一阶线性方程，由前面一阶线性方程的求解步骤可以求得 Bernoulli 方程的通解为\n$$y^{1-n}=e^{-(1-n)\\int p(x)dx}\\left(C+(1-n)\\int q(x)e^{(1-n)\\int p(x)dx}dx\\right)$$\n其中 $C$ 为任意常数。当 $n&gt;0$ 时， $y=0$ 也是 Bernoulli 方程的解\n恰当方程与积分因子法恰当方程考虑对称形式的一阶微分方程\n$$P(x,y)dx+Q(x,y)dy=0$$\n如果存在一个可微函数 $\\Phi(x,y)$ ，使得它的全微分为\n$$d\\Phi(x,y)=P(x,y)dx+Q(x,y)dy$$\n则称其为恰当方程或全微分方程，$\\Phi(x,y)$称作是一个原函数。由该定义，原方程为恰当方程当且仅当有一个可微函数 $\\Phi(x,y)$ 满足\n$$\\frac{\\partial\\Phi}{\\partial x}=P(x,y),\\quad \\frac{\\partial\\Phi}{\\partial y}=Q(x,y)$$\n此时可以很容易证明 $\\Phi(x,y)=C$ 就是原方程的通积分，其中 $C$ 是任意常数。\n由此可证明如下定理：设函数 $P(x,y)$ 和 $Q(x,y)$ 在区域\n$$R:\\alpha &lt; x &lt;\\beta,\\quad \\gamma &lt; y &lt;\\delta$$\n上连续，且有连续的一阶偏导数 $\\dfrac{\\partial P}{\\partial y}$ 与 $\\dfrac{\\partial Q}{\\partial x}$ ，则原微分方程是恰当方程的充要条件为恒等式\n$$\\frac{\\partial P}{\\partial y}(x,y)\\equiv \\frac{\\partial Q}{\\partial x}(x,y)$$\n在 $R$ 内成立。此时，原方程的通积分为\n$$\\int^x_{x_0} P(x,y)dx+\\int^y_{y_0} Q(x_0,y)dy=C$$\n或\n$$\\int^x_{x_0} P(x,y_0)dx+\\int^y_{y_0} Q(x,y)dy=C$$\n其中 $(x_0,y_0)$ 是 $R$ 中任意取定的一点。\n积分因子法还是针对上面提到的对称形式一阶微分方程，假设 $P$ 和 $Q$ 有连续的一阶偏导数，当它不是恰当方程时。如果存在连续可微函数 $\\mu=\\mu(x,y)\\not=0$，使得\n$$\\mu(x,y)P(x,y)dx+\\mu(x,y)Q(x,y)dy=0$$\n是恰当方程，亦即\n$$\\frac{\\partial(\\mu P)}{\\partial y}=\\frac{\\partial(\\mu Q)}{\\partial x}$$\n则称 $\\mu(x,y)$ 是原方程的积分因子。显然，找到了积分因子后，我们就能把原方程变为恰当方程来求解，关键在于如何找到积分因子。\n事实上寻求积分因子等同于求一阶偏微分方程$$Q\\frac{\\partial \\mu}{\\partial x}-P\\frac{\\partial \\mu}{\\partial y}=\\left(\\frac{\\partial P}{\\partial y}-\\frac{\\partial Q}{\\partial x}\\right) \\mu$$\n理论上它的解是存在的，然而对它的求解又会归结到对原方程的求解。因此，一般来说，先求出积分因子的表达式再去求解原方程是行不通的。但在若干特殊情形中，上式的求解还是比较容易的：\n原方程有一个只依赖于 $x$ 的积分因子的充要条件是\n$$\\cfrac{\\cfrac{\\partial P}{\\partial y}-\\cfrac{\\partial Q}{\\partial x}}{Q}:=G(x)$$\n只依赖于 $x$，而与 $y$ 无关。此时积分因子为 $\\mu=e^{\\int G(x)dx}$\n原方程有一个只依赖于 $y$ 的积分因子的充要条件是\n$$\\cfrac{\\cfrac{\\partial P}{\\partial y}-\\cfrac{\\partial Q}{\\partial x}}{-P}:=H(y)$$\n只依赖于 $y$，而与 $x$ 无关。此时积分因子为 $\\mu=e^{\\int H(y)dy}$\n另外还有分组求积分因子法之类的方法，这里不再过多记录。\n隐式微分方程一阶微分方程的一般形式为\n$$F(x,y,y’)=0$$\n如果能够解出导数 $y’=f(x,y)$，则可以根据 $f$ 的具体形式，由前面介绍的方法来求解\n可解出y（或x）的方程——微分法考虑可解出 $y$ 的方程\n$$y=f(x,\\frac{dy}{dx})$$\n令 $p=\\dfrac{dy}{dx}$ ，则方程变为 $y=f(x,p)$\n两边对 $x$ 求导，并将 $p=\\dfrac{dy}{dx}$ 代入，得\n$$p=\\frac{\\partial f}{\\partial x}+\\frac{\\partial f}{\\partial p}\\cdot\\frac{dp}{dx}$$\n这是关于 $x,p$ 的一阶微分方程，导数 $\\dfrac{dp}{dx}$ 已解出。若求得通积分\n$$\\Phi(x,p,C)=0$$\n则原方程有通积分\n$$\\left\\{\\begin{array}{l}\\Phi(x,p,C)=0, \\\\y=f(x,p), \\\\\\end{array}\\right.$$\n其中 $p$ 是参数，$C$ 为任意常数\n对于可解出 $x$ 的方程$$x=f(y,\\frac{dy}{dx})$$求解方法类似。令 $\\dfrac{dy}{dx}=p$ ，则方程变为 $x=f(y,p)$ ，两端对 $y$ 求导，将 $\\dfrac{dx}{dy}=\\dfrac{1}{p}$ 代入，得到一一阶微分方程，若求得通积分$$\\Phi(y,p,C)=0$$则原方程通积分为$$\\left\\{\\begin{array}{l}x=f(y,p), \\\\\\Phi(y,p,C)=0, \\\\\\end{array}\\right.$$\n不显含x（或y）的方程——参数法考虑不显含 $x$ 的微分方程$$F\\left(y,\\frac{dy}{dx}\\right)=0$$令 $p=y’$，则方程变为$$F(y,p)=0$$作为 $y,p$ 之间的联系，该方程一般代表 $(y,p)$ 平面上的若干条曲线。则可设出原方程的一个参数表示$$\\left\\{\\begin{array}{l}y=g(t), \\\\p=h(t), \\\\\\end{array}\\right.$$又由于$$dx=\\frac{1}{p}dy=\\frac{g’(t)}{h(t)}dt$$积分得$$x=\\int\\frac{g’(t)}{h(t)}dt+C$$从而原方程有通解$$\\left\\{\\begin{array}{l}y=g(t), \\\\x=\\displaystyle{\\int\\frac{g’(t)}{h(t)}+C,} \\\\\\end{array}\\right.$$其中 $t$ 为参数，$C$ 为任意常数\n对于不显含 $y$ 的方程$$F(x,y’)=0$$解法类似。令 $p=y’$ ,则方程变为 $F(x,p)=0$ ,设$$x=\\phi(t),\\quad p=\\psi(t)$$代入 $dy=pdx$ ，积分即可解得原方程通解为$$\\left\\{\\begin{array}{l}x=\\phi(t), \\\\y=\\displaystyle{\\int\\psi(t)\\phi’(t)dt+C,} \\\\\\end{array}\\right.$$\n一般情形——参数法考虑一阶隐式微分方程$$F(x,y,y’)=0$$令 $p=y’$ ，则方程可以写成$$F(x,y,p)=0$$它在 $(x,y,p)$ 空间中表示若干张曲面，设$$x=f(u,v),\\quad y=g(u,v),\\quad p=h(u,v)$$是其中一张曲面，由 $dy=pdx$ ，得$$g’_udu+g’_vdv=h(f’_udu+f’_vdv)$$它可以写成如下形式$$M(u,v)du+N(u,v)dv=0$$这是一阶显式微分方程，其中$$\\begin{array}{l}M(u,v)=g’_u(u,v)-h(u,v)f’_u(u,v),  \\\\N(u,v)=g’_v(u,v)-h(u,v)f’_v(u,v),\\end{array}$$如果能够求出它的通解$$v=Q(u,C)$$则原方程的通解为$$\\left\\{\\begin{array}{l}x=f(u,Q(u,C)), \\\\y=g(u,Q(u,C)), \\\\\\end{array}\\right.$$其中 $u$ 是参变量， $C$ 是任意常数。另外，如果除以上通解，显式一阶微分方程还有特解 $v=S(u)$ ，则原方程还有特解$$\\left\\{\\begin{array}{l}x=f(u,S(u)), \\\\y=g(u,S(u)), \\\\\\end{array}\\right.$$\n可降阶的高阶方程这里只简单介绍三类高阶微分方程的解法，基本思路都是降低高阶微分方程的阶数\n最简单的n阶微分方程$$\\frac{d^ny}{dx^n}=f(x)$$\n对于此类方程，直接求积分n次即可求解\n不显含y的微分方程$$F\\left(x,\\frac{d^ky}{dx^k},\\dots,\\frac{d^ny}{dx^n}\\right)=0 \\quad (k\\ge 1)$$\n令 $\\dfrac{d^ky}{dx^k}=z$ ，则可将方程降低 $k$ 阶，此时方程变为$$F\\left(x,z,\\dots,\\frac{d^{n-k}z}{dx^{n-k}}\\right)=0$$\n不显含x的微分方程$$F\\left(y,\\frac{dy}{dx},\\dots,\\frac{d^ny}{dx^n}\\right)=0$$\n令 $z=\\dfrac{dy}{dx}$ ，则有恒等式$$\\left\\{\\begin{array}{l}\\dfrac{d^2y}{dx^2}=\\dfrac{dz}{dx}=\\dfrac{dz}{dy}\\dfrac{dy}{dx}=z\\dfrac{dz}{dy}, \\\\\\dfrac{d^3y}{dx^3}=\\dfrac{d}{dx}\\left(z\\dfrac{dz}{dy}\\right)=z^2\\dfrac{d^2z}{dy^2}+z\\left(\\dfrac{dz}{dy}\\right)^2, \\\\\\cdots \\cdots \\cdots \\cdots \\\\\\dfrac{d^ny}{dx^n}=\\phi\\left(z,\\dfrac{dz}{dy},dots,\\dfrac{d^{n-1}z}{dy^{n-1}}\\right). \\\\\\end{array}\\right.$$将它们代入原方程就得到一个 $n-1$ 阶微分方程$$F_1\\left(y,z,\\frac{dz}{dy},\\dots,\\frac{d^{n-1}z}{dy^{n-1}}\\right)=0$$其中 $z$ 是未知函数，而 $y$ 是自变量\n","categories":["学习笔记"],"tags":["数学","微分方程","微积分"]},{"title":"字符编码常识简单介绍","url":"/2019/802/","content":"一直以来都有点搞不清楚各种字符编码的区别，但又总是碰到 ASCII、Unicode、UTF-8 等字符编码术语，所以查了点资料了解了一下这几种编码的区别及原理，下面简单记录分享一下吧。\n\n\n编码原理在计算机内部，所有信息最终都是用一个二进制的值来表示。每个二进制位有 0 和 1 两种状态，每八个二进制位（bit）组成一个字节（byte），所以很明显的，每个字节共有 2^8=256 种状态。每个状态对应一个二进制值，从 00000000 到 11111111 。\nASCII 码ASCII 码是由美国制定的一套字符编码，对英语字符和字节二进制值的对应关系做了统一的规定。\nASCII 码使用一个字节来表示一个字符，一共规定了 128 个字符的编码，这些字符只使用了单个字节中的后七个二进制位（2^7=128），第一位统一为 0 。\n对于英语来说，ASCII 编码的 128 个字符已经足够使用，但对于其他语言来说就有点不够了。所以有一些语言将 ASCII 编码中闲置的第一位也利用了起来，充分使用单个字符的 256 种状态。但这样就造成了一个很明显的问题：同一编码在不同语言编码体系中表示的字符不同，容易造成混乱。\n更进一步，对于一些象形文字发展出来的语言，比如中文，要为每一个“字”对应一个编码，单个字节的 256 种状态远远不够，必须使用多个字节来表示一个字符。比如简体中文的 GB2312 编码方式，使用两个字节表示一个字符，最多可以表示 256×256=65536 个字符。\nUnicode由于前面提到的问题，在不同的编码体系中同一个二进制数字可以被解释成不同的字符。因此，要想正常打开一个文件，就必须知道它的编码方式，否则就会出现乱码的问题。由此 Unicode 应运而生。\nUnicode 是一个统一的编码集合，类似于编码界的世界语，它将世界上所有的字符都赋予的一个独一无二的编码，从而避免了字符编码混乱的问题。\n需要注意的是 Unicode 只规定了字符的二进制代码，但并没有规定这个二进制码应该如何存储表示，这就引出了后文的 UTF-8 编码。\nUTF-8UTF-8 全名为 8-bit Unicode Transformation Format ，从名字就可以看出来，它其实是 Unicode 的实现方式之一。\n不同于纯粹的 Unicode，UTF-8 规定了 Unicode 字符的存储方式。使用一种变长的编码方案，用 1~4 个字节表示一个字符，根据不同的字符改变字节长度，从而做到在兼顾所有字符的情况下将占用空间尽可能的减小。因此成为了互联网上使用最广的一种 Unicode 实现方式。\nUTF-8 具体的编码规则如下：\n\n对于单字节的字符，字节的第一位设为 0 ，后七位为这个字符的 Unicode 码，因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。\n对于 n 个字节的字符（1&lt;n&lt;=4)，第一个字节的前 n 位都设为 1 ，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下没有提及的二进制位全部为这个字符的 Unicode  码。\n\n在知道了编码方式的条件下，解读 UTF-8 编码的字符串也就很简单了：如果一个字节第一位是 0 ，这这个字节单独就表示一个字符，取出 Unicode 码对应即可；如果第一位是 1 ，则连续有多少个 1 ，就表示当前字符占用多少字节，根据上面编码规则就可以得到该字符对应的 Unicode 码，从而得到对应字符。\n","categories":["趣味分享"],"tags":["字符编码","杂谈"]},{"title":"Nginx 隐藏版本号信息","url":"/2019/912/","content":"当我们使用 apt 或者其他包管理工具安装完 Nginx 之后，访问网站时 Header 里面会默认携带 Nginx 的版本号信息。命令行下可以使用 curl -I http://your-domain 查看：\nHTTP&#x2F;2 200 server: nginx&#x2F;1.16.1     #这里带有版本号信息date: Thu, 12 Sep 2019 03:06:23 GMTcontent-type: text&#x2F;html; charset&#x3D;cache-control: publiccontent-language: auto\n\n\n\n而软件漏洞往往都是跟版本绑定的，在管理员没有及时更新修复漏洞的情况下，一旦攻击者知道了你用的 Nginx 版本就能轻松利用已知漏洞实现入侵。\n这无疑是一个安全隐患，所以对版本号进行隐藏就一定必要了（当然，更新修复漏洞才是解决问题的根本途径）。\n解决方法要隐藏 Nginx 版本号其实很简单，稍微修改一下配置文件即可。这里使用 vim 编辑器：\nsudo vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf\n\n在 http&#123;&#125; 段中添加一行 server_tokens off; \nhttp &#123;    ......    server_tokens off;    ......&#125;\n\n之后保存文件，测试 Nginx 配置文件是否正常后重载配置即可\nsudo nginx -t            #测试配置文件是否正常sudo nginx -s reload     #重载nginx配置\n\n测试效果配置好之后可以再用 curl 测试一下，会发现不再显示 Nginx 版本号了。\nHTTP&#x2F;2 200 server: nginx       #版本号信息没有了date: Thu, 12 Sep 2019 03:32:16 GMTcontent-type: text&#x2F;html; charset&#x3D;cache-control: publiccontent-language: auto\n","categories":["技术教程"],"tags":["配置文件","Nginx"]},{"title":"为什么 vim 使用 hjkl 键作为方向键","url":"/2019/930/","content":"初次接触 vi/vim 编辑器的人可能都会有个疑问：用 hjkl 键（作为方向键）控制光标移动是什么鬼？\n关于这个问题，以前网络上有一种说法，手指放在键盘上输入时，hjkl 键比方向键距离手指更近，输入效率自然就会更高。这听起来似乎很有道理，然而我最近查了一点资料，却发现真实情况有点让人啼笑皆非。\n\n\nvim 是从 vi 发展出来的，使用了一样的键位设置，所以一切问题都要追述到 vi 编辑器的发明者 Bill Joy 身上。\n在那个时代自然是没有我们现在这么五花八门的强大计算机，Bill Joy 是在一台 ADM-3A 终端机上开发的 vi 编辑器，它就长下面这样。\n\n我们重点关注一下它的键盘。\n\n嗯，这下知道为什么要使用 hjkl 键作为方向键了吗？因为它们上面标有方向箭头啊，不用这几个键用啥？\n另外，vim 饱受诟病的使用 Esc 键切换模式的操作（模式切换属高频动作，但现代键盘上 Esc 键太远了，按起来很不方便）也是因为这个键盘布局导致的，看看那时候的 Esc 键离手指多近啊……\n最后，从上面的键盘布局图中我们还能发现一个有趣的事情，看看右上角的 HOME 键，发现了什么吗？没错，那时候的 ~ 和 HOME 是在一个键上面的，这就是起源于那个时代的 UNIX/Linux 系统中使用 ~ 表示 home 目录的原因。\n参考资料：https://catonmat.net/why-vim-uses-hjkl-as-arrow-keys\n","categories":["逸趣杂谈"],"tags":["vim","杂谈"]},{"title":"在没有管理员权限的 Linux 服务器上安装 vim","url":"/2019/1006/","content":"最近拿到了一个实验室的服务器帐号用来跑一些计算，是一个没有 sudo 权限的普通用户帐号。\n本来以为有没有管理员权限对我都没啥影响，结果登上去一看，发现这台新配的服务器很多东西都还没来得及装，连 vim 都没有，在命令行下改东西只能用 vi，十分的不方便（没有高亮）。\n\n\n由于没有管理员权限，用 apt 安装肯定是不用想的，只能尝试源码编译安装了。\n尝试编译首先从 vim 的官网或者 GitHub 下载源码，截至本文发布官网最新版本是 8.1\n# 下载源码wget ftp:&#x2F;&#x2F;ftp.vim.org&#x2F;pub&#x2F;vim&#x2F;unix&#x2F;vim-8.1.tar.bz2# 解压tar -jxvf vim-8.1.tar.bz2\n\n解压后我们进入源码文件夹执行 ./configure 尝试生成 Makefile 文件。这里需要注意的是，vim 默认将最后的编译产物放在 /usr/local 下（可以执行 ./configure --help 查看），而我们没有管理员权限，无权操作该文件夹（一般普通用户只能操作自己用户目录下面的文件夹），所以需要手动指定一下安装目录。\ncd vim81.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;km&#x2F;opt&#x2F;vim81\n\n我们自然是没有那份能够一次性成功的运气，执行过程中遇到了如下报错：\nchecking for tgetent()... configure: error: NOT FOUND!      You need to install a terminal library; for example ncurses.      Or specify the name of the library with --with-tlib.\n\n这个报错说的算是比较清楚了：没有找到终端库，让我们去安装一个。\n根据这个报错说明，装 ncurses 肯定是可以的。一般遇到这种情况都是直接用 apt 去安装（有管理员权限的话，ubuntu 下执行 sudo apt install libncurses5-dev 即可安装），然而跟我们无法直接安装 vim 同样的原因：没有管理员权限，这个依赖库也只能靠编译安装了。\n编译安装 ncurses同样的首先需要下载源码，截至本文发布最新的版本是 6.1\n# 下载wget https:&#x2F;&#x2F;ftp.gnu.org&#x2F;pub&#x2F;gnu&#x2F;ncurses&#x2F;ncurses-6.1.tar.gz# 解压tar -xzvf ncurses-6.1.tar.gz\n\n同样的，执行 ./configure 的时候我们需要指定一个自己有操作权限的安装目录。\ncd ncurses-6.1.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;km&#x2F;opt&#x2F;ncurses-6.1\n\n这次倒是一次成功没有遇到任何问题，接下来编译后安装就行了。\nmakemake install\n\n执行完之后可以在我们指定的安装目录下找到 bin、include、lib、share 几个文件夹。\n重新尝试编译在编译安装好 ncurses 之后我们回到 vim 源码所在的目录重新执行 ./configure 。需要注意的是，我们安装的 ncurses 不在标准目录下，所以在编译其他依赖 ncurses 的程序的时候需要手动指定一下相关文件所在的目录。\n.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;km&#x2F;opt&#x2F;vim81 LDFLAGS&#x3D;-L&#x2F;home&#x2F;km&#x2F;opt&#x2F;ncurses-6.1&#x2F;lib CPPFLAGS&#x3D;-I&#x2F;home&#x2F;km&#x2F;opt&#x2F;ncurses-6.1&#x2F;include\n\n这次直接一路到底，没有出现任何报错，接下来编译后安装一下就可以啦。\nmakemake install\n\n在安装完之后可以在我们指定的安装目录下（我这里是 /home/km/opt/vim81 ）找到 bin 和 share 两个目录，vim 的可执行文件就存放在 bin 目录下。\n用绝对路径执行一下试试： /home/km/opt/vim81/bin/vim ，可以看到熟悉的界面就说明编译安装成功啦。\n一些其他设置每次都像上面那样用相对/绝对路径来运行 vim 无疑是很麻烦的，我们这里为编译出来的可执行文件设置一个 alias 以方便使用（将 vim 的可执行文件路径添加到 PATH 环境变量中也能实现同样地效果）\n# 编辑用户目录下的 .bashrc文件vi ~&#x2F;.bashrc# 在最后添加一行 aliasalias vim&#x3D;&#39;&#x2F;home&#x2F;km&#x2F;opt&#x2F;vim81&#x2F;bin&#x2F;vim&#39;\n\n保存文件后使用 source ~/.bashrc  激活设置，之后就可以在任何位置直接输入 vim 使用啦。\n另外，在实际使用中发现这样自己编译出来的 vim 存在这篇文章：Debian9 下为 vim 启用鼠标复制粘贴 中提到的无法使用鼠标右键复制粘贴的问题（系统是 Ubuntu 18.04）。要解决这个问题也很简单，修改一下 vim 的用户配置文件即可（由于这样安装的 vim 只有自己一个账户能用，所以修改用户个人配置文件即可，那篇文章中修改的是 vim 的全局配置文件）。\n# 在当前用户目录下新建 vim 配置文件目录mkdir ~&#x2F;.vim# 新建 vim 用户配置文件并编辑vim ~&#x2F;.vim&#x2F;vimrc# 在其中写入如下内容（注意将 source 后面的文件路径修改为自己的）source &#x2F;home&#x2F;km&#x2F;opt&#x2F;vim81&#x2F;share&#x2F;vim&#x2F;vim81&#x2F;defaults.vimlet skip_defaults_vim &#x3D; 1if has(&#39;mouse&#39;)    set mouse-&#x3D;aendif\n\n保存文件并退出，再次使用 vim 时就会发现能够正常的使用鼠标右键来进行复制粘贴操作啦！\n后记在这样一顿操作编译安装好 vim 后的第二天，成功找当初给我分配服务器帐号的学长搞到了 sudo 权限，所以……可执行文件、源码啥的统统删掉！然后 sudo apt install vim ……（手动狗头）\n","categories":["技术教程"],"tags":["Linux","vim","编译"]},{"title":"为 Debian 下 root 用户的 ls 命令开启颜色显示","url":"/2019/1118/","content":"平时自己折腾时还是比较喜欢更轻量一些的 Debian 系统。然而用过 Debian 的应该都知道，它的 root 用户使用 ls 命令时的输出默认是不带颜色显示的。\n这虽然不是什么大问题，但对使用体验的影响还是不小的。查了一些资料后找到了解决方案，在这里记录一下吧。\n\n\n问题详情使用 root 用户登录一个刚刚安装好的 Debian 系统，然后使用 ls 命令试试。如下图，输出结果是不带颜色显示的。这导致我们很难把文件、文件夹、可执行文件、普通文件区分开来，十分影响使用体验。\n\n解决方案解决方法其实很简单，修改用户目录下的 .bashrc 文件，把 ls 设置为带颜色参数的 ls 命令的别名（alias）即可。当然，这个别名实际上也不需要我们去手动添加，.bashrc 文件中本来就有，我们只要将其取消注释就行了。\n使用 vim 编辑 .bashrc 文件：\nvim ~&#x2F;.bashrc\n\n打开该文件后我们可以找到如下几行：\n# You may uncomment the following lines if you want `ls&#x27; to be colorized:# export LS_OPTIONS=&#x27;--color=auto&#x27;# eval &quot;`dircolors`&quot;# alias ls=&#x27;ls $LS_OPTIONS&#x27;# alias ll=&#x27;ls $LS_OPTIONS -l&#x27;# alias l=&#x27;ls $LS_OPTIONS -lA&#x27;\n\n这里第一行的注释已经说得很清楚了：如果你想要 ls 命令被“着色”，可以把下面几行取消注释。根据这一说明，我们把下面几行的注释取消掉后保存文件即可。\n效果展示按照上面的步骤修改好后，重新开一个对话使用 ls 命令试试看。可以发现输出结果已经自动带上颜色显示了，文件、文件夹等不同类型的输出一目了然。\n\n","categories":["技术教程"],"tags":["Linux","常用命令"]},{"title":"纯 Nginx 实现一个 IP 地址显示 API","url":"/2019/1203/","content":"如标题所示，不依赖任何后端方法，使用纯 Nginx 实现（Nginx-Lua 也不需要）一个“显示我的 IP 地址”的 API。\n实际上这是我在很久之前看过的一篇文章中介绍的技巧，时间有点久了，一时半会儿也找不到原文地址，但发现自己当时写的 Nginx 配置文件还在，所以翻出来分享一下。\n\n\n普通版本Nginx 的配置文件中提供了一个变量 $remote_addr 用来获取用户访问本实例时的 IP 地址，我们只要将这个变量的值返回给用户就行了（没错，就是这么简单！）：\nlocation / &#123;    default_type text/plain;    return 200 $remote_addr;&#125;\n\n这里使用 default_type text/plain 来向浏览器表明我们返回的值是一个纯文本，从而能够被浏览器直接显示出来。\nJSON 版本同样依赖于 $remote_addr 这个变量，我们可以将返回值稍微修饰一下，实现一个返回 JSON 数据的 API：\nlocation /json &#123;    default_type application/json;    return 200 &quot;&#123;\\&quot;ip\\&quot;:\\&quot;$remote_addr\\&quot;&#125;&quot;;&#125;\n\n配置文件中的 default_type application/json 向浏览器表明我们的返回的值是 JSON 数据。\n测试效果配置好后可以使用 curl 来测试一下（下面的 API 域名和返回值中的 IP 地址都做了替换处理，非真实情况）：\n$ curl http:&#x2F;&#x2F;example.com&#x2F;xx.xx.xx.xx$ curl http:&#x2F;&#x2F;example.com&#x2F;json&#123;&quot;ip&quot;:&quot;xx.xx.xx.xx&quot;&#125;\n","categories":["趣味分享"],"tags":["Nginx","自建服务"]},{"title":"Linux 系统查看某个用户组下面的所有用户","url":"/2020/103/","content":"Linux 系统中有关用户组的信息放在 /etc/group 这个文件中，而用户信息放在 /etc/passwd 文件中。\n要查看某个用户组下面的所有用户，很明显我们需要把这两个文件提供的信息结合起来，下面做一些简单的介绍。\n\n\n文件内容在实际动手之前我们先来看看这两个文件中到底存了些啥。由于是纯文本文件，直接使用 cat 命令查看即可。\n用户组信息$ cat &#x2F;etc&#x2F;grouproot:x:0:rootsys:x:3:binmem:x:8:ftp:x:11:mail:x:12:log:x:19:smmsp:x:25:proc:x:26:adm:x:999:daemon......\n\n可以看到一行表示一个用户组，总共有四个字段，字段之间使用冒号分隔，从左往右依次为：用户组名、用户组密码、用户组ID（GID）、用户列表（可以为空）。详细解释如下：\n\n用户组名：就是用户组的名字，在同一个 Linux 操作系统中不允许重复\n用户组密码：出于保密性考虑，在这个文件中都是用 x 代替的，真正的密码信息存放在 /etc/gshadow 中\n用户组ID：用户组的唯一标识，这是我们能够实现查找某个用户组下面的所有用户的关键\n用户列表：每个用户之间用 , 号分割，可以为空，如果字段为空表示用户组为 GID 的用户名\n\n用户信息$ cat &#x2F;etc&#x2F;passwdroot:x:0:0::&#x2F;root:&#x2F;bin&#x2F;bashbin:x:1:1::&#x2F;:&#x2F;usr&#x2F;bin&#x2F;nologindaemon:x:2:2::&#x2F;:&#x2F;usr&#x2F;bin&#x2F;nologinmail:x:8:12::&#x2F;var&#x2F;spool&#x2F;mail:&#x2F;usr&#x2F;bin&#x2F;nologinftp:x:14:11::&#x2F;srv&#x2F;ftp:&#x2F;usr&#x2F;bin&#x2F;nologinhttp:x:33:33::&#x2F;srv&#x2F;http:&#x2F;usr&#x2F;bin&#x2F;nologinnobody:x:65534:65534:Nobody:&#x2F;:&#x2F;usr&#x2F;bin&#x2F;nologinuuidd:x:68:68::&#x2F;:&#x2F;usr&#x2F;bin&#x2F;nologingit:x:977:977:git daemon user:&#x2F;:&#x2F;usr&#x2F;bin&#x2F;git-shell......\n\n同样的一行表示一个用户，共有七个字段，字段之间使用冒号分隔，从左往右依次为：用户名、用户密码、用户ID（UID），用户所在组的ID（GID），一些说明信息，用户的家目录，用户登录后的 shell。详细解释如下：\n\n用户名：用户登录时使用的名字，区分大小写，在同一个 Linux 操作系统中不允许重复\n用户密码：用户密码都是同样的都是用 x 代替。真正的密码信息存放在 /etc/shadow 文件中\n用户ID：用户的唯一标识，系统是通过 UID 来识别不同的用户和分配用户权限的。只有 UID&gt;500 的用户才是普通用户，其他都是系统用户（也称为伪用户），是用来运行系统服务的，不能登录，也不能删除\n用户所在组的ID：这个”用户所在组“指的是初始组，用户一登录就立即拥有这个组的相关权限。每个用户只能有一个初始组，一般就是将和组名这个用户的用户名相同的组作为这个用户的初始组。除此之外还有附加组等\n一些说明信息：就是对该用户的一些描述，功能类似于注释，没有什么实际作用\n用户的家目录：即用户的 ~ 所代表的路径，一般情况下用户拥有他的家目录的所有权限\n用户登录后的 shell：用户登录后所使用 shell 的可执行文件路径，可以通过这里限制用户的登录行为\n\n查找方式Linux 系统中使用 UID 唯一标识一个用户，使用 GID 唯一标识一个用户组，再结合上面两个文件中的其他信息，我们很容易就能找到一个“查看一个用户组内所有用户”的方式。\n首先从 /etc/group 文件中找出我们需要查找的用户组的 GID（这里以 http 用户组为例）：\n$ cat &#x2F;etc&#x2F;group | grep httphttp:x:33:\n\n从上面的结果中可以看到 http 用户组的 GID 是 33，接下来我们从 /etc/passwd 文件中找出所有的用户所在组ID为 33 的用户：\nawk -F &quot;:&quot; &#39;&#123;print $1&quot;\\t&quot;$4&#125;&#39; &#x2F;etc&#x2F;passwd | grep &#39;33&#39;\n\n会一点 shell 编程的人应该很容易看懂这句命令的意思。先是使用 awk 的 -F 参数指定使用使用冒号作为分隔符，然后 &#123;print $1&quot;\\t&quot;$4&#125; 打印输出第一列和第四列（即用户名和 GID），中间用一个制表符 \\t 分隔开来，最后将结果通过管道送给 grep 处理，从中查找出所有包含字符串“33”的行。\n上述命令的输出结果如下所示：\nhttp\t33\n\n这说明在我使用的系统中 http 用户组下只有一个名为 http 的用户。查找其他用户组的操作同理。\n","categories":["技术教程"],"tags":["Linux","常用命令"]},{"title":"Arch Linux 从零开始安装","url":"/2020/104/","content":"很久之前的一份记录，本来不打算发的，但最近折腾了一下把服务器上的系统在线替换安装成了 Arch Linux，中间涉及到很多本文的步骤，所以还是稍微整理一下发出来吧。\n由于之前做记录只是用于自己备忘，所以全程无图，一些细节部分请对照 官方wiki 查看，注意安装时需要联网。\n\n\n启动到 live 环境安装过 Linux 系统的人对这一步自然不会陌生，完全没有安装 Linux 系统经验的人我也不建议你直接上手折腾 Arch Linux。这里我们不再详述，简单概括一下的话就下面几个步骤：刻录 U 盘、从 U 盘启动、选择第一项启动 Arch Linux。\n不同于一般的 Linux 发行版提供了图形界面（类图形界面）的安装方式，Arch Linux 的安装全程在命令行下进行，此时我们从 U 盘启动 Arch Linux 后进入的就是这么一个临时的命令行环境。\n硬盘分区输入 fdisk -l 列出自己所有的硬盘，结果中以 rom，loop 或者 airoot 结束的可以忽略。这里我们将系统装在 /dev/sda 中。\n对于一个正常的 Linux 系统，根分区 / 是必须要有的，如果你使用 UEFI 模式，则还会需要一个 EFI 分区。除此之外你还可以分配交换空间（SWAP），将 /boot  、/home 分区单独挂载等。\n我们这里一切从简，只分配一个根分区。我虽然曾经配置过 UEFI 模式，但并没有记录下当时的步骤，所以本文暂不会涉及 UEFI ，以后若我重新折腾了相关的东西可能会补发上来。\n在只分配一个根分区的情况下我们需要考虑的事情就少了很多，直接将所有空间分到一个分区内即可。输入 fdisk /dev/sda 进入分区程序，输入 o 新建一个分区表（开始分区），输入 n 新建一个分区，然后一路按回车键 Enter 选择默认的配置即可，在完成后输入 p 可以查看我们的分区情况，输入 w 写入分区信息并退出。\n之后输入 lsblk 可以看到 sda 下面分出了一个名为 sda1 的分区。\n硬盘格式化分好区后我们还需要对其格式化，输入 mkfs.ext4 /dev/sda1 将 sda1 分区格式化为 ext4 格式。\n挂载分区再之后就属于正式安装的步骤了，输入 mount /dev/sda1 /mnt 将 sda1 分区挂载到我们当前系统的 /mnt 目录下。\n选择镜像源选择一个中国用起来比较快的镜像源能够很大程度上加快我们后面安装时的进度。\n输入 cd /etc/pacman.d 进入镜像配置文件目录，输入 cp mirrorlist mirrorlist.bk 备份一下原文件，然后输入以下命令提取出所有的中国镜像写入 mirrorlist 文件：\ncat mirrorlist.bk | grep China -A 1 | grep -v &#39;-&#39; &gt; mirrorlist\n\n最后使用你喜欢的编辑器（这个 live 系统中内置了 vim 和 nano）手动编辑 mirrorlist 文件，使用 # 注释掉不用的镜像，我这里一般最后留下中科大（ustc）和清华大学（tuna.tsinghua）的镜像源。\n安装系统这里的安装系统本质上其实是在我们挂载 sda1 分区的目录 /mnt 下安装系统所必需的文件和软件包。这里具体要安装哪些软件包是自己可选的，详情可以查看 官方wiki ，我一般在这里只安装一些必需软件包，像文本编辑器之类的东西可以在等下 chroot 进入新系统后使用 pacman 手动安装。\npacstrap &#x2F;mnt base base-devel linux linux-firmware\n\n生成自动挂载配置使用以下命令生成挂载配置并写入 fstab 文件中 (用 -U 或 -L 选项设置UUID 或卷标)：\ngenfstab -U &#x2F;mnt &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;fstab\n\n强烈建议在执行完以上命令后检查一下生成的 /mnt/etc/fstab 文件是否正确。\n进入新系统输入 arch-chroot /mnt 临时进入我们的新系统来完成最后的一些配置。\n系统配置此时这个新系统还处于啥也没有的状态，我们可以使用 pacman 来安装自己想要的软件（考虑到下载速度，你可能需要对这个新系统中的镜像源配置文件做同样的处理），需要注意的是你此时安装的软件在最终配置好的系统中都会保留下来。\n设置文字编码编辑 /etc/locale.gen 文件，将 zh_CN 开头的行全部取消注释，再找到 en_US.UTF-8 UTF-8 也取消注释。然后输入 locale-gen 生成 locale 。最后再编辑 /etc/locale.conf 设置本地编码配置如下：\nLANG&#x3D;en_US.UTF-8\n\n注意： 最好不要在这里设置任何中文 locale，不然可能会导致命令行乱码。\n设置时区和时间运行以下命令将时区设置为 Asia/Shanghai （中国所用的时区）。\nln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime\n\n运行 hwclock 以生成 /etc/adjtime （这个命令假定硬件时间已被设置为 UTC 时间）：\nhwclock --systohc\n\n其他设置编辑 /etc/hostname 文件设置自己想要的主机名，编辑 /etc/hosts 设置 host 信息。\n然后输入 mkinitcpio -P 生成启动镜像。\n在那之后输入 passwd 设置一下 root 用户的登录密码。\n配置 GRUB 引导还是在我们临时进入的这个新系统里面，输入 pacman -S grub 安装 grub 引导程序，然后输入以下命令安装 BOIS 引导到 /dev/sda 这块硬盘上。\ngrub-install --target&#x3D;i386-pc &#x2F;dev&#x2F;sda\n\n最后输入 grub-mkconfig -o /boot/grub/grub.cfg 生成 grub 配置文件就可以了。\n网络配置之后我们重启一下机器，如果前面的操作没有问题的话应该是能够正常启动我们新安装好的系统的。\n但此时你会发现机器无法联网，因为我们还缺少一个网络管理软件。本着尽量少安装软件的原则，我这里选用的是 systemd-networked，无需单独安装，直接配置好后启动即可。更多设置可以参见 Network configuration 。\n首先输入 ip a 查看自己机器的网卡配置，并记下网卡名，我这里是 ens3 。\n进入 /etc/systemd/network/ 文件夹下，新建一个配置文件 dhcp.network （名字可以任取，后缀为 network 即可），写入如下配置：\n[Match]Name&#x3D;ens3[Network]DHCP&#x3D;ipv4[DHCPv4]UseHostname&#x3D;false\n\n这表示在 ens3 这张网卡上启用 DHCP 自动分配 ipv4 地址，不使用 DHCP 分配的主机名。[Match] 部分可以使用通配符，例如写成 Name=en* 。\n配置好后启动 systemd-networkd.service 服务，并设置开机自启。\nsystemctl start systemd-networkd.servicesystemctl enable systemd-networkd.service\n\n此时你再去测试，会发现仍然无法上网，提示信息翻译过来大意是无法解析到主机，这是因为我们还没有指定一个 DNS 服务器，无法解析域名，所有使用域名的服务都无法使用。\n要解决这个问题只需要编辑 /etc/resolv.conf 写入一组 DNS 服务器即可。\nnameserver 8.8.8.8nameserver 114.114.114.114\n\n要是你不想自己指定 DNS 服务器，也可以使用 DHCP 服务器分配的 DNS（个人比较推荐这样做，速度快一些，能够避免一些奇奇怪怪的问题）。\n首先启动并设置 systemd-resolved.service 开机自启。\nsystemctl start systemd-resolved.servicesystemctl enable systemd-resolved.service\n\n然后将 /etc/resolv.conf 设为 systemd-resolved 服务下 DNS 配置文件的软链接即可。\nln -sf &#x2F;run&#x2F;systemd&#x2F;resolve&#x2F;resolv.conf &#x2F;etc&#x2F;resolv.conf\n\n其他配置在前面的操作完成后检查一下系统时间，如果不准确，可以启用 NTP 服务来自动更新系统时间：\ntimedatectl statustimedatectl set-ntp true\n\n如果你的机器需要远程连接，那么还应当安装 ssh 工具并设置开机自启：\npacman -S opensshsystemctl start sshdsystemctl enable sshd\n\n需要注意的是 openssh 现在默认禁止 root 用户登录，所以在安装好之后需要新建一个普通用户用于登录或者修改配置文件  /etc/ssh/sshd_config 设置允许 root 用户登录，\n","categories":["技术教程"],"tags":["Linux","系统安装","Arch Linux"]},{"title":"使用 GitHub Actions 自动获取 Hostloc 论坛积分","url":"/2020/111/","content":"博主其实在 GitHub Actions 还没正式推出时就申请到了测试资格，奈何自己的博客早就配置了 Travis CI 自动构建（现已更换），懒得修改了，又没有什么其他项目，所以根本没有实践过。\n最近闲了下来，稍微过了一下 GitHub Actions  的文档，然后折腾了个自动获取 Hostloc 论坛（全球主机交流论坛）积分的小工具，在这里简单介绍一下吧。\n\n\n2021年5月19日更新由于 GitHub 的使用政策更新，似乎不再允许该类用途，本仓库在近期的严查中不幸被封禁了，在跟 GitHub 联系后已确认无法解封（他们不接受任何整改意愿，甚至都不能让我将数据备份一下）。\n本项目将不再更新，原代码库备份可以从以下链接获取：https://git.inkuang.com/inkuang/hostloc-auto-get-points\n快速使用如果你对那些代码、原理不感兴趣，只是想要用这么个东西的话只要看这一小节就够了，详细讲解放在后面。\n首先 Fork 我写好代码的仓库：https://github.com/inkuang/hostloc-auto-get-points\n然后在你 Fork 的仓库页面点击右上角的 Settings，找到 Secrets 这一项，添加两个秘密环境变量。\n\n其中 HOSTLOC_USERNAME 存放你在 Hostloc 的帐户名，HOSTLOC_PASSWORD 存放你的帐户密码。支持同时添加多个帐户，数据之间用半角逗号 , 隔开即可，帐户名和帐户密码需一一对应。\n设置好环境变量后点击你的仓库上方的 Actions 选项，会打开一个如下的页面，点击 I understand... 按钮确认在 Fork 的仓库上启用 GitHub Actions 。\n\n此时页面上会显示当前仓库所有的 Workflows，点击左侧的 Hostloc Auto Get Points，然后点击页面上黄色提醒框 This scheduled workflow is disabled... 处的 Enable workflow 按钮确认在 Fork 的仓库上启用 GitHub Actions 定时任务。\n最后在你这个 Fork 的仓库内随便改点什么（比如给 README 文件删掉或者增加几个字符）提交一下手动触发一次 GitHub Actions 就可以了。\n仓库内包含的 GitHub Actions 配置文件会在每天国际标准时间 17 点（北京时间凌晨 1 点）自动执行获取积分的脚本文件，你也可以通过 Push 操作手动触发执行（测试发现定时任务的执行可能有 5 到 10 分钟的延迟，属正常现象，耐心等待即可）。\n注意： 为了实现某个链接/帐户访问出错时不中断程序继续尝试下一个，GitHub Actions 的状态将永远是“通过”（显示绿色的✔），请自行检查 GitHub Actions 日志 Get points 项的输出确定程序执行情况。\n获取积分原理及代码在 Hostloc 论坛上，访问他人用户空间每次可以获得 2 积分，每天最多 20 积分。这个小工具就是基于这一原理，使用代码模拟用户登录，然后随机访问用户空间来实现的。\n详细代码可以到我的 GitHub 仓库 查看，这里只介绍几个关键点。\n观察发现，用户空间的链接都是类似 https://www.hostloc.com/space-uid-&#123;&#125;.html 的格式，大括号内就是用户 id，基于此，我们随机生成一定数量的用户 id，然后构造一系列的用户空间链接：\ndef randomly_gen_uspace_url():    url_list = []    # 访问小黑屋用户空间不会获得积分、生成的随机数可能会重复，这里多生成两个链接用作冗余    for i in range(12):        uid = random.randint(10000, 50000)        url = &quot;https://hostloc.com/space-uid-&#123;&#125;.html&quot;.format(str(uid))        url_list.append(url)    return url_list\n\n比较关键的，登录，可以打开浏览器开发者工具的 Network 选项，然后在论坛首页使用错误的用户名、密码登录一次（正确的帐户在点击登录后页面会发生跳转，就看不到数据了），会发现我们请求了 member.php 这个文件，在它的 Headers 里可以看到我们使用 post 发送了一组数据。\n利用这些获取的数据和 requests 的 Session 对象，我们可以很轻松的实现登录功能： \ndef login(username, password):    headers = &#123;        &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;,        &quot;origin&quot;: &quot;https://www.hostloc.com&quot;,        &quot;referer&quot;: &quot;https://www.hostloc.com/forum.php&quot;,    &#125;    login_url = &quot;https://www.hostloc.com/member.php?mod=logging&amp;action=login&amp;loginsubmit=yes&amp;infloat=yes&amp;lssubmit=yes&amp;inajax=1&quot;    login_data = &#123;        &quot;fastloginfield&quot;: &quot;username&quot;,        &quot;username&quot;: username,        &quot;password&quot;: password,        &quot;quickforward&quot;: &quot;yes&quot;,        &quot;handlekey&quot;: &quot;ls&quot;,    &#125;    s = requests.Session()    s.headers.update(headers)    res = s.post(url=login_url, data=login_data)    res.raise_for_status()    return s\n\n接下来只要使用登录后的 Session 对象，依次 get 前面生成的用户空间链接即可，这里不再详述。\n需要注意的是，为了安全和方便他人使用，我们这里不把用户名和密码写在代码中，而是通过环境变量获取，这样也方便后面与 GitHub Actions 结合使用。\nusername = os.environ[&quot;HOSTLOC_USERNAME&quot;]password = os.environ[&quot;HOSTLOC_PASSWORD&quot;]\n\nGitHub Actions 配置代码写好之后我们只需要将它每天运行一遍就行了。你完全可以手动操作，但那样无疑很麻烦，这里我们使用 GitHub Actions 来自动完成这一步骤。完整配置文件请到我的 GitHub 仓库 查看，这里只简单做一下介绍。\n注： GitHub Actions 配置文件的格式请到官方文档查看了解，这里不会涉及。\n首先要考虑的就是我们什么时候需要运行这个脚本。很明显，从我们的需求来看具体的运行时间并不重要，只要每天运行一次就行了，这里使用 GitHub Actions 的定时任务来实现，在配置文件的 on 字段中指定（为了方便测试，这里将 push 操作触发也加进来）：\non:  push:    branches:       - master  schedule:    - cron: &#x27;0 17 * * *&#x27;\n\n这里指定在每次 push 操作后或者每天国际标准时间 17 点（也就是北京时间凌晨 1 点）执行。\n接下来就是考虑运行环境了。首先检出代码，然后设置 python 版本，再接着安装一下依赖（我们的依赖只有 requests 这一个包）。这样我们的 python 脚本所需要的运行环境就配置完成了。\n- name: &#x27;Checkout codes&#x27;  uses: actions/checkout@v2- name: &#x27;Set python&#x27;  uses: actions/setup-python@v1  with:    python-version: &#x27;3.x&#x27;- name: &#x27;Install dependencies&#x27;  run: python -m pip install --upgrade requests\n\n最后，也是最关键的一步：运行我们的脚本。前面提到我们的脚本中登录使用的用户名和密码是从环境变量中读取的，所以在这里我们需要设置一下环境变量。为了安全，我们将用户名和密码存在仓库的 Secrets 中，然后从 GitHub Actions 配置文件的 secrets 域中读取出来并设置为对应的环境变量：\n- name: &#x27;Get points&#x27;  env:    HOSTLOC_USERNAME: $&#123;&#123; secrets.HOSTLOC_USERNAME &#125;&#125;    HOSTLOC_PASSWORD: $&#123;&#123; secrets.HOSTLOC_PASSWORD &#125;&#125;  run: python hostloc_get_points.py\n\n好啦，基本原理之类的东西就这么些了，花了几个小时撸出来的（主要花在看 GitHub Actions 的文档和折腾论坛的登录机制上面），如果你觉得有用的话不要忘了点个 star 哦~~~\n","categories":["技术教程"],"tags":["GitHub Actions","自动化"]},{"title":"将现有 Linux 系统替换安装为 Arch Linux","url":"/2020/114/","content":"在前文 Arch Linux 从零开始安装 里就提到过我把服务器上的系统在线替换安装成了 Arch Linux，拖了这么久终于有时间来整理一下折腾过程，在这里简单记录一下。\n本文所涉及的内容在 Arch Wiki 中也有相关教程，可以对照查看：Install Arch Linux from existing Linux 。\n\n\n环境要求博主自己初次测试时用的是阿里云的轻量服务器，原系统（标题中的“现有 Linux 系统”）是 Debian 9 。\n考虑到我们并没有太多的操作需要在原系统中进行，所以原系统是啥应该影响不大，唯一的要求就是如果在云服务器上操作的话必须要能够通过网页进行 vnc 连接（在配置网络管理器、ssh 之前需要重启，但此时网络环境还没弄好，重启后就无法再通过 ssh 连上服务器了）。\n启动 chroot 环境和从镜像安装 Arch Linux 一样，我们的安装操作首先要做的就是进入一个“最小化的安装环境”。这里我们通过官方提供的引导镜像启动一个 chroot 环境以满足这一要求。\n首先从 Arch Linux 的镜像站点下载引导镜像文件（名字一般是 archlinux-bootstrap-YYYY.MM.DD-x86_64.tar.gz 的形式）到 /tmp 目录下。为了加快下载速度，我这里是从中科大的镜像源下载的：\ncd &#x2F;tmpwget http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinux&#x2F;iso&#x2F;2020.01.01&#x2F;archlinux-bootstrap-2020.01.01-x86_64.tar.gz\n\n下载之后解压可以得到一个名为 root.x86_64 的文件夹：\ntar xzvf archlinux-bootstrap-2020.01.01-x86_64.tar.gz\n\n然后我们通过 mount --bind 命令将这个文件夹与自己连接起来，这一步主要是为了让我们在进入 chroot 环境后能够使用使用 pacman 安装软件。\nmount --bind &#x2F;tmp&#x2F;root.x86_64 &#x2F;tmp&#x2F;root.x86_64\n\n在进入 chroot 环境后需要安装一些软件用于后续系统的安装，而引导镜像中不包含任何编辑软件，所以我们最好提前利用原系统上的编辑软件修改好引导镜像中使用的镜像源。\nvim &#x2F;tmp&#x2F;root.x86_64&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist\n\n去除自己想用的镜像源前面的 # 号即可启用（默认是全部注释掉了的，至少需启用一个）。\n之后利用引导镜像中的可执行文件 /tmp/root.x86_64/bin/arch-chroot 将我们的引导镜像目录 /tmp/root.x86_64/ 启动为 chroot 环境（感觉有点绕…）\n&#x2F;tmp&#x2F;root.x86_64&#x2F;bin&#x2F;arch-chroot &#x2F;tmp&#x2F;root.x86_64&#x2F;\n\n不出意外的话此时就成功进入了从我们下载的引导镜像启动的 chroot 环境。\n使用 chroot 环境进入 chroot 环境其实就相当于我们使用镜像安装时的“启动到 live 环境”这一步，这个环境已经拥有了安装系统所必需的软件包，下面介绍具体的安装操作。\n初始化 pacman 密钥在这个 chroot 环境中我们是可以使用 pacman 安装软件的，但在那之前需要先初始化一下 pacman 的密钥：\npacman-key --initpacman-key --populate archlinux\n\n初始化完成之后你就可以随意安装自己需要的软件了，我这里只安装一个了 vim 编辑器：\npacman -Syypacman -S vim\n\n抹除原系统首先将我们原系统所在的分区（我这里是 /dev/vda1 ）挂载到当前系统（chroot 环境）的 /mnt 目录下：\nmount &#x2F;dev&#x2F;vda1 &#x2F;mnt\n\n需要注意的是，我们无法对原系统所在的硬盘重新分区（重新分区后需要格式化，而我们现在所在的 chroot 环境还依赖着 /tmp/root.x86_64 目录下的文件），所以这里挂载的分区就是我们用来安装新系统的分区。\n注意：到这一步我们的原系统还是安全的，你可以随时使用 exit 退出 chroot 环境，但是一旦执行了下面的步骤就再也无法回头了，要么成功，要么重装，请谨慎操作！！！\n接下来进入 /mnt 目录，将除了 tmp、dev、proc、run、sys 几个目录外的其他所有文件/文件夹全部删掉：\ncd &#x2F;mntrm -rf ......\n\n安装新系统再接下来我们就可以按照正常安装 Arch Linux 的步骤开始安装我们的新系统了。\n具体操作参见 Arch Linux 从零开始安装 ，从“安装系统”这一步开始一直到“配置 GRUB 引导”（包括配置 GRUB 引导这一步）。\n重启系统在配置好 GRUB 引导之后我们的系统安装就已经基本完成了，这时候需要重启一下机器，正式启动我们新安装好的 Arch Linux 系统。\n由于 chroot 环境没有重启权限，原系统中的文件又已经被我们全删掉了，所以只能通过断电来“硬重启”（云服务器可以通过服务商的控制台重启）。\n若无意外的话重新启动的就是我们新安装好的 Arch Linux 系统了。此时还没有进行网络配置，机器无法联网，所以云服务器需要通过控制台的 vnc 连接来完成后续的步骤（阿里云轻量服务器就是后台的救援连接）\n配置网络配置网络的步骤跟我们正常安装时的操作一模一样，详见 Arch Linux 从零开始安装 的“网络配置”部分，这里不再赘述。\n配置 SSH 连接首先使用 pacman -Syy 更新一下软件包数据库，然后安装 openssh，启动 ssh 服务并设置开机自启：\npacman -S opensshsystemctl start sshdsystemctl enable sshd\n\n最后我们修改一下配置文件允许 root 用户登录（openssh 现在默认禁止 root 用户登录）:\nvim &#x2F;etc&#x2F;ssh&#x2F;sshd_config\n\n将 #PermitRootLogin prohibit-password 这一行修改为 PermitRootLogin yes 后保存即可。\n全部弄好之后重启一下就能够使用 ssh 工具连接机器了，接下来就可以尽情的定制属于自己的 Arch Linux 啦！\n","categories":["技术教程"],"tags":["Linux","系统安装","Arch Linux"]},{"title":"PIL.Image 和 OpenCV 图像格式互转","url":"/2020/212/","content":"最近做一些图像处理的时候经常用到 PIL.Image 和 OpenCV 这两个东西。\n稍微有点了解的应该都清楚，这两个库在图像处理方面很多功能类似，但是它们读取图片的格式却是不一样的，这就导致在混用一些图像处理工具的时候经常需要进行格式转换，在这里记录一下两种格式互转的方法。\n\n\nPIL.Image 转换成 OpenCV 格式import cv2from PIL import Imageimport numpy pil_im = Image.open(&quot;image.jpg&quot;)cv2_im = cv2.cvtColor(numpy.asarray(pil_im),cv2.COLOR_RGB2BGR)\n\n由于 PIL.Image 使用的颜色模式是 RGB ，而 OpenCV 使用的是 BGR ，所以我们在二者间进行格式转换的时候使用了 cv2.COLOR_RGB2BGR 控制颜色模式的转换。\nOpenCV 转换成 PIL.Image 格式import cv2  from PIL import Image  import numpy  cv2_im = cv2.imread(&quot;image.jpg&quot;)  pil_im = Image.fromarray(cv2.cvtColor(cv2_im,cv2.COLOR_BGR2RGB))  \n\n同上，使用 cv2.COLOR_BGR2RGB 控制颜色模式的转换。\n","categories":["学习笔记"],"tags":["Python","图像处理"]},{"title":"RSA 密码体制简记","url":"/2020/216/","content":"RSA 密码体制定义设 $n=p q$ ，其中 $p, q$ 为素数。设 $P=C=\\mathbb{Z}_{n}$ ，且定义 $K={(n, p, q, a, b): a b \\equiv 1 \\bmod \\phi(n)}$ 。对于 $k=(n, p, q, a, b), x, y \\in \\mathbb{Z}_{n}$ ，定义加密和解密分别为：$$e_{k}(x)=x^{b} \\bmod n,\\quad d_{k}(y)=y^{a} \\bmod n$$值 $(n, b)$ 组成了公钥，$(p, q, a)$ 组成了私钥。\n\n\n安全性RSA 密码体制的安全性基于相信加密函数 $e_{k}(x) \\equiv x^{b} \\bmod n$ 是一个（陷门）单向函数 [1] 。允许解密的陷门是分解 $n=p q$ 。\n若知道这个分解，则可计算 $\\phi(n)=(p-1)(q-1)$ ，由于 $a b \\equiv 1 \\bmod \\phi(n)$ ，即 $a \\equiv b^{-1} \\bmod \\phi(n) $ ，进而可以利用扩展 Euclidean 算法 [2] 来计算解密指数 $a$ 。\n[1] 单向函数：一个函数容易计算但难于求逆。陷门单向函数：一个单向函数在具有特定的陷门知识后容易求逆。[2] 扩展 Euclidean 算法：欧几里得算法的扩展，可以用来求模的逆元。 百度词条\n加解密示例假定 $p=101, q=113$ ，则 $n=11413, \\phi(n)=100 \\times 112=11200$ 。若 Bob 选取 $b=3533$ ，则可计算 $a=b^{-1} \\equiv 6597 \\bmod 11200$ 。于是 Bob 发布公钥 $(n, b)$ ，保留私钥 $(p, q, a)$ 。\n若 Alice 想加密明文 $x=9726$ 并发送给 Bob 密文 $y$ ，她将计算 $y=9726^{3533} \\bmod 11413 \\equiv 5761$ 。\nBob 收到密文 $y$ 后利用私钥中的解密指数来计算 $x=5761^{a}=5761^{6597} \\bmod 11413 \\equiv 9726$ 。\n","categories":["学习笔记"],"tags":["数学","密码学","非对称加密"]},{"title":"ElGamal 密码体制简记","url":"/2020/217/","content":"离散对数问题给定乘法群 $(G, \\quad\\cdot)$ ，一个 $n$ 阶元素 $\\alpha \\in G$ 和元素 $\\beta \\in\\langle\\alpha\\rangle$ 。要求找到惟一的整数 $a,0 \\leq a \\leq n-1$ ，满足 $\\alpha^{a}=\\beta$ 。一般将这个整数 $a$ 记为 $a=\\log _{\\alpha} \\beta$ 。\n通常取 $G$ 为有限域 $\\mathbb{Z}_{p}$ 的乘法群（$p$ 为素数），$\\alpha$ 为模 $p$ 的本原元，这时 $n=|\\langle\\alpha\\rangle|=p-1$ 。或取 $\\alpha$ 为乘法群 $\\mathbb{Z}_{p}^{*}$ 的一个素数 $q$ 阶元素，$q | p-1$ 。\n\n\nElGamal 密码体制定义考虑 $\\mathbb{Z}_{p}^{*}$ 上的情况，设 $p$ 是一个素数，使得 $\\left(\\mathbb{Z}_{p}^{*}, \\quad\\cdot\\right)$ 上的离散对数问题是难解的，令 $\\alpha \\in \\mathbb{Z}_{p}^{*}$ 是一个本原元。另 $P=\\mathbb{Z}_{p}^{*}, C=\\mathbb{Z}_{p}^{*} \\times \\mathbb{Z}_{p}^{*}$ ，定义$$K=\\left\\{(p, \\alpha, a, \\beta): \\beta \\equiv \\alpha^{a} \\bmod p\\right\\}$$其中 $(p, \\alpha, \\beta)$ 是公钥， $a$ 是私钥。对 $k=(p, \\alpha, a, \\beta)$ ，以及一个秘密的随机数 $s \\in \\mathbb{Z}_{p-1}$ ，定义加密$$e_{k}(x, s)=\\left(y_{1}, y_{2}\\right),\\quad y_{1}=\\alpha^{s} \\bmod p,\\quad y_{2}=x \\beta^{s} \\bmod p$$对 $y_{1}, y_{2} \\in \\mathbb{Z}_{p}^{*}$ ，定义解密$$d_{k}\\left(y_{1}, y_{2}\\right)=y_{2}\\left(y_{1}^{a}\\right)^{-1} \\bmod p$$注意： 这里我们在加密时使用了一个随机选取的变量 $s$ ，但是解密时并不需要知道这一参数。更换 $s$ 的值，可以为同一段明文生成多个不同的密文，但这对解密过程没有任何影响。\n加解密示例设 $p=2597$ ，$\\alpha=2$ 是模 $p$ 的本原元。令 $a=765$ ，则可以算出 $\\beta=2^{765} \\bmod 2579=949$ 。于是 Bob 发布公钥 $(p, \\alpha, \\beta)$ ，保留私钥 $a$ 。\n若 Alice 想加密明文 $x=1299$ 并发送给 Bob 密文 $y$ ，选择随机数 $s=853$ （由 Alice 随机选取，不需要告诉 Bob），她将计算$$y_{1}=2^{853} \\bmod p=435,\\quad y_{2}=1299 \\cdot 949^{853} \\bmod p=2396$$于是密文为 $y=(435,2396)$ 。\nBob 收到密文 $y$ 后利用私钥 $a$ 来解密：$x=2396 \\cdot\\left(435^{765}\\right)^{-1} \\bmod p=1299$ 。\n","categories":["学习笔记"],"tags":["数学","密码学","非对称加密"]},{"title":"记一次参与 JetBrains Quest 活动的过程","url":"/2020/310/","content":"JetBrains 公司是干啥的自然不用我多说，无意中得知 JetBrains Quest 活动的消息，就也手痒的参与了一把。题目不难，一步步探索、揭晓谜底的过程还是挺有趣的，在这里简单记录一下本次解谜的过程。\n注： 最后到手的奖励是三个月的全产品订阅，不得不说 JetBrains 在优惠活动方面从来没让人失望过。\n\n\n第一步，读懂题目先来看看 JetBrains 发布活动消息的这则推文：\n\n从中我们得到了如下的一串字符：\n48 61 76 65 20 79 6f 75 20 73 65 65 6e 20 74 68 65 20 73 6f 75 72 63 65 20 63 6f 64 65 20 6f 66 20 74 68 65 20 4a 65 74 42 72 61 69 6e 73 20 77 65 62 73 69 74 65 3f\n\n观察发现，字符串中同时包含数字和字母，但是字母最大只有 f （按 a 最小，z 最大排序），这是很明显的 16 进制字符串的特征。\n尝试一下把上面每个数字按 16 进制转成 10 进制，然后再根据 ASCII 码表取出对应的字符（肯定是写个脚本来自动转换啦），我们得到了如下的一句话：Have you seen the source code of the JetBrains website? 。嗯，让我们看看 JetBrains 网站的源码，那就来看看呗。\n第二步，源码中的信息打开 https://www.jetbrains.com/ ，右键查看网页源码，用鼠标拉动滑块快速的扫过去，很快发现在第400行附近有如下的一段注释：\n      O&#123;o)xxx|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-      OWelcome to the JetBrains Quest.What awaits ahead is a series of challenges. Each one will require a little initiative, a little thinking, and a whole lot of JetBrains to get to the end. Cheating is allowed and in some places encouraged. You have until the 15th of March at 12:00 CET to finish all the quests.Getting to the end of each quest will earn you a reward.Let the quest commence!JetBrains has a lot of products, but there is one that looks like a joke on our Products page, you should start there... (hint: use Chrome Incognito mode)It’s dangerous to go alone take this key: Good luck! &#x3D;&#x3D; Jrrg#oxfn$                 O-&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|xxx(o&#125;                 O\n\n这里给出了活动截止时间等信息，还有一条下一步的提示 —— 产品页面有一个看起来像玩笑的应用，我们需要从那里开始（提示：使用 Chrome 隐身模式）。\n第三步，奇怪的应用根据上一步的提示，我们来到产品页面：https://www.jetbrains.com/products.html\n凭着对 JetBrains 产品的印象和大胆猜测，很快锁定了那个看起来像开玩笑的应用：\n\n点击 Learn more ，页面上弹出了一个窗口，内容如下：\nYou have discovered our JetBrains Quest! If you don’t know what this is, you should start from Twitter, Facebook or LinkedIn.To continue to the next challenge you need to go to the following link… But there is a problem, the last 3 digits are missing:https:&#x2F;&#x2F;jb.gg&#x2F;###To get these digits you need to know how many prime numbers there are between 500 and 5000Good Luck!\n\n很明显，我们找对了地方，并再次获得了下一步的提示 —— 一个残缺的链接，后面三位是 500 到 5000 内素数的个数。\n第四步，素数的个数根据上一步的提示，我们随便撸一段脚本计算一下 500 到 5000 内素数的个数，发现结果是 574，于是我们访问链接 https://jb.gg/574 进入下一步。\n页面最终跳转到了 https://www.jetbrains.com/help/pycharm/getting-help.html#quest ，这次给了一张图片作为提示。注意到了图片上的如下部分：\n\n那个“YT”的标志是 JetBrains 的产品 YouTrack，另外，对 JetBrains 稍微了解深入一点的人应该能意识到“MPS-31816”是一个 Issues 号。根据这些信息，配合搜索引擎，我们找到了如下页面：https://youtrack.jetbrains.com/issue/MPS-31816 。下面是页面上所给出的信息：\n“The key is to think back to the beginning.” -- The JetBrains Quest teamQlfh$#Li#|rx#duh#uhdglqj#wklv#|rx#pxvw#kdyh#zrunhg#rxw#krz#wr#ghfu|sw#lw1#Wklv#lv#rxu#lvvxh#wudfnhu#ghvljqhg#iru#djloh#whdpv1#Lw#lv#iuhh#iru#xs#wr#6#xvhuv#lq#Forxg#dqg#iru#43#xvhuv#lq#Vwdqgdorqh&#x2F;#vr#li#|rx#zdqw#wr#jlyh#lw#d#jr#lq#|rxu#whdp#wkhq#zh#wrwdoo|#uhfrpphqg#lw1#|rx#kdyh#ilqlvkhg#wkh#iluvw#Txhvw&#x2F;#qrz#lw“v#wlph#wr#uhghhp#|rxu#iluvw#sul&#125;h1#Wkh#frgh#iru#wkh#iluvw#txhvw#lv#‟WkhGulyhWrGhyhors†1#Jr#wr#wkh#Txhvw#Sdjh#dqg#xvh#wkh#frgh#wr#fodlp#|rxu#sul&#125;h1#kwwsv&#x3D;22zzz1mhweudlqv1frp2surpr2txhvw2\n\n至此，我们得到了一长串的奇怪字符串外加一句话 —— 关键是要回过头去思考。\n第五步，早已给出的提示有没有觉得上面那些字符排列的方式有点眼熟？没错，还记得我们在第二步拿到的线索吗？还有一句话没用上。\nIt’s dangerous to go alone take this key: Good luck! &#x3D;&#x3D; Jrrg#oxfn$\n\n最后这个 Jrrg#oxfn$ 跟上面的字符串是不是有点同出一辙的感觉，再结合提示信息“回过头去思考”，我们这不就是回头来寻找线索吗？基本能够确定这一句话就是关键。\n我们来简单分析一下，最先注意到的就是 == ，这是编程语言中的“等于”，提醒我们 Good luck! 和 Jrrg#oxfn$ 相等；数一下两者字符的个数，发现都是 10 个（包括空格）；再注意到相同字符变换后对应的字符不变（前者两个连续的 o 在后者中就对应两个连续的 r ）。\n基于上面这些分析，大胆猜测这是某种基于单个字符的加密方式，再配合一点直觉和实际的操作尝试，嗯，很典型的凯撒密码。简单来说，这里所用的加密操作就是将每个字符在 ASCII 码表中的值 +3，再取出新的值对应的字符。\n知道了这一点之后再去解密上面的长字符串就很简单了，反过来将每个字符的 ASCII 值减 3 ，然后取出对应的字符，下面是最终解密出来的信息：\nNice! If you are reading this you must have worked out how to decrypt it. This is our issue tracker designed for agile teams. It is free for up to 3 users in Cloud and for 10 users in Standalone, so if you want to give it a go in your team then we totally recommend it. you have finished the first Quest, now it’s time to redeem your first prize. The code for the first quest is “TheDriveToDevelop”. Go to the Quest Page and use the code to claim your prize. https:&#x2F;&#x2F;www.jetbrains.com&#x2F;promo&#x2F;quest&#x2F;\n\n根据该信息，我们已经成功完成了本次 JetBrains Quest 的所有流程（这只是第一个 Quest ，后续还有其他挑战），接下来就就可以去领取奖励啦：打开 https://www.jetbrains.com/promo/quest/ ，输入你的邮箱和解密信息中的 Code：TheDriveToDevelop ，稍等一会儿就会收到一封包含 3 个月全产品订阅兑换码的邮件，下面是我收到邮件的部分截图（去除了关键信息，只是邮件的上半部分）。\n\n更新：第二轮活动开始题目详见：https://twitter.com/jetbrains/status/1237694815283879943\n这里不会再记录详细解密过程（包括本次活动后续的题目），虽然我已经拿到奖励啦~~~\n更新：最后一轮活动开始题目详见：https://twitter.com/jetbrains/status/1238420744817782784\n需要注意的是，与前面两次的三个月全产品订阅不同，这次的奖励是全产品订阅的八折优惠码。\n","categories":["趣味分享"],"tags":["字符编码","JetBrains","解谜"]},{"title":"测试 TCP BBR 对网络丢包的改善效果","url":"/2020/322/","content":"TCP BBR 出来已经有挺长一段时间了，都说它可以减少 TCP 连接的延迟、改善存在丢包的网络环境速度，虽然我自己一直在用，但由于从来没有测试过，所以对它具体能发挥多大的作用还是存疑的。\n正好最近了解到了一个命令 tc ，可以模拟网络延迟和丢包，于是决定来亲自测试一下 BBR 对网络丢包的改善效果。\n\n\nTCP BBR 开启和关闭的教程可以查看之前的文章：内核版本 4.9 以上的 Linux 系统开启/关闭 BBR 的方法\n测试环境为了获得充足的网速以便能够看到明显效果，同时排除其他环境因素的影响，本次测试在本地回环地址 127.0.0.1 上进行。输入 ifconfig 可以查看网卡情况，我这里绑定地址 127.0.0.1 的网卡名为 lo 。\n在本地起一个监听 127.0.0.1 的 http 服务（我这里是用 caddy 实现的），然后在其中放一个比较大的文件（我这里是一个 600 多兆的系统镜像），后续将通过 wget 下载该文件来测试网络速度。\n为了避免硬盘本身写入速度的限制，这里直接将文件 wget 到内存当中去（使用内存设备文件 /dev/shm ）\n模拟丢包网络环境这里使用 tc 命令来模拟所需要的网络环境，该命令的具体用法不再多说，自己输入 man tc 查看即可。\n执行以下命令可以在网卡 lo 上模拟 10% 的丢包：\ntc qdisc add dev lo root netem loss 10%\n\n要恢复正常情况的话执行以下命令即可：\ntc qdisc del root dev lo\n\n测试过程及结果先进入内存设备文件：\ncd &#x2F;dev&#x2F;shm\n\n使用以下命令从回环地址 127.0.0.1 的 http 服务中下载文件进行测速：\nwget http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;debian-10.3.0-amd64-xfce-CD-1.iso\n\n不开启 BBR 的结果不开启 BBR ，在正常（无丢包）网络环境下的测试结果如下图，640M 的文件下载花了 0.7s ，还是很快的。\n\n不开启 BBR ，在 1% 丢包网络环境下的测试结果如下图，640M 的文件花了 5.5s 下完，相比正常情况下的网络速度有一定程度降低。\n\n不开启 BBR ，在 10% 丢包网络环境下的测试结果如下图，可以看到同样 640M 的文件下载花了 50s ，相比正常情况下网络速度发生了大幅度降低。\n\n开启 BBR 的结果开启 BBR ，在正常（无丢包）网络环境下的测试结果如下图，640M 的文件同样花了 0.7s 下完，跟不开启 BBR 时的速度没有差别。\n\n开启 BBR ，在 1% 丢包网络环境下的测试结果如下图，640M 的文件还是花了 0.7s 下完，跟正常网络环境下的速度几乎一样，这相比同样 1% 丢包网络环境但不开启 BBR 时的 5.5s 有很大的提升。\n\n开启 BBR ，在 10% 丢包网络环境下的测试结果如下图，可以看到同样 640M 的文件下载花了 7.5s ，这虽然没有前面跟正常网络环境下速度几乎一样那么恐怖，但相比同样 10% 丢包网络环境不开启 BBR 时的 50s 还是有很大程度提升的。\n \n结果总结上面的测试通过一个简单的场景来验证了 TCP BBR 对于丢包情况下网络速度的优化。从结果中可以看到 TCP BBR 对于网络丢包的改善效果十分显著，在少量丢包的情况下甚至可以做到与正常网络环境速度无异，虽然在大量丢包时速度仍会下降，但跟不开启 BBR 的情况相比还是有很大的提升（比不开启 BBR 的情况速度降得更少）。\n所以，如果你的机器、网络环境存在丢包导致跑不满带宽的话，不妨开启 BBR 试一下吧！\n","categories":["趣味分享"],"tags":["BBR","常用命令","测试"]},{"title":"Python 使用 SMTP 发送邮件","url":"/2020/414/","content":"SMTP 全称为 Simple Mail Transfer Protocol，即简单邮件传输协议，它是一组用于从源地址到目的地址传送邮件的规则，同时会控制信件的中转方式，一般我们发送邮件都是通过这一协议来完成的。\nPython 内置的 smtplib 模块对 SMTP 协议进行了简单的封装，借助它我们可以很轻松的实现用代码来发送邮件。\n\n\n连接 SMTP 服务器要发送邮件，很明显需要先连接到一个可用的邮件服务器，为此我们需要指定服务器地址和端口。\n由于各种历史遗留问题，现在仍在使用的 SMTP 服务端口有三个，分别是：25端口（明文传输）、465端口（SSL 加密）和 587端口（STARTTLS 加密）。不同的端口处理情况稍有不同，下面在代码中分别演示三种端口的连接方式。\nimport smtplib# 25端口（明文传输）smtp_server = smtplib.SMTP(host=&quot;smtp.xxx.xxx&quot;, port=25)# 465端口（SSL加密）smtp_server = smtplib.SMTP_SSL(host=&quot;smtp.xxx.xxx&quot;, port=465)# 587端口（STARTTLS加密）smtp_server = smtplib.SMTP(host=&quot;smtp.xxx.xxx&quot;, port=587)smtp_server.starttls()\n\n登录 SMTP 服务器连上服务器之后还需要用我们的邮箱登录才能发送邮件（注意 QQ 邮箱、163 邮箱等使用 SMTP 服务需要的密码是在后台申请的授权码，不是你在网页上登录邮箱时用的密码）。\nsmtp_server.login(user=&quot;test@xxx.xxx&quot;, password=&quot;test_password&quot;)\n\n构造邮件电子邮件本质上可以看作一种按特定格式组织的文本文件，除了正文内容之外，标准邮件一般还需要三个头部信息： From（发件人）, To（收件人）和 Subject（邮件主题）。所以说发送邮件并不是将你想发的内容传过去就行了，我们还需要先按照一定的规则“构造”一封邮件。\n常见的邮件主要有纯文本邮件、HTML 邮件、带附件的邮件几种类型，下面分别演示这三种类型邮件的构造方式。\n纯文本邮件from email.mime.text import MIMETextcontent = &quot;这是一封纯文本邮件&quot;subject = &quot;纯文本邮件测试&quot;from_user = &quot;test@xxx.xxx&quot;to_user = &quot;test2@xxx.xxx&quot;# 构造邮件主体my_mail = MIMEText(content, _subtype=&quot;plain&quot;, _charset=&quot;utf8&quot;)# 添加发件人my_mail[&quot;From&quot;] = from_user# 添加收件人my_mail[&quot;To&quot;] = to_user# 添加邮件主题my_mail[&quot;subject&quot;] = subject\n\nHTML 邮件构造 HTML 邮件只需要将构造纯文本邮件代码中 MIMEText() 的 _subtype 参数修改为 html 即可，如下：\nmy_mail = MIMEText(content, _subtype=&quot;html&quot;, _charset=&quot;utf8&quot;)\n\n带附件的邮件带附件的邮件与上面两种稍有不同，我们需要借助 MIMEMultipart() 构造一封多组件邮件，再将文本内容、附件内容依次添加进去，代码如下：\nfrom email.mime.application import MIMEApplicationfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextcontent = &quot;这是一封带附件的邮件&quot;subject = &quot;带附件的邮件测试&quot;from_user = &quot;test@xxx.xxx&quot;to_user = &quot;test2@xxx.xxx&quot;file_path = &quot;xxx/test.txt&quot;   # 附件所在的路径file_name = &quot;test.txt&quot;   # 附件在邮件中显示的文件名file_content = open(file_path, &quot;rb&quot;).read()  # 读取附件内容# 构造一封多组件的邮件my_mail = MIMEMultipart()# 往多组件邮件中加入文本内容text_msg = MIMEText(content, _subtype=&quot;plain&quot;, _charset=&quot;utf8&quot;)my_mail.attach(text_msg)# 往多组件邮件中加入附件file_msg = MIMEApplication(file_content)file_msg.add_header(&quot;content-disposition&quot;, &quot;attachment&quot;, filename=file_name)my_mail.attach(file_msg)# 添加发件人my_mail[&quot;From&quot;] = from_user# 添加收件人my_mail[&quot;To&quot;] = to_user# 添加邮件主题my_mail[&quot;subject&quot;] = subject\n\n发送邮件构造好了邮件，连接并登录了 SMTP 服务器，接下来要发送邮件就很简单了，直接调用 send_message() 函数即可。\n# 连接到服务器并登录好的SMTP对象smtp_server = ......# 前面构造好的邮件my_mail = ......# 发件人邮箱from_user = &quot;test@xxx.xxx&quot;# 收件邮箱to_user = &quot;test2@xxx.xxx&quot;# 发送邮件smtp_server.send_message(my_mail)\n\n封装邮件发送方法像上面这样一步步构造邮件、发送邮件，写一次还好，经常需要这样写的话还是有点繁琐的，所以我们来给它稍微封装一下，以后直接调用即可：\nimport osimport smtplibimport emailfrom email.mime.application import MIMEApplicationfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextclass MailSender(object):    &quot;&quot;&quot;    邮件发送器，封装smtp发送邮件的常用操作    &quot;&quot;&quot;    def __init__(self, user: str, password: str, host: str, port: int):        &quot;&quot;&quot;        初始化smtp服务器连接        :param user: 邮箱用户，支持 name&lt;prefix@example.com&gt; 的形式，会自动从中提取邮箱地址用于登录        :param password: smtp登录密码        :param host: smtp服务器地址        :param port: smtp服务器端口，仅能使用25、465和587        &quot;&quot;&quot;        self.__user = user        # 提取出邮箱地址用于登录        self.__login_mail = email.utils.getaddresses([user])[0][1]        # 连接到smtp服务器，限制只允许使用25、465、587这三个端口        if port == 25:            self.__smtp_server = smtplib.SMTP(host=host, port=port)        elif port == 465:            self.__smtp_server = smtplib.SMTP_SSL(host=host, port=port)        elif port == 587:            self.__smtp_server = smtplib.SMTP(host=host, port=port)            self.__smtp_server.starttls()        else:            raise ValueError(&quot;Can only use port 25, 465 and 587&quot;)        # 登录smtp服务器        self.__smtp_server.login(user=self.__login_mail, password=password)    def send(        self, to_user: str, subject: str = &quot;&quot;, content: str = &quot;&quot;, subtype: str = &quot;plain&quot;    ):        &quot;&quot;&quot;        发送纯文本邮件        :param to_user: 收件人，支持 name&lt;prefix@example.com&gt; 的形式，如需同时发给多人，将多个收件人用半角逗号隔开即可        :param subject: 邮件主题，默认为空字符串        :param content: 邮件正文，默认为空字符串        :param subtype: 邮件文本类型，只能为 plain 或 html，默认为 plain        &quot;&quot;&quot;        self.__check_subtype(subtype)        # 构造邮件        msg = MIMEText(content, _subtype=subtype, _charset=&quot;utf-8&quot;)        msg[&quot;From&quot;] = self.__user        msg[&quot;To&quot;] = to_user        msg[&quot;subject&quot;] = subject        # 发送邮件        self.__smtp_server.send_message(msg)    def send_with_attachment(        self,        to_user: str,        attachment_path: str,        attachment_name: str = &quot;&quot;,        subject: str = &quot;&quot;,        content: str = &quot;&quot;,        subtype: str = &quot;plain&quot;,    ):        &quot;&quot;&quot;        发送带附件的邮件        :param to_user: 收件人，支持 name&lt;prefix@example.com&gt; 的形式，如需同时发给多人，将多个收件人用半角逗号隔开即可        :param attachment_path: 附件文件的路径        :param attachment_name: 附件在邮件中显示的名字，设为空字符串时（默认）直接使用文件名        :param subject: 邮件主题，默认为空字符串        :param content: 邮件正文，默认为空字符串        :param subtype: 邮件文本类型，只能为 plain 或 html，默认为 plain        &quot;&quot;&quot;        self.__check_subtype(subtype)        # 读取附件内容        with open(attachment_path, &quot;rb&quot;) as f:            file_content = f.read()        # 默认以文件名作为附件名        if attachment_name == &quot;&quot;:            attachment_name = os.path.basename(attachment_path)        # 构造一封多组件邮件        msg = MIMEMultipart()        # 添加文本内容        text_msg = MIMEText(content, _subtype=subtype, _charset=&quot;utf-8&quot;)        msg.attach(text_msg)        # 添加附件        file_msg = MIMEApplication(file_content)        file_msg.add_header(            &quot;content-disposition&quot;, &quot;attachment&quot;, filename=attachment_name        )        msg.attach(file_msg)        msg[&quot;From&quot;] = self.__user        msg[&quot;To&quot;] = to_user        msg[&quot;subject&quot;] = subject        # 发送邮件        self.__smtp_server.send_message(msg)    def __check_subtype(self, subtype: str):        if subtype not in (&quot;plain&quot;, &quot;html&quot;):            raise ValueError(&#x27;Error subtype, only &quot;plain&quot; and &quot;html&quot; can be used&#x27;)        else:            pass\n\n调用时只需要先实例化一个 MailSender 对象，然后就可以使用对应的 send 函数来发送邮件了：\nif __name__ == &quot;__main__&quot;:    test_msg = &quot;&quot;&quot;    &lt;p&gt;邮件发送测试&lt;/p&gt;    &lt;p&gt;&lt;a href=&quot;https://xirikm.net/&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt;    &quot;&quot;&quot;    attachment_path = &quot;xxx/xxx.txt&quot;  # 附件的文件路径    sender = MailSender(&quot;test@xxx.xxx&quot;, &quot;test_password&quot;, &quot;smtp.xxx.xxx&quot;, 587)    sender.send(&quot;test2@xxx.xxx&quot;, &quot;纯文本邮件&quot;, test_msg, &quot;plain&quot;)    sender.send(&quot;test2@xxx.xxx&quot;, &quot;html邮件&quot;, test_msg, &quot;html&quot;)    sender.send_with_attachment(        &quot;test2@xxx.xxx&quot;, attachment_path, &quot;xxx.txt&quot;, &quot;带附件的html邮件&quot;, test_msg, &quot;html&quot;    )    # 默认参数测试    sender.send_with_attachment(&quot;test2@xxx.xxx&quot;, attachment_path)\n","categories":["技术教程"],"tags":["Python","邮件","SMTP"]},{"title":"解决腾讯云服务器内存不足量的问题","url":"/2020/524/","content":"腾讯云服务器安装 Debian 或 Ubuntu 系统后使用 free 命令查看内存大小往往会发现比所购买配置的标称内存要小很多，1G 内存的实例通常只有 860M 左右，2G 内存的查出来也只有 1870M 左右。\n\n\n如下图所示（2G 内存）：\n\n一开始我也和大多数人想的一样，认为这是黑心商家为了多赚钱故意少分配了内存，然而最近了解了一下情况之后发现这事还真是误会腾讯云了，下面简单的记录一下问题原因和解决方案吧。\n问题原因使用命令 dmidecode 查看底层硬件信息，可以看到我的 2G 内存的服务器是分配足了 2048M 内存的。\n\n但是为什么使用 free 命令看到的内存变少了呢？查阅资料找到了答案：free 命令看到的是伙伴系统管理的内存，这部分内存是不包括 OS 内核一些基本数据结构消耗以及内核预留内存的。\n使用命令 dmesg | grep -i memory 查看内核预留内存，注意到如下部分：\n\n嗯，为 crashkernel 预留了 128M 的内存，很明显这就是导致我们“内存不足量”的罪魁祸首。\n腾讯云提供的 Debian 和 Ubuntu 系统镜像默认开启了 kdump 服务，当 Linux 内核出现了故障时 kdump 会协助产生一个 dump 文件，记录下此时的内存运行参数等信息，便于用户后续对内核问题的定位分析。而上面提到的“为 crashkernel 预留的内存”就是用于这一服务的，也就是导致我们“内存不足量”的元凶。\n这一服务对于那些注重安全的大公司来说可能会有些用处，但我们这种个人用途的低配置服务器也开着的话就没有什么必要了，本身内存就不大，还要为这服务分出去一部分不能用，想想还是有点浪费的。\n解决方案既然问题是由于系统为 kdump 服务预留了一部分内存导致的，那我们把 kdump 服务关了就行了。\n暴力点，直接卸载 kdump-tools：\napt purge kdump-tools\n\n卸载后顺便清理一下它的那些已经用不到了的依赖包：\napt autoremove\n\n然后编辑 /etc/default/grub 文件，将其中的 crashkernel=xxx 字段全部删掉，我这里的修改情况如下：\n# 待修改的两行配置GRUB_CMDLINE_LINUX_DEFAULT=&quot;crashkernel=384M-:128M&quot;GRUB_CMDLINE_LINUX=&quot;net.ifnames=0 biosdevname=0 console=ttyS0,115200 console=tty0 panic=5 crashkernel=auto&quot;# 修改后的配置GRUB_CMDLINE_LINUX_DEFAULT=&quot;&quot;GRUB_CMDLINE_LINUX=&quot;net.ifnames=0 biosdevname=0 console=ttyS0,115200 console=tty0 panic=5&quot;\n\n修改完之后执行 update-grub2 更新 grub 引导文件，最后再重启一下服务器就可以啦！\n如下图所示，重启后可用内存变成了 2004M（比之前多了 128M）：\n\n","categories":["技术教程"],"tags":["Linux","内存","腾讯云"]},{"title":"Python 中的那些官方彩蛋","url":"/2020/719/","content":"最近比较忙，都没怎么碰过博客，刚刚发现好像已经有将近两个月没有更新了，赶紧过来发水一篇压压惊。\n彩蛋一：antigravityantigravity 翻译过来是反重力、反引力的意思，在 Python 中 import antigravity 会自动打开一个 Python 的经典 XKCD 漫画页面：https://xkcd.com/353/\n\n\n\nXKCD 是由兰德尔·门罗（Randall Munroe）所绘制的网络漫画，他给作品的定义是一部“关于浪漫、讽刺、数学和语言的网络漫画”。上面的这幅漫画就是在表现 Python 的简单易用，飞一般的感觉，翻译如下：\n\nA：你在飞！怎么做到的？B：Python！我昨晚刚刚学会了 Python。一切都变得如此简单！写一个 Hello World 程序只要一行代码 print “Hello World!” 就搞定了！A：什么情况？呃……动态类型？泛空格符？B：来加入我们吧，有了 Python，编程再次变得有趣。这是一个全新的世界！A：但是你到底是怎么飞在天上的？B：我只是输入了“import antigravity”命令而已。A：就这样？B：我还把药柜中的药嗑了个遍……但我觉得还是 Python 的原因。\n\n这个模块是 Python 开发人员发布的少数复活节彩蛋之一。不止如此，在这个复活节彩蛋中还有另一个彩蛋：如果你看一下该模块的代码，就会发现其中还有一个函数实现了另一则 XKCD 漫画中的 geohashing 算法。\n彩蛋二：this在 Python 标准库中有一个叫做 this 的模块，导入这个模块会输出著名的“Python 之禅”的内容，除此之外没有任何其他功能，如下图：\n\n这是一个关于 Python 之禅的复活节彩蛋（PEP 20），有兴趣的可以自己去看看它的实现代码。有趣的是，这个输出 Python 之禅的代码似乎自己违反了 Python 之禅。\n彩蛋三：__future__在 Python 中 __future__ 模块通常会提供一些未来版本的功能，比如 from __future__ import print_function 可以让你在 Python2 中使用 Python3 的 print()。\n如果你不喜欢在 Python 中使用空格来表示作用域，试试导入 C 语言风格的 &#123;&#125; ？使用代码 from __future__ import braces （大括号的英文为 braces），很遗憾，你会得到如下报错：SyntaxError: not a chance，没有机会这样做。\n\n这是一个表达社区对此类问题态度的复活节彩蛋。不要想着这样做了，没有机会的。\n","categories":["逸趣杂谈"],"tags":["Python","杂谈","彩蛋"]},{"title":"博客迁移（升级）说明","url":"/2021/403/","content":"前段时间因为自己忙于其他的事情，再加上懒，博客鸽了有大半年没有更新。最近终于闲下来了，重新折腾一下，把博客彻底的“翻新”了一遍，也算是一个新的开始吧。\n本次“翻新”对 Hexo 和 NexT 主题的版本进行了升级，更换了域名，重新设计（调整）了主题样式，包括博客名称之类的也进行了更换，变动可谓是相当的大。\n\n\n主要变动这次博客的“翻新”并不是传统意义上升级的那种形式，而是直接建了一个新的博客，然后把原博客的文章搬过来，这也是标题中我把这个过程叫做“迁移”的主要原因。下面简单的列举一下主要的变动项吧：\n\n博客域名：xirikm.net -&gt; blog.inkuang.com\n博客名称：昔日的夕日 -&gt; Ming&#39;s Blog\n博主昵称： 夕日 -&gt; Ming\nHexo 版本：3.x -&gt; 5.x\nNexT 主题版本：7.1.0 -&gt; 8.x\n主题样式修改：都是自己魔改的，没有具体名字\n\n总的来说，这次“翻新”的变动还是挺大的，完全可以当作是一个全新的博客了，只是两个博客的博主是同一个人而已。\n扔掉旧的包袱，站在新的起点，迎接一个新的开始！\n旧文章处理在本文发布后，“旧博客”那边会发布一篇类似的文章，然后正式停更，后续的文章更新都在这个“新博客”进行。\n我会将旧博客的大部分文章迁移过来，但不是全部。那些我认为没什么意义的，或者跟旧博客本身高度相关的文章（如博客日志、更新情况之类的），就让它们随着旧博客一起消亡吧。\n旧博客站点将会继续保留到其域名过期或者服务器到期，其中已迁移的那些文章会进行重定向操作，将其链接跳转到这个新博客中对应的文章。\n","categories":["博客日志"],"tags":["Hexo","博客"]},{"title":"使用 gulp 压缩 Hexo 博客文件（兼容 ES6 标准）","url":"/2021/405/","content":"使用文本编辑器打开 Hexo 生成的博客文件，往往会发现其中存在大量的空格与空行，这虽然不影响代码发挥作用，但却会在一定程度上增加文件的大小。\n实际上不止空白，这些由 Hexo 生成的文件中还有很多能够被优化以减小大小的地方，而要提高网站访问速度，减小资源文件的大小一直是最有效的手段之一。\n\n\ngulp 是一个自动化构建工具，一般用于开发过程中执行一些常见任务，它有很多社区提供的强大插件可供使用，极大的简化了任务处理流程。在这里我们用它来对 Hexo 生成的博客文件进行压缩优化处理。\n其他教程存在的问题使用关键词 hexo gulp 在网上搜索，可以搜到一堆类似的教程，但是根据我的实际测试，网上搜到的这些教程大部分都已经过时了，现在再使用的话或多或少的存在一些问题。\n这些教程中一般都是通过安装 gulp-minify-css、gulp-uglify、gulp-htmlclean、gulp-htmlmin 这几个插件来处理的。下面按照压缩任务划分，分别说明一下现在还按照这些教程操作的话存在的一些问题。\n压缩 CSS 的问题上面那几个插件中 gulp-minify-css 是用来压缩 CSS 代码的，使用命令 npm install gulp-minify-css 安装它，此时会发现在该命令的输出中存在如下的一行：\nnpm WARN deprecated gulp-minify-css@1.2.4: Please use gulp-clean-css\n\n说得很明显了，这个插件已弃用，请使用 gulp-clean-css 。这虽然并不影响我们的正常使用该插件，但是有更好的替代品的话为什么还要用这个已弃用的插件呢？\n压缩 JS 的问题网上的大部分教程都是使用 gulp-uglify 来压缩 JS 代码，然而这个插件不兼容 JS 的 ES6 标准，导致在我的实际测试中（Hexo 5.x、NexT 8.x）使用该插件时出现了报错，如下所示，最后直接是“无法压缩 JavaScript”：\n[19:31:26] &#39;minify-js&#39; errored after 489 ms[19:31:26] GulpUglifyError: unable to minify JavaScriptCaused by: SyntaxError: Unexpected token: punc «)»File: C:\\Users\\Administrator\\Desktop\\hexo\\new-blog\\public\\js\\local-search.js\n\nES6 标准在2015年6月就正式通过了，现在已经过去了这么久，很多地方都有在使用，而 gulp-uglify 这个插件却完全不兼容，这无疑是个问题。\n压缩 HTML 的问题上面提到的插件中 gulp-htmlclean 和 gulp-htmlmin 是用来压缩 HTML 代码的。\n网上教程的一般做法是先将代码传递给 gulp-htmlclean 清理掉其中的空白，然后再传递给 gulp-htmlmin 来移除注释、压缩 HTML 文件中的 CSS、JS 代码等。然而查看 gulp-htmlmin 所基于的 html-minifier 的文档发现，它有一个 collapseWhitespace 参数，设置为 true 时可以移除 HTML 代码中的空白块，那还多此一举的安装一个 gulp-htmlclean 插件干什么呢？\n另外，上面提到了 gulp-htmlmin 可以压缩 HTML 中的 JS 代码，这个功能用的是跟 gulp-uglify 一样的底层库 uglify-js 来实现的，这也就导致它同样的不兼容 ES6 标准。最终会发现 HTML 文件中的内容并没有被全部压缩成“一行”，仍有部分 JS 代码是以未被压缩的形式存在的。\n我的解决办法针对上面那些问题，在一番查找资料与实际测试后，最终还是找到了一些在我看来比较完美的解决办法：\n\n压缩 CSS： 这个是最简单的，按照它的提示换成 gulp-clean-css 这个插件就行了。\n压缩 JS： 针对这个问题网上有一种在我看来比较“邪教”的做法：使用 babel 将 ES6 标准的代码编译为 ES5 标准的代码然后再继续使用 gulp-uglify 进行压缩。怎么说呢，这样做确实是可行的，但就是看着有种不爽的感觉。经过搜索，最后找到了 gulp-uglify-es 这个插件，它将底层库替换成了 terser，可以完美支持 ES6 标准。\n压缩 HTML： 同样要解决对 ES6 标准支持的问题，最终换到了 gulp-html-minifier-terser 这个插件，它是 gulp-htmlmin 的 fork，但是将底层库换成了 html-minifier-terser（html-minifier 的 fork，将压缩 JS 代码的功能修改为了使用 terser 库处理）。其次就是不再使用 gulp-htmlclean 插件，改为在使用 gulp-html-minifier-terser 插件时传入参数 collapseWhitespace: true。\n\n操作方法及任务配置根据 gulp 及各个插件的文档，我们首先需要全局安装 gulp-cli，然后在博客工作目录下安装需要的插件：\nnpm install --global gulp-clinpm install gulp gulp-clean-css gulp-uglify-es gulp-html-minifier-terser\n\n安装完成后在博客工作目录下新建文件 gulpfile.js ，写入如下 gulp 任务配置代码（详细描述见注释）：\nconst gulp = require(&#x27;gulp&#x27;);const cleancss = require(&#x27;gulp-clean-css&#x27;);const uglify = require(&#x27;gulp-uglify-es&#x27;).default;const htmlmin = require(&#x27;gulp-html-minifier-terser&#x27;);// 压缩public目录下的css文件// 可接受参数的文档：https://github.com/jakubpawlowicz/clean-css#constructor-optionsgulp.task(&#x27;minify-css&#x27;, () =&gt; &#123;    return gulp.src(&#x27;./public/**/*.css&#x27;)           // 处理public目录下所有的css文件，下同        .pipe(cleancss(&#123; compatibility: &#x27;ie8&#x27; &#125;))  // 兼容到IE8        .pipe(gulp.dest(&#x27;./public&#x27;));&#125;);// 压缩public目录下的js文件gulp.task(&#x27;minify-js&#x27;, () =&gt; &#123;    return gulp.src(&#x27;./public/**/*.js&#x27;)        .pipe(uglify())        .pipe(gulp.dest(&#x27;./public&#x27;));&#125;);// 压缩public目录下的html文件// 可接受参数的文档：https://github.com/terser/html-minifier-terser#options-quick-referencegulp.task(&#x27;minify-html&#x27;, () =&gt; &#123;    return gulp.src(&#x27;./public/**/*.html&#x27;)        .pipe(htmlmin(&#123;            removeComments: true,                 // 移除注释            removeEmptyAttributes: true,          // 移除值为空的参数            removeRedundantAttributes: true,      // 移除值跟默认值匹配的属性            collapseBooleanAttributes: true,      // 省略布尔属性的值            collapseWhitespace: true,             // 移除空格和空行            minifyCSS: true,                      // 压缩HTML中的CSS            minifyJS: true,                       // 压缩HTML中的JS            minifyURLs: true                      // 压缩HTML中的链接        &#125;))        .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);// 默认任务，不带任务名运行gulp时执行的任务gulp.task(&#x27;default&#x27;, gulp.parallel(    &#x27;minify-css&#x27;, &#x27;minify-js&#x27;, &#x27;minify-html&#x27;));\n\n保存之后先用 hexo g 生成博客文件，然后执行命令 gulp 就可以对刚刚生成的博客文件（public 目录下的文件）进行压缩优化处理了。\n","categories":["技术教程"],"tags":["自动化","Hexo","博客"]},{"title":"Linux 下清理 systemd 日志","url":"/2021/919/","content":"Systemd 提供了自己的日志系统，称为 journal，其日志文件保存在 /var/log/journal 目录下。随着系统的长时间运行，该目录占用的空间会不断增长，默认情况下最高可达到 4G（硬盘较小时为系统总空间大小的 10%）。\n如果硬盘容量较小或者可用空间紧张，可以考虑一下清理过期的 systemd 日志来释放空间。\n\n\n手动清理可以使用如下命令检查 systemd 日志所占用的硬盘总空间大小：\njournalctl --disk-usage\n\n实际清理之前建议先 rotate 一下（存档当前所有的活跃日志文件并重命名，后续日志将被写入到新创建的空文件中）：\nsudo journalctl --rotate\n\njournalctl 命令提供了三种清理 systemd 日志的方式。第一种是清理指定时间之前的日志：\n# 清理1天之前的日志sudo journalctl --vacuum-time&#x3D;1d# 清理1小时之前的日志sudo journactl --vacuum-time&#x3D;1h# 清理10秒之前的日志sudo journalctl --vacuum-time&#x3D;10s\n\n第二种是限制日志占用的总空间大小（优先保留最近的日志）：\n# 限制systemd日志占用总空间不超过1Gsudo journalctl --vacuum-size&#x3D;1G# 限制systemd日志占用总空间不超过10Msudo journalctl --vacuum-size&#x3D;10M\n\n第三种是限制日志文件的个数（优先保留最近的日志）：\n# 保留最近的3个日志文件sudo journalctl --vacuum-files&#x3D;3\n\n持久配置使用上面的命令可以手动清理 systemd 日志，但是如果真的有需要限制 systemd 日志占用空间大小的话，一直这么手动清理肯定是不现实的。实际上我们可以通过修改配置文件来让其自动限制所占用的空间大小。\n编辑 /etc/systemd/journald.conf 文件，取消 SystemMaxUse 参数前面的注释，将其修改为我们想设置的 systemd 日志最大占用空间即可，例如限制其最大占用 256M 空间：\n[Journal]#Storage=auto#Compress=yes#Seal=yes#SplitMode=uid#SyncIntervalSec=5m#RateLimitIntervalSec=30s#RateLimitBurst=10000SystemMaxUse=256M#SystemKeepFree=#SystemMaxFileSize=#SystemMaxFiles=100\n\n保存配置文件后需要重启 systemd-journald 服务才能生效：sudo systemctl restart systemd-journald\n","categories":["技术教程"],"tags":["Linux","常用命令"]},{"title":"浏览器野史 —— UserAgent 列传【转载】","url":"/2019/825/","content":"某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。控制台敲下：navigator.userAgent浏览器回应：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\n\n\n天，这串是啥？你怎么连话都说不清楚？我对 UserAgent 并不陌生，但明明一个单词就可以说清楚的事情，却是这么掏心掏肺的回答。怪可怜的，一定有冤情。后来我查阅了很多资料，发现历史非常的精彩。\n大事年表\n1990年: Nexus ( WorldWideWeb )诞生\n1993年1月23日：Mosaic 诞生\n1994年12月：Netscape ( Mozilla )诞生\n1995年4月：Opera 诞生\n1995年8月16日：Internet Explorer 诞生\n2002年9月23日：Firefox 诞生\n2003年1月7日：Safari 诞生\n2008年9月2日：Chrome 诞生\n\n一、盘古开天地很久很久之前，上古大神 Berners-Lee 发明了 WorldWideWeb ，即万维网。同时，李大神也发明了第一款浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神内心的想法又岂是尔等凡人能够肆意揣摩？\n万万没想到，李大神说，我这浏览器，也叫 WorldWideWeb ！不行么？行行行。\n虽然李大神起名字这么拽，但他后来发觉，还是得赋予一点承上启下的历史意义，就改名成“Nexus”。值得注意的是，这浏览器，居然是可以兼容 Unix 跟 Microsoft DOS 的。它在当时流行的各种电脑上跑得飞起，应用也越来越广，被称为“杀手级应用”。杀手级…你们看互联网一开始就是这么的腥风血雨。\n但这个浏览器，还不支持图片的显示，这是出现 UserAgent 的导火索。\n二、唐尧虞舜93 年，伊利诺大学的 NCSA 组织认为，浏览器无图无真相，这不好。因而他们发明了第一款可显示图片的浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神就是连起名字都让你惊心动魄。\nNCSA 组织说，它能显示图片，偏偏我们就要叫它“马赛克( Mosaic )”！不行么？行行行。\n但有人就问了，Nexus 不显示图片，Mosaic 能显示，你们让 html 提供者怎么写代码？你们是不是想逼死选择困难症患者？有没有考虑过天秤座的感受？\n因而 UserAgent 就诞生了。Mosaic 将自己标志为 NCSA_Mosaic/2.0 (Windows 3.1) ，大家该怎么写代码就怎么写，但请求会带上这个信息，服务器就知道该不该返回能显示图片的 html 。UserAgent 君，出生时跟我们设想的一样简单，仅仅标明了自己是什么浏览器，在什么系统运行，以及各自的版本号。\n新旧浏览器们像彬彬有礼的君王，商议和让位是为了更好的繁荣。但风雨欲来。\n三、楚汉争霸像刘邦一样，走出来一个搅局的小流氓。当然他还是很有志向的，他的目标，就是战胜霸主 Mosaic。后来，他还真的做到了。如今，所有现代浏览器的 UserAgent 里都有它的标志，就像汉朝之后，我们都称为“汉”人。一群很有天赋的程序员，一起缔造了它的辉煌。\n真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是让你永远也猜不到他们想了个什么名字。大神们说，叫 Mozilla，不行么？行。但什么意思呢？\n含义有二。其一，哥斯拉( Godzilla )谐音，诚然是一头野心勃勃的怪兽；其二，”Mosaic Killa”之意， Killa 是俚语中 Killer 的拼法，即“马赛克的终结者”，赤裸裸的挑战。\n惊呆了的 Mosaic 小心翼翼的念着 Mozilla 这发音：“Mo…摸咋了？”勃然大怒，“摸你妹！”\n鉴于 Mosaic 当时的权势，Mozilla 改名成 Netscape Navigator (网景航海家)。小怪兽突然变成有点文艺小清新的名字，郁闷得很，但内心的血液沸腾着。虽然叫大名叫网景，但它把 UserAgent 偷偷设置成 Mozilla/1.0 (Win3.1) 。还是摸咋了？咬我？\n四、宋元之战很快， NetScape 战胜了 Mosaic ，成为了新的霸主，因为其更优的展示。NetScape 最先支持了 html 框架显示，就是简单的 table 布局，内外边距之类，仅仅这点就将 Mosaic 抛诸身后。区别这两个浏览器，还是用的 UserAgent 。如果是 UserAgent 里含有“Mozilla”字样，那就发送支持框架的页面，否则，就发送不含框架的页面。\nNetScape 帝国日益庞大，歌舞升平，一切风平浪静，直到微软的铁骑挥军南下。\n微软发布了一款跟系统强绑定的浏览器，真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？不用想了，就是 IE 。这命名也相当简单粗暴， Internet Explorer ，直接把这工具的用途拍在你脸上。连说明书都可以免了。\nIE也是支持 html 标准框架的，但由于前面的历史原因，人们只会给 UserAgent 里含有“Mozilla”字样的浏览器发送含框架的页面。但这点小事能难倒我大微软？ IE 呵呵一笑，把自己的 UserAgent 改成 Mozilla/1.22 (compatible; MSIE 2.0; Windows 95) 。看，我这里也有 “Mozilla” 字样，也能收到含框架的页面了！\n当然，这个小流氓行为，跟后来把 IE 和 Windows 捆绑一起销售的大流氓行为比起来，根本不为足道。后面的故事我们也知道了， IE 把 NetScape 干掉了。但它的身体上，却永远的烙上了“Mozilla”的印记。\n五、康乾盛世看过奥特曼的都知道，怪兽被打败了会再回来。别忘了 NetScape 曾拥有一批大神们，失败后，他们围绕着浏览器排版引擎 Gecko (壁虎)成立了非正式组织 Mozilla 。小怪兽再次出发。大神们发明了另一款优秀的浏览器，它在插件拓展和开发调试领域做出的贡献，绝对可以载入互联网历史。\n真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是即使你知道了 Mozilla 的命名都是野兽，却还是猜不到是什么。Mozilla 说，我们浴火重生，叫 Phoenix (凤凰)！不行么？真不行。\n刚推出就被人告了，原来已经有一家公司叫做“凤凰科技”。Mozilla 瀑布汗，改名叫 Firebird (火鸟)！还不行么？我们得原谅一下他们的取名，虽然现在看来满满的山寨感，可放在那个时代， Firebird 这名字很炫酷。就像你当初的 QQ 昵称叫赤炎天使感觉依然良好一样。\n但是，他们发现，业内有个数据库系统，也叫的 Firebird …泪流满面的 Mozilla 感慨重生好难呀。最后才决定叫Firefox (火狐)。\n基于 Gecko 引擎的 Firefox 非常优秀，为了告诉大家，我使用了这个引擎，它标志自己的 UserAgent 为 Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0 。这时候的 UserAgent ，虽然长了点，但它并不混乱，准确的标明了系统，排版引擎，浏览器名称等信息。虽然 IE 这时已经占有了很大的市场份额，但基本停步不前；而 Mozilla 经过一段时间的修生养息，Firefox 在业内广受好评，得到了快速的发展。\n时值 2003 年， web2.0 的浪潮前夕，浏览器的发展达到了空前的盛世。然而所谓否极泰来，盛极则衰。涅槃的 Firefox 迎来盛世，却又恰恰由于盛世，决定了 UserAgent 纠结的命运。\n六、师夷长技前面说到，微软靠 Windows 系统捆绑IE销售。而 Windows 自然也有它的对手，Linux 。一个技术快速发展的时代，系统的世界里也是战火纷飞。 Linux 系统自从有了可视化界面，也需要浏览器呀。桌面系统 KDE 的缔造者们就发明了一个。\n真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是讲究先从文字上占据压垮你的气势。先有 Navigator 航海家，再有 Explorer 探索者，咱就叫 Konqueror ( Conqueror 的变体)征服者吧。行行行。我已懒得理这帮大神…\n可是，问题来了。 Konqueror 使用 KHTML 排版引擎，即使它们认为自己跟 Gecko 引擎一样优秀，但用户不买单。你 UserAgent 里没有“Gecko”字样，我就不给你经过优良排版的 html。结果， Konqueror 思来想去，做了一个艰难但很萌的决定，把 UserAgent 写成 Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko) …这就是现代浏览器里 like Gecko 这一萌词的由来。\n就这样，伟大的排版引擎 KHTML 为了获得更好的资源，师夷长技。这并没什么不好，却造成了 UserAgent 的越发混乱。KHTML 与 Gecko 这一对，永远卿卿我我比翼双飞在 UserAgent 里面了。那个满含深意的“like”，有人觉得翻译成“像”，但也有人觉得应该是“喜欢”…\n七、世界大战首先是 IE 冷静下来了，他觉得，你们不带这么玩的？就我年少时不懂事，首先改了个 Mozilla 字样，后面追究这历史我岂不是成了罪魁祸首？我改还不行吗？在 IE6 ，它明确自己 UserAgent 为 Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) 。除去已经注定不可抹去的“Mozilla”字样，其余信息简洁，准确，清晰。\n但事态已经不可收拾。\nOpera 给这狂躁的世界添了一把火。它觉得，易容术非常炫酷呀。Opera 直接在菜单提供了 Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51 ， Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51 ， Opera/9.51 (Windows NT 5.1; U; en) 三个选择项。第一个是易容成 IE ，第二个是易容成火狐，第三个才是自己，选谁就是谁！\n其实这并不是一件坏事。因为 Opera 是站在能够让用户通过选择，去获得更好的浏览体验的基础上的。你提供选择，或是不提供，混乱的 UserAgent 还是在这，不离，不弃。再者，这对网页的开发者有极大的好处，在某些情况，你不必同时打开几个不同的浏览器去调试。到目前，最新的 Chrome 浏览器更加炫酷，能够支持近 40 种不同的 UserAgent ，甚至你还可以自定义。当然这是后话。\n与此同时，苹果公司依靠内核 WebKit ，开发出 Safari ，命名 UserAgent 为 Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5 。\n有人就会问了，不是 Webkit 内核吗，怎么还有 KHTML, like Gecko ？注意，内核 Webkit 包含了一个排版引擎叫 WebCore ，而 WebCore 是 KHTML 衍生而来的。也就是说， WebCore 是 KHTML 的儿子，子承父业，基因差不多。为了能够正常排版， safari 只能这么写。\n后来， google 也开发了自己的浏览器 Chrome ，其内核也是 Webkit ，但它设定 UserAgent 为 Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13 。Safari一看，不对劲啊！你怎么也在后面写有 Safari ？ Chrome 呵呵一笑，你懂的。\n因此，请让我一口气说完下面这一段：Chrome 希望能得到为 Safari 编写的网页，于是决定装成 Safari ， Safari 使用了 WebKit 渲染引擎，而 WebKit 呢又伪装自己是 KHTML ， KHTML 呢又是伪装成 Gecko 的。同时所有的浏览器又都宣称自己是 Mozilla 。\n这就是整个 UserAgent 世界大战的格局…\n八、军阀混战将目光聚焦到国内，更是狼烟四起，混乱不堪。大家都知道，浏览器是互联网的入口，这块肥肉谁也不想丢。因而一个接一个的“国产”浏览器进入斗兽场。360 ，百度， QQ ， UC ，搜狗，猎豹，遨游，世界之窗…你能说出一大堆。连淘宝，酷狗， hao123 都有浏览器，不信你搜。注意我前面“国产”两个字必须加上双引号，因为这个 made in china 并不纯。国人并没能像远古大神一样，硬生生发明一个内核出来，我们更擅长“微创新”。\n利用 Trident （ IE 的内核），包装一下皮肤，美化一下，就可以说：完美兼容利用 Webkit ，包装一下皮肤，美化一下，就可以说：极速浏览把两个内核都包起来，就可以说：智能双核\n是微创新！读书人的事，能叫偷吗？\n在这插播一下，浏览器的“双核”，并不是你听说手机双核电脑双核那回事。再多个核，速度也不会更快，当然这么说，会显得很厉害的样子。德艺双馨，智勇双全，名利双收，才貌双绝，夫妻双双把家还，你看带“双”字的词都很牛的。\n但我上面的叙述，的确有夸张的成分。浏览器的诞生，肯定不仅仅是包一下皮肤那么简单，国内的工程师们，也苦心研究做了许多工作。如果要说优化策略，我可以再写一篇超级长的文章。优化无止境，路漫漫其修远，向同行们致敬。只是我非常讨厌那些不把事实说清楚，纯粹靠文案去忽悠人的产品…\n话说回来，这么多国产浏览器，总得靠不同 UserAgent 标志自己呀。大家自动分为两个阵营：使用 Trident 内核的，在 IE 已有 UserAgent 后添加自己的名称；使用 Webkit 内核的，就在 Chrome 的 UserAgent 后面添加。\n前者像 QQ 浏览器： Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.7.26717.400) 。后者像猎豹： Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER 。当然双核浏览器诚然就是墙头草，切换内核时 UserAgent 也需要跟着变化。\n如此的混战格局，这厢的 IE 和 Chome 想必也是醉了。\n九、国共内战适者生存是不变的生存法则，国产浏览器们经过一段时间的用户筛选，自然优胜劣汰。时值 2010 年，真正还在运营和更新的浏览器数量慢慢下降，用户集中在几家表现更优异的厂商手中。就在这时，好看的故事来了—— 3Q 大战爆发。\n有人说，腾讯电脑管家的推出是导火索。其实这场仗，大家都忍了好久，推不推出，都一定会在某个事件后爆发。 360 浏览器是奇虎的重量级产品，用户量众多， 2009 年它推出一个功能：过滤其它网站的广告。诚然民众们都很喜欢。可是其他互联网公司肯定就不乐意了，用户看不到更点击不到广告，这钱还怎么赚？\n因而在 3Q 大战爆发后，腾讯的一个手段就是：如果你使用 360 浏览器，就不能访问 QQ 的网站（单单 QQ 空间就有巨大的用户量），也直接反攻 360 的最大收入来源。一个艰难的决定背后，往往是需要无数种的技术战略支撑的。企鹅判断用户是否使用 360 浏览器，依靠的就是 UserAgent 里是否有“360SE”的字样。\n战报传来：号外， 360 浏览器上不了 QQ 空间！已经买了黄钻的杀马特贵族急了呀！只能换浏览器了呀！感覺侢乜卟哙噯嘞呀！2011年11月3日，腾讯网站封杀 360 浏览器2011年11月4日，360 浏览器访问量仅为昨日一半2011年11月5日，360 浏览器访问量几乎为 0\n有人说，腾讯就这么快赢了？恰恰相反，360 浏览器通过一次强制的自动升级，又可以访问 QQ 的网站了。 360 的工程师们在 5 日使用了伪装术——把“360SE”字样从 UserAgent 中去掉！意思就是， 360 浏览器的 UserAgent 跟 IE 完全一样，你根本判断不出来（因而访问量为 0 ）。就怕流氓有文化！企鹅傻眼了，总不能把大微软的 IE 也一并给禁了吧…\n这场土匪遇恶霸的耍流氓大战，最终通过法律而化解。企鹅在技术侧拿 360 没办法，而 360 则得到了一个跟 IE 一样的身份证。在这场内战中，受伤的除了广大网民们，其实还有令人心疼 UserAgent 君，以往让它越长越长就算了，这次长了还得阉割掉，真心 dan 疼呀。\n十、明日边缘看到这里，大家会明白一个道理：如果未来不出现一款霸主级别的浏览器（或内核）， UserAgent 应该不会有大变化了。不过，这道理并不全对。别忘了，移动侧也是有浏览器的。在早期能上网的手机里，内置了各手机厂商自研的浏览器。这些浏览器并不需要像 PC一样的复杂设计，可以访问 wap 网页就足够了。因而它们的 UserAgent 命名，怎么简单怎么来，就直接叫 诺基亚 3100 Nokia3100/06.01 (UCWEB 3.3B) ， PHILIPS755 ObigoInternetBrowser/2.0 这样，有甚者连浏览器叫什么都不带 TCL-3199 ， 三星 E618 SEC-SGHE618 。\n这样任由发展下去，一种要历史重演，往日重现的即视感压迫而来。web 世界的联合国 —— W3C 组织，站在明日边缘，面对着历史和未来，终于发话，它制定 UserAgent 标准，以后都得按这规范去起名字。详细请阅 User Agent Accessibility Guidelines 。至此，命运坎坷的 UserAgent 终于逐步走向规范。 W3C 大法好，有人说你怎么不早点来拯救世界呀！其实 W3C 一直在努力，但规范的制定，到推广至大家认可并执行，是一条漫长的道路，需要时间，也需要实践。W3C 组织，在制定 web 标准这件工作之外，再我看来，还有两个身份：1、和事佬；2、背黑锅。和事不成，就得背黑锅。是的就是这样。\n彩蛋那么，我们的故事接近尾声。还有一些有趣的小彩蛋。\n\nChome 28 开始，与苹果正式分道扬镳，采用 Blink 内核，但它的 UserAgent 并不改变。\n淘宝封杀微信打开淘宝页面，靠的就是微信内置浏览器 UserAgent 里的 MicroMessenger 字样。其实微信也可以像当初 360 一样把 UserAgent 去掉，但微信并不这样做。\n360 出招之时留有后招。也许，它一开始就想到了腾讯会告他们对于 UserAgent 的欺瞒，因而它其实提供了设置项。默认设置是“保持跟 IE 一样的 UserAgent ”，但用户也可以不勾选。只是这选项比较隐蔽，而且你重启浏览器后…又会变回默认设置。如果没有这个小小的设置，结果大家可以自行想象。\n微软又玩新花样了，在泄露版 IE11 中，去掉了以往的 MSIE 字样。初步猜测此举是为了使现有的 CSS hack  失效，避免过去网页设计师对 IE 差别对待的情况再度发生。但又会引发其他问题啊亲。\n\n注：本文转载自 Litten 的文章“浏览器野史 UserAgent 列传 (上) (下)” ，内容二合一，特此注明！\n","categories":["逸趣杂谈"],"tags":["杂谈","浏览器","转载","UserAgent"]}]